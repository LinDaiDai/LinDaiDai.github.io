<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.8.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>霖呆呆的函数式编程之路(三) - LinDaiDai</title>
  

  
  
  <meta name="description" content="">
  <meta name="author" content="LinDaiDai">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/wang.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class="header">
	<div class="header-title">
		
		<div class="header-logo">
			<a href="/">
				<img src="/images/lindaidai-logo.jpg">
			</a>
		</div>
		<div class="header-text">
			<h1>
				<a href="/">LinDaiDai</a>
			</h1>
			<subtitle>
				王霈霖的个人博客
			</subtitle>
		</div>
		
	</div>
	<div id="header-nav">
		



<nav id="nav">
	
	
		
			
		
		
			<div class="nav-item">
				
					<div class="nav-name">
				
					<a class="nav-link" href="/home/">
						<span>首页 </span>
					</a>
				</div>
			</div>
		
	
		
			
		
		
			<div class="nav-item">
				
					<div class="nav-name">
				
					<a class="nav-link" href="/about/">
						<span>关于 </span>
					</a>
				</div>
			</div>
		
	
	
	<div class="nav-item" id="nav-item-toc">
		


<div class="toc-container">
<i class="far fa-times-circle" id="toc-close" onclick="closeTOC(event);" ontouchstart="closeTOC(event);"></i>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#只要一个实参"><span class="toc-number">1.</span> <span class="toc-text">只要一个实参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unary函数"><span class="toc-number">1.1.</span> <span class="toc-text">unary函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sum案例"><span class="toc-number">1.1.1.</span> <span class="toc-text">sum案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传一个返回一个"><span class="toc-number">2.</span> <span class="toc-text">传一个返回一个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#identity函数"><span class="toc-number">2.1.</span> <span class="toc-text">identity函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#转换函数的妙用"><span class="toc-number">2.1.1.</span> <span class="toc-text">转换函数的妙用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#恒定参数"><span class="toc-number">3.</span> <span class="toc-text">恒定参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Certain-API"><span class="toc-number">3.1.</span> <span class="toc-text">Certain API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constant函数"><span class="toc-number">3.2.</span> <span class="toc-text">constant函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展在参数中的妙用"><span class="toc-number">4.</span> <span class="toc-text">扩展在参数中的妙用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不需要顺序的柯里化和偏应用"><span class="toc-number">5.</span> <span class="toc-text">不需要顺序的柯里化和偏应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#partialProps和curryProps"><span class="toc-number">5.1.</span> <span class="toc-text">partialProps和curryProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性扩展"><span class="toc-number">5.2.</span> <span class="toc-text">属性扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spreadArgProps函数"><span class="toc-number">5.2.1.</span> <span class="toc-text">spreadArgProps函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无形参风格"><span class="toc-number">6.</span> <span class="toc-text">无形参风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not函数"><span class="toc-number">7.</span> <span class="toc-text">not函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#when函数"><span class="toc-number">8.</span> <span class="toc-text">when函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printIf案例"><span class="toc-number">8.1.</span> <span class="toc-text">printIf案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list案例"><span class="toc-number">8.2.</span> <span class="toc-text">list案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<div class="toc-button" onclick="toggleTOC(event);" ontouchstart="toggleTOC(event);">
    <img src="/images/icons/blue-shadow/toc.svg" alt="">
</div>

	</div>
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="归档">
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon">
		
			<a href="/search/" title="搜索">
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/home/">
							<span>首页</span>
						</a>
					</div>
			</div>
		
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/about/">
							<span>关于</span>
						</a>
					</div>
			</div>
		
		
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/php/">
						<span>Php</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/mySql/">
						<span>Mysql</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/其它技能/">
						<span>其它技能</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/vscode/">
						<span>Vscode</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端进阶/">
						<span>前端进阶</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端入门/">
						<span>前端入门</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 

  




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>




	
	
	
	



    
        
            
            
        
    






    
    
        
    

    
        
    









<article class="article" id="/2019/06/27/webNotes/advanced/Functional/ch_3/" data-name="霖呆呆的函数式编程之路(三)" data-version="">

    <!-- Title -->
    <div class="article-header">
         
         <div class="article-logo">
            <a href="#" data-no-instant="">
                <img src="/images/前端进阶.svg" alt="" onerror="if(this.src != " images="" uncategorized.svg")="" this.src="/images/uncategorized.svg" "="">
            </a>
         </div>
         
         <h1 class="article-title">
            <a href="/2019/06/27/webNotes/advanced/Functional/ch_3/">
                霖呆呆的函数式编程之路(三)
            </a>
        </h1>
        <!-- TODO: support nested categories,display them nicely -->
        
        <ul class="article-categories">
            
            
                <li><a href="/categories/前端进阶/" data-no-instant="">
                    <img src="/images/前端进阶.svg" alt="前端进阶" onerror="if(this.src != " images="" uncategorized.svg")="" this.src="/images/uncategorized.svg" "="" title="前端进阶">
                </a></li>
            
        </ul>
        
    </div>
    
    <!-- Date and Author -->
    <div class="article-meta">
    <ul>
            <li><i class="fa fa-calendar"></i> 2019年06月27日</li>
            
            <li class="comment-button"><a href="#article-comment"><i class="fa fa-comments"></i> <span id="article-comment-count">0</span></a></li>
            <li><i class="fa fa-eye"></i> <span id="article-visit-count">0</span></li>
            <li class="thumb-up-button" id="thumb-up-button"><i class="far fa-thumbs-up fa-lg" id="thumb-up-icon"></i> <span id="article-thumbup-count">0</span></li>
            
            <li><i class="fa fa-user"></i> LinDaiDai</li>
            <li><i class="fas fa-copyright"></i>
            
                
                
            
            
                
                    
                
                <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">CC BY-NC-ND 4.0</a>
            
            </li>
    </ul>
    
<div class="tags">
	
		
			<label class="tag-1"><a href="/tags/Functional/">Functional</a></label>
		
	
		
			<label class="tag-2"><a href="/tags/前端进阶/">前端进阶</a></label>
		
	
	</div>

    </div>
    <div class="article-cards">
        <!-- Author Card -->
        <!---
        <div class='Card-article Card-author'>
            <div class='card-title'>
                <h3></h3>
            </div>
            <div class='card-content'>
                    <div class="author-meta">
                            <div class='author-figure'>
                                <img src="" alt="">
                            </div>
                            <div class='author-name'>
                                LinDaiDai
                            </div>
                        </div>
                        <div class="author-ai">
                            <div class='author-intro'>
                                <!-- TODO: auto generating author description -->
                                <!-- 
                            </div>
                            <div class="author-articles">
                                <!-- TODO: auto generating author articles -->
                                <!-- <ul>
                                    <li>Article 1</li>
                                    <li>Article 2</li>
                                    <li>Article 3</li>
                                    <li>Article 4</li>
                                    <li>Article 5</li>
                                    <li>Article 6</li>
                                </ul>
                            </div>
                        </div>
            </div>
            
        </div> -->

        <!-- Visit Card -->
        <!-- <div class="Card-article Card-visit"> -->
            <!-- <div class="card-title">
  <h3>Post Visit</h3>
</div>
<div class="card-chart">
  <div id="chart-post-visit"></div>
</div> -->
        <!-- </div> -->
        
        <!-- Auto Excerpt Card -->
        <!-- <div class="Card-article Card-excerpt">
            <div class="card-title">
  <h3>Quick Read</h3>
</div>
<div class="card-text">
  <p id="text-post-summary">只要一个实参unary函数先来看一个奇怪的例子：
123456// example1["1","2","3"].map( parseFloat );// [1,2,3]["1","2","3"].map( parseInt );// [1,NaN,NaN]
在上面的例子中，我想要将一组字符串全部设置成数字类型，但是在调用parseInt的时候，却出现了这样怪异的事情。这是为什么呢？
首先我们来说一下parseInt(str,radix)这个函数，它接受两个参数，第一个是要被解析的字符串，第二个为可选参数，表示要解析的数字的基数。该值介于 2 ~ 36...</p>
</div>
        </div> -->
    </div>
    
    <!-- Gallery -->
    <!-- TODO: add a slider to gallery -->
    

    <!-- Content -->
    <!-- TODO: support table of content -->
    <div class="article-toc" id="article-toc">
    
        


<div class="toc-container">
<i class="far fa-times-circle" id="toc-close" onclick="closeTOC(event);" ontouchstart="closeTOC(event);"></i>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#只要一个实参"><span class="toc-number">1.</span> <span class="toc-text">只要一个实参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unary函数"><span class="toc-number">1.1.</span> <span class="toc-text">unary函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sum案例"><span class="toc-number">1.1.1.</span> <span class="toc-text">sum案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传一个返回一个"><span class="toc-number">2.</span> <span class="toc-text">传一个返回一个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#identity函数"><span class="toc-number">2.1.</span> <span class="toc-text">identity函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#转换函数的妙用"><span class="toc-number">2.1.1.</span> <span class="toc-text">转换函数的妙用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#恒定参数"><span class="toc-number">3.</span> <span class="toc-text">恒定参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Certain-API"><span class="toc-number">3.1.</span> <span class="toc-text">Certain API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constant函数"><span class="toc-number">3.2.</span> <span class="toc-text">constant函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展在参数中的妙用"><span class="toc-number">4.</span> <span class="toc-text">扩展在参数中的妙用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不需要顺序的柯里化和偏应用"><span class="toc-number">5.</span> <span class="toc-text">不需要顺序的柯里化和偏应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#partialProps和curryProps"><span class="toc-number">5.1.</span> <span class="toc-text">partialProps和curryProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性扩展"><span class="toc-number">5.2.</span> <span class="toc-text">属性扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spreadArgProps函数"><span class="toc-number">5.2.1.</span> <span class="toc-text">spreadArgProps函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无形参风格"><span class="toc-number">6.</span> <span class="toc-text">无形参风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not函数"><span class="toc-number">7.</span> <span class="toc-text">not函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#when函数"><span class="toc-number">8.</span> <span class="toc-text">when函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printIf案例"><span class="toc-number">8.1.</span> <span class="toc-text">printIf案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list案例"><span class="toc-number">8.2.</span> <span class="toc-text">list案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<div class="toc-button" onclick="toggleTOC(event);" ontouchstart="toggleTOC(event);">
    <img src="/images/icons/blue-shadow/toc.svg" alt="">
</div>

    </div>
    <div class="article-content">
    <h2 id="只要一个实参"><a href="#只要一个实参" class="headerlink" title="只要一个实参"></a>只要一个实参</h2><h3 id="unary函数"><a href="#unary函数" class="headerlink" title="unary函数"></a>unary函数</h3><p>先来看一个奇怪的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( <span class="built_in">parseFloat</span> );</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( <span class="built_in">parseInt</span> );</span><br><span class="line"><span class="comment">// [1,NaN,NaN]</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我想要将一组字符串全部设置成数字类型，但是在调用<code>parseInt</code>的时候，却出现了这样怪异的事情。这是为什么呢？</p>
<p>首先我们来说一下<code>parseInt(str,radix)</code>这个函数，它接受两个参数，第一个是要被解析的字符串，第二个为可选参数，表示要解析的数字的基数。该值介于 2 ~ 36 之间,比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>);			<span class="comment">//返回 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"19"</span>,<span class="number">10</span>);		<span class="comment">//返回 19 (10+9)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"11"</span>,<span class="number">2</span>);		<span class="comment">//返回 3 (2+1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当参数 <em>radix</em> 的值为 0，或没有设置该参数时，parseInt() 会根据 <em>string</em> 来判断数字的基数。</li>
<li>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</li>
</ul>
<p>而在案例1中，由于我们在调用<code>map</code>的时候，函数时会传入三个实参：<code>value</code>、<code>index</code> 和 <code>list</code>。<code>parseInt()</code>又会接收2个参数，所以每次都相当于是将<code>value</code>和<code>index</code>传入进去了。这样就造成后面2个<code>NaN</code>的情况。</p>
<p>根据上面，我们可以看到，在实际开发中，我们会面临这样一个问题：在设计一个实用函数传入一个函数，而这个实用函数会把多个实参传入函数，但可能你只希望你的函数接收单一实参。如上面的<code>parseInt()</code>函数，我在调用它的时候希望它每次只接收一个参数。</p>
<p>根据上面的需要，我们是不是可以来实现这么一个简单的实用函数，它包装一个函数调用，让这个函数在每次调用的时候只接收一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unary</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">onlyOneArg</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn(arg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> unary = <span class="function"><span class="params">fn</span> =&gt;</span> </span><br><span class="line">							arg =&gt; </span><br><span class="line">										fn(arg);</span><br></pre></td></tr></table></figure>
<p>很简单的一层封装，也很好理解。</p>
<p>现在我们用它来配合上面的案例1:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( <span class="built_in">parseFloat</span> );</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( <span class="built_in">parseInt</span> );</span><br><span class="line"><span class="comment">// [1,NaN,NaN]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( unary( <span class="built_in">parseInt</span> ) );</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<h4 id="sum案例"><a href="#sum案例" class="headerlink" title="sum案例"></a>sum案例</h4><p>了解了上面的<code>unary</code>函数之后，我们来看一个复杂一些的案例。还是用<code>map</code>函数来进行举例，不过要用到我们在第二章讲到的松散型柯里化<code>looseCurry</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">looseCurry</span>(<span class="params">fn, arity = fn.length</span>) </span>&#123; <span class="comment">// 松散型柯里化</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">nextCurried</span>(<span class="params">prevArgs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...nextArgs</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> args = prevArgs.concat(nextArgs)</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt;= arity) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn(...args)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nextCurried(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)([])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum += args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> adder = looseCurry(sum, <span class="number">2</span>) <span class="comment">// 第一步 传2表示至少接收2个参数才可以</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.map(adder(<span class="number">3</span>)) <span class="comment">// 第二步</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"><span class="comment">// 生成的结果很有意思</span></span><br><span class="line"><span class="comment">// ["41,2,3,4,5", "61,2,3,4,5", "81,2,3,4,5", "101, ...</span></span><br></pre></td></tr></table></figure>
<p>大家可以先将这段代码在本地跑一下，并思考为什么会出现这样的情况？🤔</p>
<p>其实原理很简单：</p>
<p>在第一步的时候，创建<code>adder</code>函数，只有在接收2个及以上参数才会运行<code>sum()</code>，</p>
<p>第二步的时候，由于<code>map()</code>会传入3个实参：分别是<code>value</code>,<code>index</code>和<code>list</code>，而松散型的柯里化是可以接收比预期(这里也就是2)多的参数的。</p>
<p>所以在每次执行<code>sum</code>函数的时候，实际传入的都是3个参数，比如<code>arr</code>执行第一次的时候：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一次传入：</span><br><span class="line">firstArg: <span class="number">3</span>,   <span class="comment">// 调用adder()时传入的3</span></span><br><span class="line">value: <span class="number">1</span>, <span class="comment">// 数组第一项的值</span></span><br><span class="line">index: <span class="number">0</span>, <span class="comment">// 数组第一项的索引</span></span><br><span class="line">list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment">// 整个数组</span></span><br><span class="line"><span class="comment">// 前面3项相加为数字4，之后数字4与数组做字符串相加</span></span><br><span class="line">=&gt; <span class="number">3</span> + <span class="number">1</span> + <span class="number">0</span> + [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">=&gt; <span class="string">"41,2,3,4,5"</span></span><br><span class="line"></span><br><span class="line">第二次传入</span><br><span class="line">firstArg: <span class="number">3</span>,</span><br><span class="line">value: <span class="number">2</span>,</span><br><span class="line">index: <span class="number">1</span>,</span><br><span class="line">list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>此时，使用我们的<code>unary</code>函数就可以解决上面的问题了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr.map( unary( adder(<span class="number">3</span>) ) )</span><br><span class="line"><span class="comment">// [4,5,6,7,8]</span></span><br></pre></td></tr></table></figure>
<h2 id="传一个返回一个"><a href="#传一个返回一个" class="headerlink" title="传一个返回一个"></a>传一个返回一个</h2><h3 id="identity函数"><a href="#identity函数" class="headerlink" title="identity函数"></a>identity函数</h3><p>说到只传一个实参的函数，在函数式编程工具库中有另一种通用的基础函数：该函数接收一个实参，然后什么都不做，原封不动地返回实参值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function identity(v) &#123;</span><br><span class="line">	return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6 箭头函数形式</span><br><span class="line">var identity =</span><br><span class="line">	v =&gt;</span><br><span class="line">		v;</span><br></pre></td></tr></table></figure>
<p>举个例子，想象一下你要用正则表达式拆分（split up）一个字符串，但输出的数组中可能包含一些空值。我们可以使用 <code>filter(..)</code> 数组方法（下文会详细说到这个方法）来筛除空值，而我们将 <code>identity(..)</code> 函数作为 <code>filter(..)</code> 的断言：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="string">"   Now is the time for all...  "</span>.split( <span class="regexp">/\s|\b/</span> );</span><br><span class="line">words;</span><br><span class="line"><span class="comment">// ["","Now","is","the","time","for","all","...",""]</span></span><br><span class="line"></span><br><span class="line">words.filter( identity );</span><br><span class="line"><span class="comment">// ["Now","is","the","time","for","all","..."]</span></span><br></pre></td></tr></table></figure>
<h4 id="转换函数的妙用"><a href="#转换函数的妙用" class="headerlink" title="转换函数的妙用"></a>转换函数的妙用</h4><p>另一个使用 <code>identity(..)</code> 的示例就是将其作为替代一个转换函数（译者注：transformation，这里指的是对传入值进行修改或调整，返回新值的函数）的默认函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">msg,formatFn = identity</span>) </span>&#123;</span><br><span class="line">	msg = formatFn( msg );</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upper</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> txt.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output( <span class="string">"Hello World"</span>, upper );		<span class="comment">// HELLO WORLD</span></span><br><span class="line">output( <span class="string">"Hello World"</span> );			<span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>上面的例子，相当于是给<code>output</code>函数一个默认的函数，若是没有传的话，则原封不动的返回传进来的<code>msg</code>。</p>
<h2 id="恒定参数"><a href="#恒定参数" class="headerlink" title="恒定参数"></a>恒定参数</h2><h3 id="Certain-API"><a href="#Certain-API" class="headerlink" title="Certain API"></a>Certain API</h3><p>Certain API 禁止直接给方法传值，而要求我们传入一个函数，就算这个函数只是返回一个值。JS Promise 中的 <code>then(..)</code>方法就是一个 Certain API。</p>
<p><code>then(..)</code>中必须要传入一个函数，而有时候我们可能不需要传入一个有实际用处的函数，而是直接返回<code>then</code>在上一步中获取到的值。</p>
<p>或许你可以用<code>ES6</code>的箭头函数解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.then( foo ).then( <span class="function"><span class="params">()</span> =&gt;</span> p2 ).then( bar )</span><br></pre></td></tr></table></figure>
<p>在第二个<code>then</code>中直接将<code>p2</code>返回。</p>
<h3 id="constant函数"><a href="#constant函数" class="headerlink" title="constant函数"></a>constant函数</h3><p>我们可以来构造一个实用函数来实现上面的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constant</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or the ES6 =&gt; form</span></span><br><span class="line"><span class="keyword">var</span> constant =</span><br><span class="line">	v =&gt;</span><br><span class="line">		() =&gt;</span><br><span class="line">			v;</span><br></pre></td></tr></table></figure>
<p><code>constant</code>函数功能也很简单，返回传入的参数。</p>
<p>对比：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1.then( foo ).then( <span class="function"><span class="params">()</span> =&gt;</span> p2 ).then( bar );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：</span></span><br><span class="line"></span><br><span class="line">p1.then( foo ).then( constant( p2 ) ).then( bar );</span><br></pre></td></tr></table></figure>
<p>两种方式都可以解决<code>Certain API</code>的问题。但是我更建议用第二种方式，该箭头函数返回了一个来自外作用域的值，这和 函数式编程的理念有些矛盾。在后面“减少副作用”中会提到该行为的不足。</p>
<h2 id="扩展在参数中的妙用"><a href="#扩展在参数中的妙用" class="headerlink" title="扩展在参数中的妙用"></a>扩展在参数中的妙用</h2><p>在第一章中，我们提到了形参数组解构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> [x,y,...args] </span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x, y, args)</span><br><span class="line">	<span class="comment">// 1, 2, [3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br></pre></td></tr></table></figure>
<p>当函数必须接收一个数组，而你却想把数组内容当成单独形参来处理的时候，这个技巧十分有用。</p>
<p>然而，有的时候，你无法改变原函数的定义，但想使用形参数组解构。</p>
<p>比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( x + y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	fn( [ <span class="number">3</span>, <span class="number">9</span> ] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar( foo );</span><br><span class="line"><span class="comment">// 3,9undefined</span></span><br></pre></td></tr></table></figure>
<p>由于<code>fn</code>会将实参<code>[3, 9]</code>作为<code>x</code>传入，那么<code>y</code>就是<code>undefined</code>，所以达不到我们期望的效果。</p>
<p>在这种情况下，我们可能想要改变<code>bar()</code>函数的行为，将<code>foo([3, 9])</code>改为<code>foo(…[3, 9])</code>，这样就能将 <code>3</code> 和 <code>9</code> 分别传入 <code>foo(..)</code> 函数了。</p>
<p>为了调整一个函数，让它能把接收的单一数组扩展成各自独立的实参，我们可以定义一个辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spreadArgs</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">spreadFn</span>(<span class="params">argsArr</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn( ...argsArr );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数的形式：</span></span><br><span class="line"><span class="keyword">var</span> spreadArgs =</span><br><span class="line">	fn =&gt;</span><br><span class="line">		argsArr =&gt;</span><br><span class="line">			fn( ...argsArr );</span><br></pre></td></tr></table></figure>
<p><strong>注意⚠️</strong>：</p>
<p>在我参考的教材中，将这个辅助函数叫为<code>spreadArgs</code>，但一些库，比如 <a href="http://ramda.cn/" target="_blank" rel="noopener">Ramda</a>，经常把它叫做 <code>apply(..)</code>。</p>
<p>现在我们可以使用 <code>spreadArgs(..)</code> 来调整 <code>foo(..)</code> 函数，使其作为一个合适的输入参数并正常地工作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar( spreadArgs( foo ) );			<span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>本质上，<code>spreadArgs(..)</code> 函数使我们能够定义一个借助数组 <code>return</code> 多个值的函数，不过，它让这些值仍然能分别作为其他函数的输入参数来处理。</p>
<p>一个函数的输出作为另外一个函数的输入被称作组合（composition），这个在后面的章节中会详细说明。</p>
<p>有了<code>spreadArgs</code>函数，同样的我们也可以定义一个与它功能相反的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gatherArgs</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">gatheredFn</span>(<span class="params">...argsArr</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn( argsArr );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数形式</span></span><br><span class="line"><span class="keyword">var</span> gatherArgs =</span><br><span class="line">	fn =&gt;</span><br><span class="line">		(...argsArr) =&gt;</span><br><span class="line">			fn( argsArr );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Ramda 中，该实用函数被称作 <code>unapply(..)</code>，是与 <code>apply(..)</code> 功能相反的函数。我认为术语 “扩展（spread）” 和 “聚集（gather）” 可以把这两个函数发生的事情解释得更好一些。</p>
</blockquote>
<h2 id="不需要顺序的柯里化和偏应用"><a href="#不需要顺序的柯里化和偏应用" class="headerlink" title="不需要顺序的柯里化和偏应用"></a>不需要顺序的柯里化和偏应用</h2><p>在上面介绍的多形参柯里化和偏应用中，参数传递都是有一定顺序的。哪一个参数在哪一步才能传，放在第一个位置都是固定好的，要是想进行修正调整可能需要费一番功夫。</p>
<p>这时候我们不得不思考有没有一种方法能让我们从修正参数顺序这件事里解脱出来呢？</p>
<p>或许<strong>解构模式</strong>可以？</p>
<p>在第一章节中，我们提到了命名参数解构模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> &#123;x,y&#125; = &#123;&#125; </span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( x, y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( &#123;</span><br><span class="line">	y: <span class="number">3</span></span><br><span class="line">&#125; );					<span class="comment">// undefined 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到这种解构模式就相当于是一种映射，将调用时传入的实参于函数的形参进行一个映射。</p>
<p>命名实参主要的好处就是不用再纠结实参传入的顺序，因此提高了可读性。</p>
<h3 id="partialProps和curryProps"><a href="#partialProps和curryProps" class="headerlink" title="partialProps和curryProps"></a>partialProps和curryProps</h3><p>有了这样的想法，我们就可以来重新调整一下原先的柯里化<code>curry</code>和偏应用<code>partial</code>了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialProps</span>(<span class="params">fn, presetArgsObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">partialApplied</span>(<span class="params">laterArgsObj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(<span class="built_in">Object</span>.assign(&#123;&#125;, presetArgsObj, laterArgsObj))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryProps</span>(<span class="params">fn, arity = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">nextCurried</span>(<span class="params">prevArgsObj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">nextArgObj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> [key] = <span class="built_in">Object</span>.keys(nextArgObj)</span><br><span class="line">            <span class="keyword">var</span> allArgsObj = <span class="built_in">Object</span>.assign(&#123;&#125;, prevArgsObj, &#123; [key]: nextArgObj[key] &#125;)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(allArgsObj).length &gt;= arity) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn(allArgsObj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nextCurried(allArgsObj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至不需要设计一个 <code>partialPropsRight(..)</code> 函数了，因为我们根本不需要考虑属性的映射顺序，通过命名来映射形参完全解决了我们有关于顺序的烦恼！</p>
<p>现在可以来试试这两个新函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x, y, z &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">`x:<span class="subst">$&#123;x&#125;</span> y:<span class="subst">$&#123;y&#125;</span> z:<span class="subst">$&#123;z&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = curryProps( foo, <span class="number">3</span> );</span><br><span class="line"><span class="keyword">var</span> f2 = partialProps( foo, &#123; <span class="attr">y</span>: <span class="number">2</span> &#125; );</span><br><span class="line"></span><br><span class="line">f1( &#123;<span class="attr">y</span>: <span class="number">2</span>&#125; )( &#123;<span class="attr">x</span>: <span class="number">1</span>&#125; )( &#123;<span class="attr">z</span>: <span class="number">3</span>&#125; );</span><br><span class="line"><span class="comment">// x:1 y:2 z:3</span></span><br><span class="line"></span><br><span class="line">f2( &#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">x</span>: <span class="number">1</span> &#125; );</span><br><span class="line"><span class="comment">// x:1 y:2 z:3</span></span><br></pre></td></tr></table></figure>
<p>我们不用再为参数顺序而烦恼了！现在，我们可以指定我们想传入的实参，而不用管它们的顺序如何。也不需要类似 <code>reverseArgs(..)</code> 的函数或其它妥协了。</p>
<h3 id="属性扩展"><a href="#属性扩展" class="headerlink" title="属性扩展"></a>属性扩展</h3><p>上面的<code>partialProps</code> 看似解决了我们这种多形参无顺序的问题，但是，只有在我们可以掌控 <code>foo(..)</code> 的函数签名，并且可以定义该函数的行为，使其解构第一个参数的时候，以上技术才能起作用。</p>
<p>如果一个函数，其形参是各自独立的（没有经过形参解构），而且不能改变它的函数签名，那我们应该如何运用这个技术呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">`x:<span class="subst">$&#123;x&#125;</span> y:<span class="subst">$&#123;y&#125;</span> z:<span class="subst">$&#123;z&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面的<code>bar</code>函数，接收的就是三个参数，但是我想要能映射到对应的位置，比如这样传：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar(&#123; <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="spreadArgProps函数"><a href="#spreadArgProps函数" class="headerlink" title="spreadArgProps函数"></a>spreadArgProps函数</h4><p>就像之前的 <code>spreadArgs(..)</code> 实用函数一样，我们也可以定义一个 <code>spreadArgProps(..)</code> 辅助函数，它接收对象实参的 <code>key: value</code> 键值对，并将其 “扩展” 成独立实参。</p>
<p>为了满足上面的需求，我们现在需要取得在调用<code>fn</code>时传递的实际参数。</p>
<p>在<code>JS</code>的函数对象上有一个<code>toString()</code>方法，它返回函数代码的字符串形式，其中包括函数声明的签名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spreadArgProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	fn,</span></span></span><br><span class="line"><span class="function"><span class="params">	propOrder =</span></span></span><br><span class="line"><span class="function"><span class="params">		fn.toString(</span>)</span></span><br><span class="line"><span class="function">		.<span class="title">replace</span>(<span class="params"> <span class="regexp">/^(?:(?:function.*\(([^]*?)\))|(?:([^\(\)]+?)\s*=&gt;)|(?:\(([^]*?)\)\s*=&gt;))[^]+$/</span>, <span class="string">"$1$2$3"</span> </span>)</span></span><br><span class="line"><span class="function">		.<span class="title">split</span>(<span class="params"> <span class="regexp">/\s*,\s*/</span> </span>)</span></span><br><span class="line"><span class="function">		.<span class="title">map</span>(<span class="params"> v =&gt; v.replace( <span class="regexp">/[=\s].*$/</span>, <span class="string">""</span> </span>) )</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">spreadFn</span>(<span class="params">argsObj</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn( ...propOrder.map( <span class="function"><span class="params">k</span> =&gt;</span> argsObj[k] ) );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看 <code>spreadArgProps(..)</code> 实用函数是怎么用的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">`x:<span class="subst">$&#123;x&#125;</span> y:<span class="subst">$&#123;y&#125;</span> z:<span class="subst">$&#123;z&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3 = curryProps( spreadArgProps( bar ), <span class="number">3</span> );</span><br><span class="line"><span class="keyword">var</span> f4 = partialProps( spreadArgProps( bar ), &#123; <span class="attr">y</span>: <span class="number">2</span> &#125; );</span><br><span class="line"></span><br><span class="line">f3( &#123;<span class="attr">y</span>: <span class="number">2</span>&#125; )( &#123;<span class="attr">x</span>: <span class="number">1</span>&#125; )( &#123;<span class="attr">z</span>: <span class="number">3</span>&#125; );</span><br><span class="line"><span class="comment">// x:1 y:2 z:3</span></span><br><span class="line"></span><br><span class="line">f4( &#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">x</span>: <span class="number">1</span> &#125; );</span><br><span class="line"><span class="comment">// x:1 y:2 z:3</span></span><br></pre></td></tr></table></figure>
<p>虽然上面的方法看上去有些不靠谱，但是它确实能解决我们实际的问题，至少解决了80%的情况。</p>
<h2 id="无形参风格"><a href="#无形参风格" class="headerlink" title="无形参风格"></a>无形参风格</h2><p>在函数式编程中，还有一种流行的代码风格，其目的是通过移除不必要的形参-实参映射来减少视觉上的干扰。这种风格的正式名称为 “隐性编程（tacit programming）”，一般则称作 “无形参（point-free）” 风格。术语 “point” 在这里指的是函数形参。</p>
<p>我们从一个简单的例子开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map( <span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> double( v );</span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">// [2,4,6,8,10]</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>mapper(..)</code> 函数和 <code>double(..)</code> 函数有相同（或相互兼容）的函数签名。形参（也就是所谓的 “point“）<code>v</code> 可以直接映射到 <code>double(..)</code> 函数调用里相应的实参上。这样，<code>mapper(..)</code> 函数包装层是非必需的。我们可以将其简化为无形参风格：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map( double );</span><br><span class="line"><span class="comment">// [2,4,6,8,10]</span></span><br></pre></td></tr></table></figure>
<p>还有之前<code>parseInt()</code>的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( <span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>( v );</span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line">=&gt; 无形参风格：</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map( unary( <span class="built_in">parseInt</span> ) );</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>借助<code>unary()</code>函数使得每次只传一个参数。</p>
<h2 id="not函数"><a href="#not函数" class="headerlink" title="not函数"></a>not函数</h2><p>首先来看一个案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( txt );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printIf</span>(<span class="params"> predicate, msg </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (predicate( msg )) &#123;</span><br><span class="line">		output( msg );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isShortEnough</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.length &lt;= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">var</span> msg2 = msg1 + <span class="string">" World"</span>;</span><br><span class="line"></span><br><span class="line">printIf( isShortEnough, msg1 );			<span class="comment">// Hello</span></span><br><span class="line">printIf( isShortEnough, msg2 );</span><br></pre></td></tr></table></figure>
<p>案例很简单，我们要求当信息足够长时，将它打印出来，换而言之，我们需要一个 <code>!isShortEnough(..)</code> 断言。你可能会首先想到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLongEnough</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !isShortEnough( str );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printIf( isLongEnough, msg1 );</span><br><span class="line">printIf( isLongEnough, msg2 );			<span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>上面的方式看似是很简单的，但是还是需要我们传递<code>str</code>，现在我们能否不通过重新实现 <code>str.length</code> 的检查逻辑，而重构代码并使其变成无形参风格呢？</p>
<p>我们定义一个 <code>not(..)</code> 取反辅助函数（在函数式编程库中又被称作 <code>complement(..)</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">predicate</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">negated</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !predicate( ...args );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数形式</span></span><br><span class="line"><span class="keyword">var</span> not =</span><br><span class="line">	predicate =&gt;</span><br><span class="line">		(...args) =&gt;</span><br><span class="line">			!predicate( ...args );</span><br></pre></td></tr></table></figure>
<p>传入的<code>predicate</code>为断言，也就是条件。</p>
<p>现在我们可以用<code>not</code>函数来修改上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isLongEnough = not( isShortEnough )</span><br><span class="line"></span><br><span class="line">printIf( isLongEnough, msg2 )  <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<h2 id="when函数"><a href="#when函数" class="headerlink" title="when函数"></a>when函数</h2><p>到目前位置，上面的案例已经被我们优化的不错了。但是也许还能再进一步，我们实际上可以将 <code>printIf(..)</code> 函数本身重构成无形参风格。</p>
<p>我们可以用 <code>when(..)</code> 实用函数来表示 <code>if</code> 条件句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">when</span> (<span class="params">predicate, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">conditional</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate(...args)) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn(...args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> when = <span class="function">(<span class="params">predicate, fn</span>) =&gt;</span> </span><br><span class="line">                (...args) =&gt; </span><br><span class="line">                    predicate(...args) ? fn(...args) : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>我们把本章前面讲到的另一些辅助函数和 <code>when(..)</code> 函数结合起来搞定无形参风格的 <code>printIf(..)</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printIf = uncurry( partialRight( when, output ) );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们是这么做的：将 <code>output</code> 方法右偏应用为 <code>when(..)</code> 函数的第二个（<code>fn</code> 形参）实参，这样我们得到了一个仍然期望接收第一个实参（<code>predicate</code> 形参）的函数。当<strong>该函数</strong>被调用时，会产生另一个期望接收（译者注：需要被打印的）信息字符串的函数，看起来就是这样：<code>fn(predicate)(str)</code>。</p>
<p>多个（两个）链式函数的调用看起来很挫，就像被柯里化的函数。于是我们用 <code>uncurry(..)</code> 函数处理它，得到一个期望接收 <code>str</code> 和 <code>predicate</code> 两个实参的函数，这样该函数的签名就和 <code>printIf(predicate,str)</code> 原函数一样了。</p>
</blockquote>
<h3 id="printIf案例"><a href="#printIf案例" class="headerlink" title="printIf案例"></a>printIf案例</h3><p>现在我们可以将上面的<code>printIf</code>整理一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isShortEnough</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.length &lt;= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isLongEnough = not( isShortEnough );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> printIf = uncurry( partialRight( when, output ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">var</span> msg2 = msg1 + <span class="string">" World"</span>;</span><br><span class="line"></span><br><span class="line">printIf( isShortEnough, msg1 );			<span class="comment">// Hello</span></span><br><span class="line">printIf( isShortEnough, msg2 );</span><br><span class="line"></span><br><span class="line">printIf( isLongEnough, msg1 );</span><br><span class="line">printIf( isLongEnough, msg2 );			<span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<h3 id="list案例"><a href="#list案例" class="headerlink" title="list案例"></a>list案例</h3><p>实现功能：</p>
<p>若是列表中的数大于3则添加进<code>greater</code>，否则添加进<code>less</code>。</p>
<p>这种简单的案例虽然可以用十分简单的方式来实现，但是为了习惯函数式编程的写法，所以算是我做一个小练习吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> greater = []</span><br><span class="line"><span class="keyword">var</span> less = []</span><br><span class="line"><span class="keyword">var</span> isGreater = <span class="function">(<span class="params">val</span>) =&gt;</span> val &gt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> pushGreater = <span class="function">(<span class="params">val</span>) =&gt;</span> greater.push(val);</span><br><span class="line"><span class="keyword">var</span> pushLess = <span class="function">(<span class="params">val</span>) =&gt;</span> less.push(val);</span><br><span class="line"><span class="keyword">var</span> handleFn = <span class="function"><span class="params">fn</span> =&gt;</span> uncurry( partialRight( when, fn ) )</span><br><span class="line"><span class="keyword">var</span> setGreater = handleFn( pushGreater )</span><br><span class="line"><span class="keyword">var</span> setLess = handleFn( pushLess )</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleList</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    list.forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        setGreater(isGreater, val)</span><br><span class="line">        setLess(not(isGreater), val)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'greater'</span>, greater)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'less'</span>, less)</span><br><span class="line">&#125;</span><br><span class="line">handleList(list)</span><br><span class="line"><span class="comment">// greater [4, 5]</span></span><br><span class="line"><span class="comment">// less [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>偏应用是用来减少函数的参数数量 —— 一个函数期望接收的实参数量 —— 的技术，它减少参数数量的方式是创建一个预设了部分实参的新函数。</p>
<p>柯里化是偏应用的一种特殊形式，其参数数量降低为 1，这种形式包含一串连续的链式函数调用，每个调用接收一个实参。当这些链式调用指定了所有实参时，原函数就会拿到收集好的实参并执行。你同样可以将柯里化还原。</p>
<p>其它类似 <code>unary(..)</code>、<code>identity(..)</code> 以及 <code>constant(..)</code> 的重要函数操作，是函数式编程基础工具库的一部分。</p>
<p>无形参是一种书写代码的风格，这种风格移除了非必需的形参映射实参逻辑，其目的在于提高代码的可读性和可理解性。</p>
</blockquote>

    
    </div>
    
    
        <div class="article-comment" id="article-comment">
            

<h1>评论</h1>

  
    <div id="valine"></div>
  


        </div>
        
</article>
  </div>

  

<footer id="footer">
    <div class="footer-copyright">
        <div>
            <p> 版权所有 <a href="">LinDaiDai </a> @ 2019</p>
            <!--<p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>-->
        </div>
    </div>
    
    <div class="footer-social">
        
            
                
                    <div class="footer-social-item"><a href="https://github.com/LinDaiDai" target="_blank"><i class="fab fa-github fa-2x" aria-hidden="true"></i></a></div>
                
            
                
                    <div class="footer-social-item"><a href="https://github.com/LinDaiDai" target="_blank"><i class="fab fa-weixin fa-2x" aria-hidden="true"></i></a></div>
                
            
                
                    <div class="footer-social-item"><a href="https://github.com/LinDaiDai" target="_blank"><i class="fab fa-qq fa-2x" aria-hidden="true"></i></a></div>
                
            
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
		
			
				
			
		
		
	
		
			
		
		
	
	
	<div class="nav-item" id="nav-item-toc">
		


<div class="toc-container">
<i class="far fa-times-circle" id="toc-close" onclick="closeTOC(event);" ontouchstart="closeTOC(event);"></i>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#只要一个实参"><span class="toc-number">1.</span> <span class="toc-text">只要一个实参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unary函数"><span class="toc-number">1.1.</span> <span class="toc-text">unary函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sum案例"><span class="toc-number">1.1.1.</span> <span class="toc-text">sum案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传一个返回一个"><span class="toc-number">2.</span> <span class="toc-text">传一个返回一个</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#identity函数"><span class="toc-number">2.1.</span> <span class="toc-text">identity函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#转换函数的妙用"><span class="toc-number">2.1.1.</span> <span class="toc-text">转换函数的妙用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#恒定参数"><span class="toc-number">3.</span> <span class="toc-text">恒定参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Certain-API"><span class="toc-number">3.1.</span> <span class="toc-text">Certain API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constant函数"><span class="toc-number">3.2.</span> <span class="toc-text">constant函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展在参数中的妙用"><span class="toc-number">4.</span> <span class="toc-text">扩展在参数中的妙用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不需要顺序的柯里化和偏应用"><span class="toc-number">5.</span> <span class="toc-text">不需要顺序的柯里化和偏应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#partialProps和curryProps"><span class="toc-number">5.1.</span> <span class="toc-text">partialProps和curryProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性扩展"><span class="toc-number">5.2.</span> <span class="toc-text">属性扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spreadArgProps函数"><span class="toc-number">5.2.1.</span> <span class="toc-text">spreadArgProps函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无形参风格"><span class="toc-number">6.</span> <span class="toc-text">无形参风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not函数"><span class="toc-number">7.</span> <span class="toc-text">not函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#when函数"><span class="toc-number">8.</span> <span class="toc-text">when函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printIf案例"><span class="toc-number">8.1.</span> <span class="toc-text">printIf案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list案例"><span class="toc-number">8.2.</span> <span class="toc-text">list案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<div class="toc-button" onclick="toggleTOC(event);" ontouchstart="toggleTOC(event);">
    <img src="/images/icons/blue-shadow/toc.svg" alt="">
</div>

	</div>
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="归档">
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon">
		
			<a href="/search/" title="搜索">
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/home/">
							<span>首页</span>
						</a>
					</div>
			</div>
		
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/about/">
							<span>关于</span>
						</a>
					</div>
			</div>
		
		
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/php/">
						<span>Php</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/mySql/">
						<span>Mysql</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/其它技能/">
						<span>其它技能</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/vscode/">
						<span>Vscode</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端进阶/">
						<span>前端进阶</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端入门/">
						<span>前端入门</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    

    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        appId: '0Nyr31J74bB24hrKnRrheEdf-gzGzoHsz',
        appKey: 'RYPhOnr007gXeWPQr3V1VFHH',
        placeholder: '说点什么吧...',
        path:window.location.pathname, 
        avatar:'monsterid',
        lang: 'zh-cn',
        visitor: true // 阅读量统计
    });
</script>









    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type="text/javascript">

  
  // update cookie if this page is opened (directly)
  loadjs(['/libs/jshashes/hashes.min.js', '/libs/js-cookie/src/js.cookie.js', '/js/post.v2.js'], 'post-version');
  loadjs.ready('post-version', function(){
    
    new Postv2('hashit_686ae2624ac1f6d4b6b572a93c98a312aea7c0ab3fabf3ebbf964fab53066265').update('hashit_3e0220e538daaae641f63340aea79d08ab9376b42062f0d9b812d4342e659818', function(){});
  });
  
</script>


    
<script type="text/javascript">
  
  // update cookie if this page is opened (directly)
  function getIP(json) {
  loadjs(['/libs/jshashes/hashes.min.js', '/libs/js-cookie/src/js.cookie.js', '/js/leancloud.js'], 'post-visit-comment-count');
  loadjs.ready('post-visit-comment-count', function(){
    
    
    LeanCloud.init('', '');
    var leanCloud = LeanCloud.getInstance();
    leanCloud.fetchIsThumbUp('/2019/06/27/webNotes/advanced/Functional/ch_3/', json.ip);
    document.getElementById('thumb-up-button').addEventListener('click', function(e){
      leanCloud.isThumbUp('/2019/06/27/webNotes/advanced/Functional/ch_3/', function(isThumbUp){
        console.log('is thumb up:' + isThumbUp);
        if(isThumbUp){
          leanCloud.removeThumbUpRecord('/2019/06/27/webNotes/advanced/Functional/ch_3/', json.ip);
          document.getElementById('thumb-up-icon').className = "far fa-thumbs-up fa-lg";
          
        }else{
          leanCloud.addThumbUpRecord('/2019/06/27/webNotes/advanced/Functional/ch_3/', json.ip);
          document.getElementById('thumb-up-icon').className = "fas fa-thumbs-up fa-lg";
        }
        leanCloud.getThumbUpCount('/2019/06/27/webNotes/advanced/Functional/ch_3/', function(count){
            console.log('thumb up count: ' + count)
            var el = document.getElementById('article-thumbup-count');
            if(el) el.innerHTML = count;
        });
      });
    });
    leanCloud.addVisitRecord('/2019/06/27/webNotes/advanced/Functional/ch_3/', json.ip);
    leanCloud.fetchCommentCount('/2019/06/27/webNotes/advanced/Functional/ch_3/');
    leanCloud.fetchVisitCount('/2019/06/27/webNotes/advanced/Functional/ch_3/');
    leanCloud.fetchThumbUpCount('/2019/06/27/webNotes/advanced/Functional/ch_3/');
    leanCloud.getCommentCount('/2019/06/27/webNotes/advanced/Functional/ch_3/', function(count){
        var el = document.querySelector('#article-comment-count');
        if(el) el.innerHTML = count;
    });
    leanCloud.getVisitCount('/2019/06/27/webNotes/advanced/Functional/ch_3/', function(count){
        var el = document.querySelector('#article-visit-count');
        if(el) el.innerHTML = count;
    });
    leanCloud.getThumbUpCount('/2019/06/27/webNotes/advanced/Functional/ch_3/', function(count){
        var el = document.getElementById('article-thumbup-count');
        if(el) el.innerHTML = count;
    });
    leanCloud.isThumbUp('/2019/06/27/webNotes/advanced/Functional/ch_3/', function(isThumbUp){
        console.log('init thumb up:' + isThumbUp);
        if(isThumbUp){
          document.getElementById('thumb-up-icon').className = "fas fa-thumbs-up fa-lg";
        }else{
          document.getElementById('thumb-up-icon').className = "far fa-thumbs-up fa-lg";
        }
    });
  });
  }
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant="" type="text/javascript">

initHeadroom();

changeLayoutOnTouchScreen();

// 
// var post = new Post('', '');
// post.getCommentCount(window.location.pathname, function(count){
//     $('#article-comment-count').text(count);
// });
// post.addVisitRecord(window.location.pathname, userip);
// post.getVisitCount(window.location.pathname, function(count){
//     $('#article-visit-count').text(count);
// });

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
