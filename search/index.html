<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.8.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - LinDaiDai</title>
  

  
  
  <meta name="description" content="">
  <meta name="author" content="LinDaiDai">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/wang.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class="header">
	<div class="header-title">
		
		<div class="header-logo">
			<a href="/">
				<img src="/images/lindaidai-logo.jpg">
			</a>
		</div>
		<div class="header-text">
			<h1>
				<a href="/">LinDaiDai</a>
			</h1>
			<subtitle>
				王霈霖的个人博客
			</subtitle>
		</div>
		
	</div>
	<div id="header-nav">
		



<nav id="nav">
	
	
		
			
		
		
			<div class="nav-item">
				
					<div class="nav-name">
				
					<a class="nav-link" href="/home/">
						<span>首页 </span>
					</a>
				</div>
			</div>
		
	
		
			
		
		
			<div class="nav-item">
				
					<div class="nav-name">
				
					<a class="nav-link" href="/about/">
						<span>关于 </span>
					</a>
				</div>
			</div>
		
	
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="归档">
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon active_dot">
		
			<a href="/search/" title="搜索">
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/home/">
							<span>首页</span>
						</a>
					</div>
			</div>
		
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/about/">
							<span>关于</span>
						</a>
					</div>
			</div>
		
		
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/php/">
						<span>Php</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/mySql/">
						<span>Mysql</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/其它技能/">
						<span>其它技能</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/vscode/">
						<span>Vscode</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端进阶/">
						<span>前端进阶</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端入门/">
						<span>前端入门</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class="search-container">
	<input type="text" id="search-form">

	<ul class="cat-list">
		
			<li><a href="/categories/php/"><img src="/images/php.svg" alt="php" onerror="if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"" title="php"></a></li>
		
			<li><a href="/categories/mySql/"><img src="/images/mySql.svg" alt="mySql" onerror="if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"" title="mySql"></a></li>
		
			<li><a href="/categories/其它技能/"><img src="/images/其它技能.svg" alt="其它技能" onerror="if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"" title="其它技能"></a></li>
		
			<li><a href="/categories/vscode/"><img src="/images/vscode.svg" alt="vscode" onerror="if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"" title="vscode"></a></li>
		
			<li><a href="/categories/前端进阶/"><img src="/images/前端进阶.svg" alt="前端进阶" onerror="if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"" title="前端进阶"></a></li>
		
			<li><a href="/categories/前端入门/"><img src="/images/前端入门.svg" alt="前端入门" onerror="if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"" title="前端入门"></a></li>
		
	</ul>

	<div class="archive-cards">
			<div class="Card-archive" style="display:none">
				<div class="Card-body">
					<h3 class="Card-title">
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class="fa fa-calendar"></i> <span class="Card-date"></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"php中使用SDK完成微博授权","date":"2016-02-08T11:24:45.000Z","content":"很多应用中都可以使用QQ、微博、微信等授权登录,那么这些授权登录是怎么实现的呢？该篇文章记录的是使用php并结合相关SDK实现微博授权。\n0. 开始之前\n首先你可以注册一个新浪云用于你的盛放你的应用,注册SEA新浪云\n\n需要在微博开发平台中也注册一个账号 注册微博开放平台\n\n下载相关的SDK 下载SDK\n\nsdk （软件开发工具包）软件开发工具包（外语首字母缩写：SDK、外语全称：Software Development Kit）一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。软件开发工具包括广义上指辅助开发某一类软件的相关文档、范例和工具的集合。\n\n​\n\n\n1. 创建应用1.1 创建服务器\n登录新浪云账号(如果有微博可以直接用微博账号登录)\n登录成功后进入控制台 -&gt; 云应用SAE -&gt; 创建新应用\n开发语言选择PHP 然后其它按照你的需要选择1语言: PHP , 环境: 标准环境 , 版本 : 5.6\n\n\n\n1.2 创建微博应用创建完成后进入应用详情\n记录App Key 和App Secret\n创建完成后, 记录域名\n2. 配置2.1 配置SDK解压SDK压缩包后, 打开config.php 文件\n把之前记录的App Key ,App Secret 以及域名填写到文件中\n123456&lt;?phpheader(Content-Type: texthtml; charset=UTF-8);define( WB_AKEY , xxxxxxxxxx );define( WB_SKEY , xxxxxxxxxxxxxxxxxxxxxxxxx );define( WB_CALLBACK_URL , http:xxxxxxxxxxxxcallback.php );\n域名后的callback.php需要保留\n如:define( &quot;WB_CALLBACK_URL&quot; , &#39;http:testqqsdk.applinzi.comcallback.php&#39; );\n配置完成后打包(必须为.zip格式)\n2.2 配置微博应用把前一步最后的回调地址填写进入授权回调页, 提交\n2.3 配置服务器回到服务器控制台, 上传之前打包的SDK , 访问testqqsdk.applinzi.com 即可进入授权页面\n","tags":["php"],"path":"2016/02/08/phpNotes/phpAndSinaSDK/","external_link":""},{"title":"安装配置mySql及使用navicat","date":"2018-07-03T13:13:00.000Z","content":"一.下载安装配置本地mysql网上下载安装mysql的教程很多，这里贴上一个比较简介的教程传送门：mysql下载与安装不过上面的教程其中有几个坑是要新手注意的：1234567891.教程中的所有&quot;D:javamysql&quot;路径都是教程本身安装mysql的路径，你得换成自己的路径，比如我的安装路径就是&quot;D:mysql-8.0.11-winx64&quot;;1.在配置my.ini文件中 “default-character-set=utf8” 上面应该有个&quot; [mysql] &quot;,不然会出错2.在执行     mysqld install MySQL --defaults-file=&quot;D:javamysqlmy.ini&quot;     时如果出现错误：     InstallRemove of the Service Denied!     解决办法：            通过管理员身份运行cmd，也就是在window查找cmd时右键以管理员身份运行即可；3.执行所有mysql语句的时候，都要以“;”结尾\n如我在执行show databases的语句的时候，第一次忘了在结尾处写”;” ，然后又执行了一遍show databases;但是还是报错了，这是因为mysql是以”;”来判断一个语句结尾的，上面我的做法就相当于执行了show databasesshowdatabases; 所以会报错。此时你只要重新执行show database;就可以了：\n执行完上面的步骤，你就可以使用sql语句来创建自己的表了。如我在这个库中创建一个名为lindaidai的表：\n二.使用Navicat 管理本地数据库推荐使用Navicat来管理本地的数据库破解版的Navicat小伙们可以自行度娘，或者加博主QQ：244508795\n在使用Navicat连接本地数据库的时候，可能会报 1251 错误；原因：\n\n比较新的mysql采用新的保密方式，所以旧的似乎不能用\n\n解决办法：修改密码改密码方式：用管理员身份打开cmd\n-uroot -p（输入密码）            进入mysql执行下面三个命令123456use mysql;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;你的密码&apos;;FLUSH PRIVILEGES;\n如我修改密码的语句：最后使用quit语句退出数据库，然后重新打开Navicat建立一个新的连接即可。\n建立链接成功后可以看到\n三.后续启动mysql以后启动mysql可以有以下几种方式：\n1.任务管理器启动Ctrl + Alt + Del打开任务管理器，找到服务下的MySQL 右键启用\n2.指令启动管理员身份启动cmd输入指令:net start mysql\n登录：\n指令：123登录   mysql -u root -p查询库  show databases退出   quit\n后语本章介绍的是如何安装配置mysql并使用Navicat来管理自己的数据库，后续还有使用node.js链接上数据库并搭建一个完整的后台项目。\n","tags":["mySql","navicat"],"path":"2018/07/03/mySqlNotes/basicMySqlAndNavicat/","external_link":""},{"title":"适合初学者的TCP讲解","date":"2017-12-01T05:43:00.000Z","content":"首先在编写这篇文章之前呢，我想先澄清一些事情。这篇文章是我参考阮一峰老师的《TCP协议简介》,仅仅是把它用我自己的话阐述一遍，以便自己以及一些想了解TCP协议的读者来理解。有写的不好的或者表述不清楚的地方，请各位读者能指正出来，谢谢。\n前言\n一、TCP存在哪里介绍TCP之前，应该先要让大家了解一下TCP存在哪里并且有什么作用。\n用一张图来表述可能更加实在\n\n首先，可以看到，TCP是以太网协议和IP协议的上层协议，也是应用层的下层协议。\n(简单介绍一下以太网协议和IP协议)\n以太网协议：\n最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。\nIP协议：\nIP协议解决的就是多个局域网互相通信，比如路由器就是基于IP协议的。\n(通俗一点理解就是以太网协议解决了局域网的点对点通信，但不能解决多个局域网互相通信，这时候就得靠IP协议来解决多个局域网互相通信的问题)\n那么弄清楚了这俩个协议之后好像还是不知道TCP到底在哪里。别急，下面这张图更加实在。\n\n可以看到，不管是IP数据包还是TCP数据包还是应用层数据包都包裹在以太网数据包中的。\n这个最大的以太网数据包最初只有1518字节，后来增加到了1522字节。\n其中有1500字节是以太网数据包的负载，而另外的22字节是头信息。\n(CRC是利用除法及余数的原理来作错误侦测)\n那么所以另外的那些包数据都是存在于以太网的负载中的。\nIP数据包又分为IP标头和IP负载，存在于以太网的负载中。IP标头(也就是头信息)最少需要20字节，所以它的负载最多就是1500-20=1480字节。\n但由于IP和TCP协议中往往有额外的头信息，所以最终TCP负载实际就是1400字节左右。\n因此，一条1500字节的信息需要两个 TCP 数据包。HTTP2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。(原话)\n\n通过上面的学习，我们了解到了IP协议它其实只是一个地址协议，并不能保证包的完整性(也就是如果缓存满了，新进来的包就可能会丢失等等问题)。这时候就需要TCP来知道丢了哪个包，以及如何重新发送这个包。\n总结：\n\nTCP 协议的作用是：保证数据通信的完整性和可靠性，防止丢包。\n\n以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。\n\n\n二、TCP数据包的编号可以看到一个包的负载是1400字节，那么如果现在要传输的是大量的数据，那这时候就得分成很多个包。(比如，一个 10MB 的文件，需要发送7100多个包。)\n在进行发送的时候，TCP协议就起作用了，它为每个包编号(sequence number，简称 SEQ),这样每个包都有了自己的编号后，接受的一方就可以按顺序还原，就算包丢失之后也能知道是哪个包丢失了。\n编号规则：\n第一个包的编号是一个随机的数字，比如第一个包的编号为1，负载长度为100字节，那么第二个包的编号就是101，依次类推。\n这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。\n此时我们就可以将TCP协议的作用再补充一条：\n将每个要传输的包进行编号，保证数据通信的完整性和可靠性，防止丢包。\n三、TCP数据包的组装当TCP协议为每个包编号完成之后，就将TCP数据包发送出去。\n在接收到数据包后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。\n可以看到，过程大概就是：12编写好的数据包 --&gt;  传递给操作系统 --&gt;  操作系统按照顺序组装 --&gt;判断TCP数据包中的端口号  --&gt; 继续传递给监听端口号的那个应用程序\n","tags":["其它技能","http"],"path":"2017/12/01/otherSkill/Http/basicOfTCP/","external_link":""},{"title":"你的vscode本可以这么炫","date":"2019-06-18T15:15:35.000Z","content":"前言记录霖呆呆第一台 Mac Pro上Vscode的主题配置，参考的是Jinkey大神的原创文章如何配置透明发光的骚气 vscode —— Jinkey 原创)。本文中目录结构与原创中大同小异，但加上了一些自己的理解和新手用Mac的一些快捷键提示，以及如何给Vscode 加上背景图片。产权无价，支持原创。\nWhat do I want ?Is this…This is too cool ! 🙊\n1. 在vscode上安装自定义JS和CSS的插件在vscode的扩展页面搜索下载以下插件\n\nCustom CSS and JS Loader\n\n\n2. 安装vscode发光主题\nSynthWave ‘84\n\n\n3. 下载相关的vscode样式完成上述两个步骤之后，我们可以自定义一些样式使我们的vscode看上去更加酷炫。首先要在你电脑的本地上选择一个文件目录用来放你的自定义JS和CSS文件。一般可以就放在vscode的安装文件夹下，或者自己找得到的文件夹下。我这里为了配置方便，定义了一个config文件夹专门存放一些配置文件。并在config中创建一个名为vscode-transparent-theme的文件夹，将以下配置文件放入其中。配置文件直接要感谢Jinkey大神整理好的配置，下载地址:https:github.comJinkeycodevscode-transparent-glow将下载下来的文件放入相应的文件夹下：各个文件的作用这里就不一一做介绍了，大概的作用就是能改变vscode本身的一些样式，以及代码文字的样式等等…\n4. 修改vscode的相关配置打开vscode的setting.json文件，这个文件可以在左下角的设置中找到，用来配置用户的自定义属性。打开之后，将以下内容全部复制到setting.json中：123456789101112&#123;   &quot;vscode_custom_css.imports&quot;: [        &quot;file:Userslindaidaiconfigvscode-transparent-themevscode-vibrancy-style.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themesynthwave84-noglow.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themetoolbar.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themeterminal.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themeenable-electron-vibrancy.js&quot;    ],    &quot;vscode_custom_css.policy&quot;: true,    &quot;terminal.integrated.rendererType&quot;: &quot;dom&quot;,    &quot;workbench.colorTheme&quot;: &quot;SynthWave &apos;84&quot;,&#125;\nfile:Userslindaidaiconfigvscode-transparent-theme就是你存放这些配置文件的绝对路径。MacOS 上获取文件夹或者文件的路径快捷键：1Option+Command+C\n选中你的文件夹然后使用上面的快捷键，文件夹的路径就复制到了你的粘贴板上了。例如我这里就是Userslindaidaiconfigvscode-transparent-themefile:  这个前缀记得加上。\n若是你的setting.json中原本就有配置内容的话，比如有设置vscode字体大小的配置：123&#123;  &quot;editor.fontSize&quot;: 16&#125;\n那就直接在它下面加上配置就行了，如下：12345&#123;  &quot;editor.fontSize&quot;: 16,  &quot;vscode_custom_css.imports&quot;: [...],  ...&#125;\n5. 重新加载vscode配置保存好上面的setting.json之后，需要重新加载vscode才能看到效果。按下 Ctrl + Shift + P(MacOS下为Shift+commoand+P)，运行 &quot;Reload Custom CSS and JS&quot;, 重启 vscode 即可。如果提示VSCode 已经损坏，选择右上角齿轮“不再提示”即可。部分电脑提示 reload 失败的，请以管理员模式运动 vscode1sudo code --user-data-dir=&quot;~.vscode-root&quot;\n最终看到的效果和配置就是这样：\neditor.tokenColorCustomizations那个配置是我看成功之后注释的字体颜色太淡了，很难看清，所以加的配置。comments代表的就是配置注释的字体颜色，这个可以自己发挥。\n6. 安装背景插件完成上面的步骤就已经实现了你的vscode透明发光的效果了，要是还想再炫一点的话，要不给它加个背景图？安装以下背景插件\n\nbackground\n\n安装成功之后重新加载vscode就可以看到右下角有一个默认的背景图片。当然你也可以把vscode整体想象成一个div元素，然后给这个元素配置上背景图片的样式。并且自定义背景图片，如我的setting.json配置：123456789101112131415161718192021222324252627282930313233&#123;    &quot;editor.fontSize&quot;: 16,    &quot;editor.tokenColorCustomizations&quot;: &#123;        &quot;comments&quot;: &quot;#72777b&quot;    &#125;,    &quot;vscode_custom_css.imports&quot;: [        &quot;file:Userslindaidaiconfigvscode-transparent-themevscode-vibrancy-style.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themesynthwave84-noglow.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themetoolbar.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themeterminal.css&quot;,        &quot;file:Userslindaidaiconfigvscode-transparent-themeenable-electron-vibrancy.js&quot;    ],    &quot;vscode_custom_css.policy&quot;: true,    &quot;terminal.integrated.rendererType&quot;: &quot;dom&quot;,    &quot;workbench.colorTheme&quot;: &quot;SynthWave &apos;84&quot;,    &quot;material-icon-theme.activeIconPack&quot;: &quot;vue&quot;,    &quot;background.customImages&quot;: [        &quot;file:Userslindaidaiconfigvscode-background-imagetimg3.png&quot;    ],    &quot;background.style&quot;: &#123;        &quot;content&quot;:&quot;&apos;&apos;&quot;,        &quot;pointer-events&quot;:&quot;none&quot;,        &quot;position&quot;:&quot;absolute&quot;,图片位置        &quot;width&quot;:&quot;100%&quot;,        &quot;height&quot;:&quot;100%&quot;,        &quot;z-index&quot;:&quot;99999&quot;,        &quot;background.repeat&quot;:&quot;no-repeat&quot;,        &quot;background-size&quot;:&quot;25%, 25%&quot;,图片大小        &quot;opacity&quot;:0.2 透明度    &#125;,    &quot;background.useFront&quot;: true,    &quot;background.useDefault&quot;: false 是否使用默认图片&#125;\nbackground.customImages 就是你自定义背景图片的绝对路径，它是一个数组，最多支持3张背景图片。背景图片的样式可以在background.style中配置。最终效果：\n后记参考资料：如何配置透明发光的骚气 vscode —— Jinkey 原创\n","tags":["vscode","hexo"],"path":"2019/06/18/otherSkill/Vscode/theme/","external_link":""},{"title":"Git的基本知识","date":"2017-02-08T08:24:45.000Z","content":"第一章 下载以及使用下载地址:git\n1.1配置git​    在命令行模式里输入以下命令\n​      git config –global user.name “用户名”\n​      git config –global user.email “邮箱名”\n  注:全英文,不能用中文\n​    输入完后检查是否输入成功\n​    git config –list\n  若:\n\n​    显示除了user.name 以及 user.email   即输入成功;\n1.2Git理论基础#####         1.三颗树\n​            工作区域      暂存区域      Git仓库\n\n#####          2.Git的工作流程\n​            1.在工作目录中添加,修改文件\n​            2.将需要进行版本管理的文件放入暂存区域\n​            3.将暂存区域的文件提交到Git仓库\n​        Git管理的三种状态:\n​            1.以修改        modified\n​            2.以暂存        staged\n​            3.已提交        committed\n#### 1.3 创建Git项目\n​    1.在磁盘中创建一个文件夹MyProject  用来存放你的Git项目\n​    2.然后打开命令CMD   进入存放MyProject 的磁盘  ,  并用输入 cd   MyProject 进入文件夹\n​    3.输入命令     git  init        会显示初始化了一个空的git仓库(如图):\n​     \n并且在文件夹中创建了一个git文件(如图):\n​    \n​    4.在当前MyProject文件夹内创建一个md类型的文本(文本名为README)  并以notepad++打开(为防止乱码,可把notepad++内的编码格式改为 UTF-8无BOM编码格式;   (即工作流程中的第一步)\n​    5.输入命令:  git add README.md    (即工作流程中的第二步,将README文件添加至暂存区域,若要添加全部的文件可用 –all)\n​     回车之后再输入:     git commit -m “add a readme file”    (commit 提交,即工作流程中的第三步,将暂存区域内的README文件提交到git仓库)\n​                引号内是写入对这次提交做的一个说明(做了什么),\n​        显示如下图:    \n\n​        \n1.4 git status\n作用: 查看此时 git 的状态\n\n​        输入  git status  即可查看此时git的状态 (如图):\n​         \n​         在一个默认的分区 master 中\n​         没有需要提交的文件,当前的工作目录是干净的\n1.5添加协议 开源​    1.在当前文件夹创建一个md  (文件名为 LICENSE)  ,里面写MIT的开源协议\n​    将README内的内容进行编辑;\n​    此时 在 git status 下查看  ,可发现:\n​    \n​        此时发现 , README.md 是已经添加到了暂存区域并提交的\n​        而  LICENSE.md 是未被跟踪的状态  ( 即在工作区域内的,圆括号内代表git给我们的建议 );\n​    \n​    2.将LECENSE添加至暂存区域并查看状态\n​    \n​    \n1.6 git reset HEAD将LECENSE添加至暂存区域后,会提示出 是否使用 git reset HEAD 的操作(若不 操作则不用理他)\n\n作用: 撤销上一次的操作 ,返回上一个版本   HEAD表示当前版本  上一个表示HEAD~\n是将git仓库中的内容恢复到暂存区域中\n\n一般  会   HEAD~(1~100) 这样写\n​        git reset   &lt;版本快照 文件名路径&gt; 也可以指定文件名\n1.git reset  –mixed HEAD~            (默认)\n​    -移动HEAD的指向,将其指向上一个快照\n-将HEAD移动后指向的快照回滚到暂存区域\n\ngit reset   –soft  HEAD~            (仅仅只是修改了HEAD指针,相当于撤销git commit 这一步而已\n  -移动HEAD的指向,将其指向上一个快照 \n\ngit reset  –hard  HEAD~        (同时影响了三颗树)\n\n\n\n​       -移动HEAD的指向,将其指向上一个快照\n​       -将HEAD移动后指向的快照回滚到暂存区域\n​       -将暂存区域的文件还原到工作目录\n区别详情请参考1.9的例1\n  快照1   快照2  快照3    当HEAD处于快照3时,使用git reset –hard HEAD~ 回到快照2 ,若此时再想返回快照3:\n​    方法1:  查看以前的历史记录  找到快照3的id 并使用git reset -hard 快照3id  ;\n​    方法2: 若找不到快照3的id ,可使用git reflog  (注:用来记录你的每一次指令)查看你的快照3的id名   ,然后再执行git reset –hard 快照3id\n1.7 git checkout\n作用1:     git checkout –            将暂存区内的文件内容覆盖工作目录的文件内容\n作用2:    git checkout 分支名            切换到指定分区\n\n如在1.5的操作中,我们将LICENSE的这个文件提交到了暂存区域中,在使用git commit -m “ add a license file” 命令将其提交到git仓库;\n之后,如果我们对LICENSE内的内容进行编辑或者修改,如将LICENSE协议内首行的换为2017; \n( 此时可以理解为LICENSE有俩个版本,一个是最开始在暂存区中的版本(即year),一个是工作目录下的版本(即2017)\n此时,在输入 git status 来查看git的工作状态,会提示出 \n\n是否将已改动的文本添加至暂存区域中 ;\n\n是否将暂存区域中对应的这个文件内容覆盖工作目录的文件内容\n如下图( README 和  LICENSE  俩个文件都是改动过的 ):\n\n\n\n此时 若输入git add LICENSE.md  回车\n​            git commit -m “ add a license file” \n​        则将暂存库里和工作目录中的LICENSE 的内容都修改了 \n​    若输入 git checkout – LICENSE.md \n​        则暂存库里的内容没被修改,并且工作目录中的内容也会变为暂存库中的内容\n1.8 git log\n 作用: 查看历史提交\n\n历史提交 最新的提交在最头上;\n​    git log –decorate    –oneline    只显示快照的说明 ID 不显示作者,日期等其他信息(能精简快照历史信息)\n​            –graph    以图形的方式显示\n​            –all      显示所有的分支\n​    如下图:有俩个分支master feature    \n​    \n​    d1d14c6表示的是俩个分支共同拥有的        \n1.9 git reset 和 git checkout 的区别\n​    不难看出\n​        checkout  是将工作区域内的内容恢复成暂存区域\n​        reset 是将git仓库内的内容恢复成上一个版本\n​    恢复文件:\n​        checkout 命令和 reset 命令都可以用于恢复指定快照的指定文件,并且他们都不会改变HEAD指针的指向.\n​        区别是: reset 命令只将指定文件恢复到暂存区域(–mixed) , 而checkout 命令是同时覆盖暂存区域和工作目录.\n​        ( 如果你想使用 git reset –hard HEAD~ README.md 命令让reset 同时覆盖工作目录,但git会告诉你不行,因为此时,reset不允许使用–soft或者–hard 选项.SO 恢复文件上,reset要安全一些)\n​    区别:\n​        1.对于reset –hard 命令,checkedout 命令更安全,因为 checkedout 命令在切换分支前会先检查一下当前的工作状态,如果不是 “clean”的话,git不会允许你这样做,而 resert –hard 命令则是直接覆盖所有数据;\n​        2.如何更新HEAD指向, reset 命令会移动 HEAD所在分支的指向,而 checkout 命令只会移动HEAD自身来指向另一个分支.\n例1:\n​    1.在master 中创建3个txt , 1.txt    2.txt   3.txt 并添加到git 仓库,\n​    2.git checkout -b feature    创建一个分支feature并将指针指向它,\n​    3.在分支feature中创建1个名为 feature1.txt 的文件并添加到git仓库,\n​    4.使用 git checkout master 跳回到 master中,再在master中创建1个名为 master1.txt 的文件并添加到git仓库中,\n​    5.再执行    git reset –hard feature     此时查看git log 对比第4步和第5步\n​        \n​        说明:    git reset  –hard feature命令将HEAD 指向的分支(即master)以及HEAD本身都切到了feature分支里,换句话说,原来的快照已经消失了(master1.txt那个快照不见了).\n​    6.此时执行  git reset –soft HEAD~    和 git reset HEAD~    \n​        \n​        说明 :    –soft 仅仅将指针HEAD指向了上一个快照,    –mixed 也会将指针HEAD指向上一个快照, mixed还会将HEAD指针移动后的快照回滚到暂存区域        此时查看git status:\n​    \n​        说明: 回到了” 还没有将3.txt 添加到暂存区域 “ 时\n例子\n在E盘创建文件夹MyProject,\n\n在CMD 进入E盘中的MyProject文件夹内:       E:    回车      cd  MyProject     ;\n\n创建空的git仓库:    git init \n\n在MyProject 文件夹内创建README.md 文件\n\n将README.md文件添加到暂存区域:      git add README.md\n\n将README.md文件提交到git仓库:         git commit -m “ add a readme file”;\n\n在MyProject文件夹内创建LICENSE.md文件,并写上MIT协议\n\n将LICENSE.md文件添加到暂存区域:     git  add LICENSE.md\n\n修改LICENSE.md文件内的year 改为2017\n\n执行 :    git status        弹出:     1. use “ git add ..”    2. use “ git checkout – ..”\n\n执行 :    git add LICENSE.md   和  git commit -m “ add a license file”;\n\n执行 :    git log 查看历史记录:\n\n\n\n结构模型:\n\n\n执行 git reset HEAD~       回车               git status \n\n\n\n结构模型\n\n此时,git会检测到工作区域内的LICENSE版本比暂存区域内的版本新,所以会有提示,是否要更新\n第二章  版本对比1. git diffa、查看尚未暂存的文件更新了哪些部分，不加参数直接输入​    git diff此命令比较的是工作目录(Working tree)和暂存区域快照(index)之间的差异也就是修改之后还没有暂存起来的变化内容。\nb、查看已经暂存起来的文件(staged)(即git仓库中的快照)的差异​    git diff –cached  快照ID            没加ID名就是和上次提交时的快照之间(HEAD)最新的git仓库中的快照的差异​    git diff –staged      快照ID显示的是下一次commit时会提交到HEAD的内容(不带-a情况下)\nc  比较俩个历史版本之间的快照\n   git diff   STAID1   STAID2\nd.比较 工作目录(Working tree) 和git仓库中的快照\n git diff   STAID(要比较的那个快照的ID名)\n第三章 实用小技巧1.修改最后一次提交​    情景一:    版本刚一提交(commit)到仓库,突然想起漏掉俩个文件还没有添加(add);\n​    情景二:     版本刚一提交到仓库,突然想起版本说明写得不够全面,\n执行带 –amend  选项的commit操作 Git就会”更正”最近的一次提交:    git commit –amend\n​        进入更正界面        大写I      将要修改的地方修改    esc        shift + s 保存并退出  此时查看历史,发现快照并没有增加一个,而是在原本的快照基础上进行了修改\n​        若不想修改        大写Q      输入q! 回车      退出当前更正界面\n2.恢复删除的文件​    若在文件夹中不小心将文件删除,\n​    git checkout –     即可看到文件又恢复到了文件夹中\n3.从git中删除文件​    情形一:\n​        若一个文件你已经提交到了git仓库,想让它删除掉并且没有任何记录\n​    先执行:\n​    git rm \n​        该命令删除的只是工作目录和暂存区域的文件,也就是取消跟踪,在下次提交时不纳入版本管理.(但在git仓库还是会有快照的历史记录)\n​    再执行:\n​    git reset –soft HEAD~\n​        此时再查看git log  就发现历史记录中并没有刚刚删除的那个快照;\n​    情形二:\n​        若一个文件你添加到了暂存区域,之后又对工作区域的文件进行的修改,\n​            执行:    git rm      时,git 会提示你 此时 暂存区域和工作区域有俩个版本的文件,问要删除哪一个;\n​            若执行:    git rm -f                 git 会将俩个版本都删除(一个-)\n​                    git rm –cached             git会删除暂存区域, 保留工作区域(俩个-)\n#### 4.git重命名文件\n​    git mv &lt;原来的文件名&gt;  &lt;改之后的文件名&gt;\n​    例:     git mv game.html workgame.html\n第四章 Git分支#### 1:创建分支\n​    git brance 分支名\n​    \n#### 2:切换分支\n​    git checkout 分支名    \n​    git checkout -b feature2    创建并切换到feature2的分支\n3.合并分支​        git  merge 分支名\n​        如此时再master分支中,想将feature 的分支合并过来:        git merge feature \n​        若不同分支中有相同名称的文件,文件内容却不同,此时合并时git会提示有冲突CONFLICT,需要我们人为去合并\n​            打开文件将HEAD 内的内容和feature的内容合并起来保存并退出\n​            此时再执行 git status 操作, 可发现git提示你git add      执行git add 后,执行 git commit -m “ add fixed file”;\n​            执行git log –decorate –oneline –graph –all\n​            会发现俩分支合并到了一起    \n4.删除分支​    git brand -d 分支名\n第五章: 将本地项目上传到GitHub​    1.在GitHub上创建一个git 仓库 : 点Great a new repository;\n​    2.在Github上设置好SSH密钥并创建好git远程仓库后,就可以和本地关联了 在本地git仓库的命令栏中输入:\n​        $ git remote add origin &lt;GitHub上创建好的仓库的地址&gt;\n​    3.将本地库里的所有内容推送到远处仓库(也就是GitHub上了)通过:\n​        $ git push -u origin master\n​    4.由于新建的远程仓库是空的 所以第一次推送要加上 -u   等远程仓库有了内容之后就可以直接通过:\n​        $ git push  origin master    \n​    注: 这里有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https:github.comguyibangTEST2.git的错。\n​         这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：\n1$ git pull --rebase origin master\n​    然后你在执行 push 就可以了.\n注:\n​    执行  git reflog    查看所有快照的id等等\n​    若push时有一些关于 REBASE的提示,可执行 git  rebase master\n第六章: Fork当你觉得gitbub上有人的项目写的特别好,你也想和他一起完善这个项目的时候,你就可以使用Fork\n1.在别人的项目里点击Fork,此时返回自己的github 可以发现自己的profile下多了一个别人的项目\n2.使用clone自己的这个项目到本地,在本地进行修改操作\n3.修改完之后,使用指令\n1234$ git add --all$ git commit -m &quot;add some file&quot;$ git push$ git remote add upstream 别人的这个项目的git仓库地址\n4.执行完后可以使用git remote -v查看是否添加成功,\n1234origin  git@github.com:LinDaiDaivue2-axf.git (fetch)origin  git@github.com:LinDaiDaivue2-axf.git (push)upstream        https:github.comtangcaiyevue2-axf.git (fetch)upstream        https:github.comtangcaiyevue2-axf.git (push)\n5.到你的github找到刚刚的项目,点击New pull request 将你刚刚要添加的内容提及上去,等待对方同意就ok\n第七章：SSH Keys1.要确定你的电脑上安装了git 并且添加到了环境变量中\n2.在开始中找到git bash并打开，输入 $ssh-keygen -t rsa -C “username@email.com“此时会提示你输入存储key的文件名（我输入github），并提示你输入密码与确认密码（我这里选择不输入），接着会生成连个文件名一个是公钥与私钥文件并存储在C:Users***文件夹下：github，github.pub\n3.在github上 settings -&gt; SSH and GPG keys -&gt; new SSH keytitle 随便输key 填入 C:Userscestbon.sshid_rsa.pub 内的内容\n","tags":["其它技能","Git"],"path":"2017/02/08/otherSkill/Git/basicGit/","external_link":""},{"title":"在npm上发布模块","date":"2016-02-08T11:24:45.000Z","content":"前言入行前端也不少时间了，之前一直都在使用npm install别人的模块组件，那么作为一名有追求的前端肯定不会满足一直在用别人的轮子。今天给大家分享一下如何在npm上发布自己的模块或者组件。\n第一章 登录npm123npm adduser 创建用户ornpm login 登录用户\n可以使用\n1npm whoami\n检测用户是否登录上了npm\n第二章 发布模块1.首先安装npm publish1npm i -g publish\n2.创建自己的npm模块创建空文件夹 fm_lindaidai_first\n并且在命令行输入\n12npm init一路回车\n此时会出现package.json\n1234567891011&#123;  name: fm_lindaidai_first,  version: 1.0.0,  description: ,  main: index.js,  scripts: &#123;    test: echo Error: no test specified &amp;&amp; exit 1  &#125;,  author: lindaidai,  license: ISC&#125;\n在package.json同级目录下编写date.js\n12345678910111213141516171819202122232425262728293031date.js(function(global) &#123;\tuse strict;    var datachange = (function() &#123;        return function(date) &#123;            var date = date || new Date;            if (!date instanceof Date) &#123;                data = new Date(date);            &#125;            if (isNaN(data)) &#123;                throw TypeError(Invalid date);            &#125;            let enDate = date.getFullYear() + . + (date.getMonth()+1) + . + date.getDate();            return enDate;        &#125;    &#125;)();    if (typeof define === function &amp;&amp; define.amd) &#123;        define(function () &#123;          return datechange;        &#125;);      &#125; else if (typeof exports === object) &#123;        module.exports = datechange;      &#125; else &#123;        global.datechange = datechange;      &#125;&#125;)(this);\n上面的date.js是添加简单的日期转换格式插件\n由于命名的是date.js，因此记得将package.json中的“main”修改为date.js\n否则别人使用的时候就会报错\n3.在npm上发布自己的模块注\n\n1.确保自己是登录了npm的\n2.确保自己的npm的邮箱被激活了\n3.命名不能太简单,最后要有自己的标志,太简单可能是别人已经用过的名字你就不能发布成功,也不要有数字\n4.如果是要再次推送同一个项目记得修改该项目版本号。\n\n在fm_lindaidai_first的命令行中输入指令\n1npm publish\n成功之后会提示\n1+ fm_lindaidai_first@1.0.0\n若是你编写的模块是第一次发布的，则直接使用指令npm publish就可以了若是第二次，则需要在package.json中修改一下version，如修改为1.0.1，然后再次执行npm publish就OK。\n4.使用自己的模块可以直接就在项目中使用指令\n1npm i --save-dev fm_lindaidai_first\n接下来可以在项目中使用\n123var datechange = require(fm_lindaidai_first);var now = new Date();var timeStamp = datechange(now);\n第三章 创建vue组件并发布上面介绍发布的模块是一个比较简单的时间格式转换插件，当然你也可以针对某个框架来发布特定的组件。\n说一下我要实现的效果：1.构建一个基于elementUI的表单生成器组件2.在npm上发布它并使用\n3.1 表单构造器组件想要实现一个表单生成器，我们希望通过prop传入其中，就能构造想要的表单组件如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt;&lt;div&gt;    &lt;form-generator :schema=schema v-model=formData&gt;&lt;div&gt;&lt;template&gt;data() &#123;        return &#123;            formData: &#123;                firstName: Lin,                lastName: DaiDai            &#125;,            schema: [&#123;                    fieldType: SelectList,                    name: food,                    multi: false,                    label: food,                    options: [&#123;                        value: 黄金糕,                        label: 黄金糕                    &#125;, &#123;                        value: 双皮奶,                        label: 双皮奶                    &#125;, &#123;                        value: 蚵仔煎,                        label: 蚵仔煎                    &#125;, &#123;                        value: 龙须面,                        label: 龙须面                    &#125;, &#123;                        value: 北京烤鸭,                        label: 北京烤鸭                    &#125;]                &#125;,                &#123;                    fieldType: TextInput,                    placeholder: First Name,                    label: First Name,                    name: firstName                &#125;,                &#123;                    fieldType: TextInput,                    placeholder: Last Name,                    label: Last Name,                    name: lastName                &#125;,                &#123;                    fieldType: NumberInput,                    placeholder: Age,                    name: age,                    label: Age,                    minValue: 0                &#125;            ]        &#125;\n向名为from-generator的组件中传递一个数组，就能构建出以下表单列表：\n3.1.1 vue-cli创建vue简单项目1vue init webpack-simple form-lin\n我创建的项目名为form-lin\n3.1.2 安装elementUI1npm i element-ui -S\n可以看到我上面的表单类型是有select、input、numberInput、button这几种，所以我没有引入ele的全部组件，只是按需引入了，按需引入还需要借助 babel-plugin-component1npm install babel-plugin-component -D\n然后，将 .babelrc 修改为：123456789101112&#123;  presets: [[es2015, &#123; modules: false &#125;]],  plugins: [    [      component,      &#123;        libraryName: element-ui,        styleLibraryName: theme-chalk      &#125;    ]  ]&#125;\n在main.js中引入部分组件123456import &#123; Button, Select, Input, Option, InputNumber &#125; from element-ui;Vue.component(Button.name, Button);Vue.component(Select.name, Select);Vue.component(Option.name, Option);Vue.component(Input.name, Input);Vue.component(InputNumber.name, InputNumber);\n通过以上步骤你已经可以在你的这个项目中使用elementUI的部分组件了。\n3.1.3 逐个创建表单组件结合上面的效果图，可以发现此项目创建的表单类型只有下拉框、输入框、数字输入框这三种，所以可以分别创建3种不同的组件\n在components文件夹下创建文件夹v5，并在其中分别创建以下三个组件\n\nTextInput.vue\nSelectList.vue\nNumberInput.vue\n\n\nTextInput.vue1234567891011121314151617181920212223242526272829&lt;template&gt;  &lt;div class=v5-template&gt;    &lt;label&gt;&#123;&#123;label&#125;&#125;&lt;label&gt;    &lt;!-- &lt;input type=text           :name=name           :value=value           @input=$emit(input,$event.target.value)           :placeholder=placeholder           &gt; --&gt;    &lt;el-input style=width: 135px; :name=name           :value=value           @input=TextInput           :placeholder=placeholder clearable&gt;&lt;el-input&gt;  &lt;div&gt;           &lt;!-- @input=$emit(input,$event.target.value) --&gt;&lt;template&gt;&lt;script&gt;import &#123; Input &#125; from element-ui;export default &#123;  name: TextInput,  props: [placeholder, label, name, value],  methods: &#123;    TextInput(value) &#123;      this.$emit(input, value);    &#125;  &#125;&#125;&lt;script&gt;\n\n注释部分为原生的input标签\n\nSelectList.vue1234567891011121314151617181920212223242526272829&lt;template&gt;  &lt;div class=v5-template&gt;    &lt;label&gt;&#123;&#123;label&#125;&#125;&lt;label&gt;    &lt;el-select  :multiple=multi                :value=value                @change=SelectVal                placeholder=请选择&gt;      &lt;el-option v-for=option in options                :key=option.value                :label=option.label                :value=option.value&gt;      &lt;el-option&gt;    &lt;el-select&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;import &#123; Select &#125; from element-ui;import &#123; Option &#125; from element-ui;export default &#123;  name: SelectList,  props: [multi, options, name, label, value],  methods: &#123;    SelectVal(value) &#123;      this.$emit(input, value);    &#125;  &#125;&#125;&lt;script&gt;\n\n\nNumberInput.vue1234567891011121314151617181920212223242526272829&lt;template&gt;  &lt;div class=v5-template&gt;    &lt;label&gt;&#123;&#123;label&#125;&#125;&lt;label&gt;    &lt;!-- &lt;input type=number           :name=name           :value=value           @input=$emit(input,           $event.target.value)           :placeholder=placeholder&gt; --&gt;    &lt;el-input-number :name=name           :value=value            @change=InputNumber           :placeholder=placeholder controls-position=right :min=1 :max=10&gt;    &lt;el-input-number&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;import &#123; InputNumber &#125; from element-ui;export default &#123;  name: NumberInput,  props: [placeholder, label, name, value],  methods: &#123;    InputNumber(value) &#123;      this.$emit(input, value);    &#125;  &#125;&#125;&lt;script&gt;\n\n完成以上步骤，我们创建了三种不同的表单组件接下来我们需要用一个生成器来将这三种表单组件联系起来\n3.1.4 表单生成器上面所创建的三种不同的组件，其实都可以用component标签来进行引入，只需要改变component标签的:is属性就可以了。如12345&lt;!--输入框组件--&gt;&lt;component :is=TextInput&gt;&lt;component&gt;&lt;!--下拉框组件--&gt;&lt;component :is=SelectList&gt;&lt;component&gt;\n那么我们就可以通过v-for来循环创建不同的表单组件，仅仅只需要改变:is的值就行了\n接下来 还是在v5文件夹下，创建文件FormGenerator.vue\n\nFormGenerator.vue12345678910111213141516171819202122232425262728293031323334&lt;template&gt;  &lt;div&gt;    &lt;component v-for=(field, index) in schema               :key=index               :is=field.fieldType               :value=formData[field.name]               @input=updateForm(field.name, $event)               v-bind=field&gt;    &lt;component&gt;      &lt;div&gt;&lt;template&gt;&lt;script&gt;import NumberInput from .NumberInput;import SelectList from .SelectList;import TextInput from .TextInput;export default &#123;  name: FormGenerator,  components: &#123; NumberInput, SelectList, TextInput &#125;,  props: [schema, value],  data() &#123;    return &#123;      formData: this.value || &#123;&#125;    &#125;;  &#125;,  methods: &#123;    updateForm(fieldName, value) &#123;      this.$set(this.formData, fieldName, value);      this.$emit(input, this.formData);    &#125;  &#125;&#125;;&lt;script&gt;\n\nv-for不用多说，schema就是我们在引用这个组件时外部传递进来表单数组:is就是表单组件的类型@input在使用component标签时，默认的事件名就是为input，值为value\n3.1.5 调用表单构造器完成以上步骤，我们可以在这个项目中本地调用以下这个组件在APP.vue中引用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt;&lt;div&gt;    &lt;form-generator        :schema=schema        v-model=formData    &gt;    &lt;form-generator&gt;    &lt;p&gt;        Hello &#123;&#123;formData.title&#125;&#125; &#123;&#123;formData.firstName&#125;&#125; &#123;&#123;formData.lastName&#125;&#125;, I hear you are &#123;&#123;formData.age&#125;&#125; years old.    &lt;p&gt;&lt;div&gt;&lt;template&gt;&lt;script&gt;import FormGenerator from .componentsv5FormGenerator;export default &#123;    name: formlin,    components: &#123;        FormGenerator     &#125;,    methods: &#123;    &#125;,    data() &#123;        return &#123;            formData: &#123;                firstName: Lin,                lastName: DaiDai            &#125;,            schema: [&#123;                    fieldType: SelectList,                    name: food,                    multi: false,                    label: food,                    options: [...]                &#125;,                &#123;                    fieldType: TextInput,                    placeholder: First Name,                    label: First Name,                    name: firstName                &#125;,                &#123;                    fieldType: TextInput,                    placeholder: Last Name,                    label: Last Name,                    name: lastName                &#125;,                &#123;                    fieldType: NumberInput,                    placeholder: Age,                    name: age,                    label: Age,                    minValue: 0                &#125;            ]        &#125;    &#125;&#125;&lt;script&gt;&lt;style&gt;&lt;style&gt;\n使用npm run dev打开项目，是可以在页面中看到效果的，此时整个项目目录如下：style文件夹是我个人创建的公用样式DemoFive.vue和HellowWorld.vue可以忽略srcindex.js在后面会讲到。\n3.2 将整个vue项目发布至npm要想将vue项目发布至npm上，需要做一些配置\n\n修改package.json\n\n修改”private”: falsenpm默认创建的项目是私有的，如果要发布至npm必须将其公开\n\n添加”main”: “distbuild.js”通过import formlin from ‘form-lin’引用该组件时，项目会自动找到node_modulesload-ling-zidistbuild.js\n\n\n\n\n在src加入组件代码App.vue， 并创建我们的导出文件index.js。 在index.js中添加：\n12345678import formlin from .App.vueexport default formlin;global 情况下 自动安装if (typeof window !== undefined &amp;&amp; window.Vue) &#123;    window.Vue.component(formlin, formlin);&#125;\n\n在APP.vue中做一些修改\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt;&lt;div&gt;    &lt;h1&gt;Form Generator&lt;h1&gt;    &lt;form-generator        :schema=schema        v-model=formData    &gt;    &lt;form-generator&gt;    &lt;el-button @click=outPut&gt;提交&lt;el-button&gt;    &lt;p&gt;        Hello &#123;&#123;formData.title&#125;&#125; &#123;&#123;formData.firstName&#125;&#125; &#123;&#123;formData.lastName&#125;&#125;, I hear you are &#123;&#123;formData.age&#125;&#125; years old.    &lt;p&gt;    &lt;demo-five&gt;&lt;demo-five&gt;&lt;div&gt;&lt;template&gt;&lt;script&gt;import DemoFive from .componentsDemoFive.vue;import FormGenerator from .componentsv5FormGenerator;import &#123; Button &#125; from element-ui;export default &#123;    name: formlin,    components: &#123;        DemoFive,        FormGenerator     &#125;,    methods: &#123;        outPut() &#123;            this.$emit(submit, this.formData);        &#125;    &#125;,    data() &#123;        return &#123;            formData: &#123;                firstName: Lin,                lastName: DaiDai            &#125;,            schema: [&#123;...&#125;]        &#125;    &#125;&#125;&lt;script&gt;&lt;style&gt;@import .stylecommon.css;&lt;style&gt;\n\n\n在el-button标签中添加一个click事件，用于输出formData再将name修改为你要模块的名字，如我这里修改为formlin\n\n因为最后我们是打包成一个js文件，所以需要修改一下配置文件webpack.config.js\n\n因为不是所有使用你组件的人都是通过npm按住和impor的很多人是通过直接引入的,我们要将libraryTarget改为umd,以及修改入口文件与设置导出文件目录以及名称。123456789entry: .srcindex.js,output: &#123;path: path.resolve(__dirname, .dist),publicPath: dist,filename: build.js,library: formlin,libraryTarget: umd,umdNamedDefine: true&#125;,\n\n最后需要把.gitignore文件里面的dist删除掉要不然上传时会忽略掉dist打包的文件。\n\n完成上述步骤之后，我们就可以开始正式发布了，首先要将整个项目进行打包使用指令1npm run build\n如果报错，请检查你是否安装了相关的依赖执行完毕之后，目录下会出现dist文件夹，里面存放的就是压缩的js文件继续执行指令1npm publish\n提示1+ form-lin@1.0.0\n则表示发布成功。\n3.3 使用vue组件我们将自己的vue模块已经发布到了npm上面，那么怎样使用它呢。\n首先我还是先创建一个vue-cli项目，然后等会再用1npm i formlin -D\n看是否能够使用它。\n\n创建use-form-lin项目1vue init webpack use-form-lin\n\n\n再使用指令12npm install element-ui -Snpm install form-lin babel-plugin-component -D\n需要配置以下12345678910111213141516171819202122main.jsimport &#123; Button, Select, Input, Option, InputNumber &#125; from element-ui;Vue.config.productionTip = false;Vue.component(Button.name, Button);Vue.component(Select.name, Select);Vue.component(Option.name, Option);Vue.component(Input.name, Input);Vue.component(InputNumber.name, InputNumber);.babelrc&#123;  presets: [[es2015, &#123; modules: false &#125;]],  plugins: [    [      component,      &#123;        libraryName: element-ui,        styleLibraryName: theme-chalk      &#125;    ]  ]&#125;\n\n组件依赖于elementUI  以上步骤是配置elementUI 当然也可以参考elementUI官网全局引用ele组件传送门elementUI\n\n\n在APP.vue中使用123456789101112131415161718192021&lt;template&gt;  &lt;div id=app&gt;    &lt;h3&gt;use form-lin&lt;h3&gt;    &lt;formlin @submit=submitForm&gt;&lt;formlin&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;import formlin from form-linexport default &#123;  name: App,  components: &#123;    formlin: formlin  &#125;,  methods: &#123;    submitForm($event) &#123;      console.log($event);    &#125;  &#125;&#125;&lt;script&gt;\n\n\n使用npm run dev打开页面可以看到效果：\n后语\n实现的功能很简单而且也很low ，甚至还要依赖于其他的UI组件，比较创建的这个vue组件里面的表单内容是写死的，你也可以多加一个prop值将内容传进去最后想说的是 每个人在学习一样新东西的时候肯定都会碰到各种意想不到的情况，有时候你甚至和参考来的代码一模一样都不能实现相同的效果但希望你能够坚持 在一个胡同了转太久了总是弄不出来一个东西时 你可以选择休息以下或者第二天再弄 总之不要放弃就OK\n\n上面vue组件的源码已经上传只git 有兴趣的小伙可以给个小心心https:github.comLinDaiDaivuetreemasterform-lin\n","tags":["其它技能","npm","vue"],"path":"2016/02/08/otherSkill/Npm/npmOfPublic/","external_link":""},{"title":"Angular4升级为Angular7进阶指南","date":"2019-01-26T12:47:15.000Z","content":"前言光阴似箭，入职现在的公司已经一年多了，回想刚入职时还是第一次接触到angular，当时angular4出来也没有多久，所以对这门新技术也是报以期待。一年多内，我们的产品也从我刚来时的v1.03版本迭代到了v2.0。但在此过程中，我们前端团队一直忙于业务功能的开发，而忽视了“工具”本身的进阶。导致angular中很多新的功能甚至是很多新的UI组件不能使用。在年前开发完公司产品的v2.0版本之后，我终于能抽出来一些时间为整个项目做一个升级，以下为此次升级的一些步骤已经才到的坑，希望能对小伙们有一些帮助。\n1. 开始前准备1.备份你的项目2.确保你的环境满足一下要求12$ node -v node &gt;= 8.9.0  $ npm -v npm &gt;= 5.6.0\n3.删除你项目根目录下的 package-lock.json 文件\n2. Angular4升级为Angular5由于整个项目过于庞大，也是为了试试水，所以在此次升级的过程中，我想先升级为5.0来看看。查阅了一些资料，发现Angular官网是有一篇升级指南。打开升级指南，将初始版本号选择4.0，升级到的版本号选择到5.0。点击Show me how to update!按钮，查看升级步骤。在升级步骤中，前面两个小步骤提示按上面的做法做就可以了。如果你的项目不是使用en-us以外的语言环境的应用程序，则直接在项目的根目录执行一下命令：1npm install @angularanimations@^5.0.0 @angularcommon@^5.0.0 @angularcompiler@^5.0.0 @angularcompiler-cli@^5.0.0 @angularcore@^5.0.0 @angularforms@^5.0.0 @angularhttp@^5.0.0 @angularplatform-browser@^5.0.0 @angularplatform-browser-dynamic@^5.0.0 @angularplatform-server@^5.0.0 @angularrouter@^5.0.0 typescript@2.4.2 rxjs@^5.5.2\n1npm install typescript@2.4.2 --save-exact\n或者使用淘宝镜像cnpm。\n升级完之后，如果你的项目中使用了router，会看到使用路由的地方爆一些错，查阅了一下资料，是Angular5中路由的一些改动，由于在后面的版本中也做了相应的调整，所以在这里我就没有管它，而是继续后面的升级。\n3. 升级本地的Angular-cli在这里我是先卸载原先的Angular-cli，然后再安装最新版。123$ npm uninstall -g @angularcli     卸载旧版本cli。$ npm cache clean    清除缓存，确保卸载干净$ npm install -g @angularcli@latest  安装最新版本的cli\n注：如果卸载全局包失败可以在本地目录下手动删除（window10）C:UsersHUAWEIAppDataRoamingnpmnode_modules（一般存在于C盘的用户文件夹下）安装完毕之后使用指令查看：1$ ng -v\n4. Angular5到Angular7升级了本地的Angular-cli之后，就可以对项目进行升级了。依次执行一下命令123456npm install @angularcling update @angularcling update @angularcoreng updatenpm install -g rxjs-tslintrxjs-5-to-6-migrate -p srctsconfig.app.json\n上面依次更新的是angularcli,angularcore，以及rxjs。\n5. 项目代码报错调整升级完毕之后，打开项目文件，许多代码可能会报错，一般都是在你的http方法中。\n5.1 Observable和Subject若是你的代码中有使用到12import &#123; Observable &#125; from rxjsObservable;import &#123; Subject &#125; from rxjsSubject;\n的地方，则可能会报错，因为新版本的rxjs做了一些改变，你只需要按以下写法就可以1import &#123; Observable ,  Subject &#125; from rxjs;\n5. 2 timeout, map, filter, mergeMap等同时有用到timeout,map, filter, mergeMap的地方(一般http请求的时候有用到),也需要进行响应调整1import &#123; timeout, map, filter, mergeMap &#125; from &apos;rxjsoperators&apos;\n新版本的timeout,map, filter, mergeMap在rxjsoperators中调用。原来的引用方式是：1234567let xhr = this.http.post(url, data, option).timeout(60000).toPromise().then(res =&gt; &#123;  ...&#125;)\n此时也要修改为1234567let xhr = this.http.post(url, data, option).pipe(timeout(60000)).toPromise().then(res =&gt; &#123;  ...&#125;)\n在使用时需要用pipe()盛放起来。同理：1234567891011121314this.router.events    .pipe(      filter(event =&gt; event instanceof NavigationEnd),      map(() =&gt; this.activatedRoute),      map(route =&gt; &#123;        while (route[firstChild]) route = route[firstChild];        return route;      &#125;),      filter(route =&gt; route[outlet] === primary),      mergeMap(route =&gt; route[data])    )  .subscribe(event =&gt; &#123;    ...  &#125;)\n后语在将项目成功升级之后，就可以开心的使用NG-ZORRO了(原本使用的UI库为primeng)。在这里安利一波antd，这真的是一个很强大的UI库，现在前端主流的三大框架vue, react, angular，它都有对应的库，如angular中的NG-ZORRO。升级参考：记NG4 迁移到 NG6 的一次实践\n","tags":["前端进阶","Angular"],"path":"2019/01/26/webNotes/advanced/Angular/advanceAngular7/","external_link":""},{"title":"Angular4中自定义管道","date":"2018-08-08T12:22:00.000Z","content":"前言\nAngular 是由谷歌开发与维护一个开发跨平台应用程序的框架，同时适用于手机与桌面。管道的作用是把数据作为输入，然后转换它，给出期望的输出。\n1.1 使用管道如：\n1234567891011import &#123; Component &#125; from @angularcore;@Component(&#123;  selector: app-hero-birthday,  template: `&lt;p&gt;&#123;&#123; birthday &#125;&#125;&lt;p&gt;`&#125;)export class HeroBirthdayComponent &#123;  birthday = new Date(1988, 3, 15); &#125; 不使用管道时，显示： Fri Apr 15 1988 00:00:00 GMT+0800 (中国标准时间)\n使用管道后：\n12&lt;p&gt;&#123;&#123; birthday | date &#125;&#125;&lt;p&gt; Apr 15, 1988\n1.2 参数化管道上面的案例中，使用的是data管道，来进行时间转换，有其默认的转换格式，我们也可以自定义转换格式，只需要像data管道中传递参数就可以了。\n比如我们想要上面的信息转换为19980315的格式\n1&lt;p&gt;&#123;&#123; birthday | date:yyyyMMdd &#125;&#125;&lt;p&gt;\n1.3 自定义管道angular4还支持自定义管道，你可以自己定义想要的管道。\n近期接到这样一个需求：\n要求在多个页面中显示用户的头像图片，但有的用户没有上传头像的话，就需要系统根据用户性别显示默认的男女头像。\n当然这样一个简单的需求无论你是在HTML进行判断还是在js中判断都可以实现。\n当若是有多个页面都需要用到的话，似乎也是一项比较繁重的任务。\n所以你可以选择封装一个共用的方法在每个页面进行调用或者可以尝试自定义一个管道。    \n博主工作中使用的是前端框架Angularjs4，项目整体是使用angular-cli进行搭建的，下面介绍的是如何在angularjs中自定义一个管道。\n\n1.确定需求\n\n1234多个页面显示用户头像若是头像图片地址不存在则判断用户性别根据用户性别显示默认的男女头像若是性别和头像图片地址都不存在则显示默认的人形头像\n\n2.设计管道\n\n1.前期准备\n在项目目录srcappcommon文件夹下创建一个新文件夹pipe，并在pipe中创建一个comm.pipe.ts文件。\n(common文件夹是我存放一些公共组件方法管道的文件夹,它是一个功能的模块，其中的所有组件方法管道我都会在common文件夹下的shared.module.ts中进行导出)\n2.编写comm.pipe.ts\n自定义管道需要先引入@angularcore中的Pipe和PipeTransform\n12345678910111213141516171819comm.pipe.tsimport &#123; Pipe, PipeTransform &#125; from @angularcore;const sexList = [, 男, 女];const uHeadImg = [.assetsimagesdefault_male.png, .assetsimagesboy.png, .assetsimagesgirl.png];@Pipe(&#123; name: portrait &#125;)export class Portrait implements PipeTransform &#123;    transform(value): string &#123;        let url = ;        if (value === 男 || value === 女) &#123;            let idx = sexList.indexOf(value);            url = uHeadImg[idx];        &#125; else &#123;            url = value ? value : uHeadImg[0];        &#125;        return url;    &#125;&#125;\n\n定义俩个数组一个为性别，一个为三种图片的存放路径\n需要使用@Pipe来装饰类\n实现PipeTransform的transform方法，该方法接受一个输入值和一些可选参数\n在@Pipe装饰器中指定管道的名字，这个名字就可以在模板中使用。\ntransform为PipeTransform中继承而来的方法，它接收0个或多个参数\n\n\n3.导出自定义管道\n\n在shared.module.ts中导出：\n12345678910111213141516171819202122shared.module.tsimport &#123; NgModule &#125; from @angularcore;import &#123; Portrait &#125; from .pipecomm.pipe;...@NgModule(&#123;  imports: [    ...  ],  declarations: [  \t...    Portrait  ],  exports: [    ...    Portrait  ]&#125;)export class SharedModule &#123;&#125;\n\n4.使用管道\n\n由于管道是在shared.module.ts中导出的，因此要使用它就必须在要使用的模块中导入\n如在student这个模块中使用\n1.首先在student.module.ts中引用\n12345678910111213141516171819student.module.tsimport &#123; NgModule &#125; from @angularcore;import &#123; SharedModule &#125; from ...commonshared.module;...import &#123; Students &#125; from .students; students为该模块下的一个页面@NgModule(&#123;  imports: [    SharedModule,    ...  ],  declarations: [    Students  ],  providers: [  ]&#125;)export class StudentModule &#123; &#125;\n2.在页面中使用：\n12345students.component.html&lt;div class=uHead&gt;\t&lt;span&gt;学员头像：&lt;span&gt;\t&lt;img src=&#123;&#123;studentInfo[uHeadUrl]||studentInfo.sex | portrait&#125;&#125; title=头像 alt=头像&gt;&lt;div&gt;\n1231. 图片的src是需要用&#123;&#123;&#125;&#125;的方式2. studentInfo[&apos;uHeadUrl&apos;]||studentInfo.sex就是传递给管道的参数，表示为如果有头像路径则传递头像路径，没有则传递性别。3. | potrait表示使用名为potrait的管道，就是你在 comm.pipe.ts中定义的name\n\n5.总结\n\n在angularjs4中使用管道总结为这么几步：\n1.定义一个自定义管道的ts并引入@angularcore中的Pipe来编写管道\n2.将自定义管道的ts在模块中导出\n3.要使用管道的模块中引入管道模块\n4.html中使用的话采用以下方式：\n1&#123;&#123; info | PipeName &#125;&#125;   PipeName为你自定义的管道名称","tags":["前端进阶","Angular"],"path":"2018/08/08/webNotes/advanced/Angular/angularOfPipe/","external_link":""},{"title":"position:fixed什么时候会失效？","date":"2019-01-16T14:10:15.000Z","content":"position:fixed什么时候会失效？我们知道，设置了position: fixed固定定位属性的元素会脱离文档流，达到“超然脱俗”的境界。也就是说此时给这种元素设置top, left, right, bottom等属性是根据浏览器窗口定位的，与其上级元素的位置无关。但是有一种情况例外：若是设置了position: fixed属性的元素，它的上级元素设置了transform属性则会导致固定定位属性失效。无论你的transform设置的是什么属性都会影响到position: fixed。看下面的案例1：12345678910111213141516171819202122&lt;style&gt;    .father &#123;        width: 300px;        height: 300px;        background: yellow;        transform: translate(100px);         * transform: scale(0.5); *        * transform: rotate(-45deg); *    &#125;    .son &#123;        width: 100px;        height: 100px;        background: red;        position: fixed;        top: 400px;    &#125;&lt;style&gt;&lt;body&gt;&lt;div class=father&gt;   &lt;div class=son&gt;&lt;div&gt;&lt;div&gt;&lt;body&gt;\n给父级加上了transform属性之后就会影响子级的固定定位了。如下图：\n\n其实不仅仅是给父级加transform属性会失效，只要上级存在transform属性都会导致position: fixed失效。\n案例2：123456789101112131415161718192021222324&lt;style&gt;    .content&#123;        transform: translate(100px);    &#125;    .father &#123;        width: 300px;        height: 300px;        background: yellow;    &#125;    .son &#123;        width: 100px;        height: 100px;        background: red;        position: fixed;        top: 400px;    &#125;&lt;style&gt;&lt;body&gt;    &lt;div class=content&gt;        &lt;div class=father&gt;            &lt;div class=son&gt;&lt;div&gt;        &lt;div&gt;    &lt;div&gt;&lt;body&gt;\n上面的案例也会影响position: fixed属性。\n","tags":["前端进阶","css"],"path":"2019/01/16/webNotes/advanced/CSS/positionOfInvalid/","external_link":""},{"title":"使用Hexo快速搭建博客","date":"2019-02-24T07:15:35.000Z","content":"这是一篇教你快速搭建自己博客并进行上线部署的文章。不管你是不是前端，不管你对Hexo了解多少，只要你按照下面的步骤一步一步来，我保证你能够在个把小时里创建出你想要的个人博客。\n\n看下效果？我们在去做一件事之前肯定是抱有一定的目的性，在你被这个标题吸引进来之后我想我就知道你的目的了。所以先来看看接下来要搭建的博客的最终效果：霖呆呆的个人博客: https:lindaidai.wang\n30秒了解HexoHexo 是一个快速、简洁且高效的博客框架。它使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。也就是能帮助我们快速的搭建自己的博客。Hexo博客搭建的基础大致为：\n\n安装node.js\n安装Git\n安装Hexo\n创建Hexo项目并进行本地测试运行\n注册github并创建一个存放Hexo博客项目的仓库\n部署上你的博客项目\n修改博客主题theme\n\n前期准备安装node.js如果你的电脑上已经安装了node.js的话则你可以跳过这一步骤。Hexo是基于node.js的, 所以我们在安装它之前需要用到npm安装工具, 这个工具是 node.js 安装包的工具, 所以, 我们先要安装 node.js。安装node.js很简单，直接去nodejs官网下载对应的版本就可以了。下载安装完毕之后可以进行检测一下，看是否正常安装。打开你的cmd(终端)，输入node -v回车，看是否显示了版本号。比如我这里显示的是1v10.14.1\n证明安装完毕。安装完毕了nodejs之后，你的电脑就自带了npm，你就可以使用npm的指令来下载其它东西了。比如我们可以先装一个cnpm。它其实就是一个淘宝npm镜像，在国内来说会使下载速度快一些。123$ npm install cnpm -g或者$ npm i cnpm -g\n($符号不需要打出来，只是表示这个指令是在终端上运行的，-g表示的是全局安装，这样你就可以在你电脑的任意文件夹下使用)\n安装Git如果你的电脑上已经安装了Git的话则你可以跳过这一步骤。直接去官网上下载安装：Git下载地址我们知道Git的主要作用是代码托管，这里为什么也要用到Git呢。是因为我们在创建完了博客项目之后需要将其部署到Git上，相当于上线这个博客，这样其他人就能通过一个网址直接访问你的博客了。想了解Git的小伙可以看这里：Git基础知识-霖呆呆\n安装Hexo现在我们可以使用npm或者cnpm来安装hexo了：1$ npm i hexo-cli -g\n同样的你在安装完毕之后可以使用指令来查看是否安装成功：1$ hexo -v\n如下图：\n创建博客前期准备都完毕之后，让我们来创建自己的第一个博客吧。\n创建一个名为my-hexo-blog的网站将终端上的路径设置为你想要放博客项目的路径。比如我想把我的博客项目放到D盘的projects文件夹下，则在终端打开D:projects。进入了文件夹下，在终端输入指令：1$ hexo init my-hexo-blog\n你不想用my-hexo-blog这个名字的话用其他的也可以。 (如果不写my-hexo-blog, 就会在当前目录进行初始化. 如果后面跟了名子就会创建目录并在目录进行初始化操作, 以这个名子为目录名.)\n本地运行博客执行完init指令之后，会看到你的目录下多出了一个my-hexo-blog文件夹，这个就是你刚刚生成的博客项目。你看到的应该是这样的文件夹：\n此时我们在进入这个项目的目录里。使用指令：1$ cd my-hexo-blog\n跳转进项目目录。\n进入到项目目录之后，在执行指令：12345$ npm install或者$ npm i或者$ cnpm i\n用于安装项目的依赖(你可以把它理解为java中的各种包)。\n接下来我们就可以来启动它了，使用指令：123$ hexo server或者$ hexo s\n此时，它会提示你12INFO  Start processingINFO  Hexo is running at http:localhost:4000 . Press Ctrl+C to stop.\n也就证明你的博客项目已经启动了，你只需要打开浏览器并在网址中输入localhost:4000即可访问你的博客了。可以看到，博客应该是长这样的：\n部署博客项目通过上面的步骤我们已经使博客项目在本地正常的跑去来了，下面该如何部署上线呢？\n创建github账号并创建一个仓库创建仓库如果你有自己的github账号的话登录即可，没有的话在github上先行创建。登录成功之后点击右上角的New repositories创建一个新的仓库，用于你的博客部署。这个仓库的名字需要和你的github名对应，格式: yourname.github.io由于我的github名为LinDaiDai，所以我创建的项目名为LinDaiDai.github.io。\n查看SSHSSH公钥默认储存在账户的主目录下的 ~.ssh 目录。在终端输入：12$ cd ~.ssh$ ls\n如果返回 something 和 something.pub，说明已经有 SSH 公钥。如下图：\n如是没有SSH的话则需要手动生成。还是在.ssh目录下，执行命令：1ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;\n按 3 个回车，密码为空。\n在 C:UsersAdministrator.ssh 下，得到两个文件 id_rsa 和 id_rsa.pub。\nGitHub 上添加 SSH 密钥打开 id_rsa.pub，复制全文到 https:github.comsettingsssh ，Add SSH key，粘贴进去。\n修改博客项目目录下的_config.yml配置文件打开我们博客项目目录下的_config.yml文件(使用记事本或者Notepad++直接打开)在该文件的最下面加上以下代码：1234deploy:  type: git  repository: git@github.com:LinDaiDaiLinDaiDai.github.io.git  branch: master\n将repository中的地址换成你刚刚新建的仓库的地址即可。Ctrl + s保存修改。注意：在type前面需要增加两个空格, 在type的冒号后面需要增加一个空格。 请保持代码风格一致，否则会出现错误或是不正确的问题。\n安装部署使用到的git插件在这里我们使用的是git源码管理工具, 所以, 我们需要安装git包来进行部署, 安装这个插件才能使用git进行自动部署。在博客项目目录下执行指令：1$ npm i hexo-deployer-git --save\n自动生成网站并部署当我们部署网站前, 需要先生成静态网站。它会自动在目录下创建public的目录, 并将新生成的网页存放在这个目录里。只需要在博客项目目录下执行指令：1$ hexo g\n此时就会生成public目录。\n然后进行自动部署网站：1$ hexo d\n上面的两步你可以合成一步：1$ hexo g -d\n部署成功后会提示：1[INFO] Deploy done: git\n如果在部署时出现一下错误信息，请参考上面的步骤进行git插件的安装1ERROR Deployer not found: git\n上面的步骤全部完成之后，恭喜你，你已经成功完成了个人博客的部署上线，此时打开你的浏览器并输入https:userName.github.io看看吧。    \n","tags":["hexo","前端进阶"],"path":"2019/02/24/webNotes/advanced/Hexo/createHexoBlog/","external_link":""},{"title":"Angular/Typescript全局变量解决方案","date":"2017-12-15T12:47:15.000Z","content":"前言\n在其它前端框架中都有适用于框架本身的状态管理\nvue的vuex、react的redux\nangular中最为官方的也就是使用Rx\n在网上搜索了以下\n可以参考 Managing State in Angular 2 Applications ，理论上 Redux 能实现的功能 Rx 当然也都可以\n也有 Rx 和 Redux 的组合产品，比如 GitHub - ngrxstore: RxJS powered state management for Angular2 apps, inspired by Redux \n\n1. 前期准备当然你也可以自己手动撸一个适用于angular2Typescript的状态管理模块,也就是类似于全局变量的这种\n首先要明确一点,在angular中,app-root这个组件是最大的那个父级组件,因此其它的所有组件都是它的子组件\n而在angular中组件引用一个服务需要这样：\nSomeSharedService.ts\n123456789import &#123; Injectable &#125; from @angularcore@Injectable()export class SomeSharedService &#123;  public globalVar = LinDaiDai;  updateGlobaleVar(newVal) &#123;    this.globalVar = newVal;  &#125;&#125;\napp.component.ts\n123456789101112131415161718192021import &#123; Component, OnInit &#125; from @angularcore;import &#123; SomeSharedService &#125; from .SomeSharedService;@Component(&#123;  selector: app-root,  templateUrl: .app.component.html,  styleUrls: [.app.component.css],  providers: [SomeSharedService]&#125;)export class AppComponent implements OnInit&#123;\tconstructor(\t\tpublic someSharedService: SomeSharedService\t)&#123;&#125;\tngOnInit() &#123;      this.getSharedService();\t&#125;\tgetSharedService() &#123;      let info = this.someShareService.golobalVar;      console.log(info);LinDaiDai\t&#125;&#125;\n上面的步骤是创建一个SomeSharedService服务并将其引入到app.component.ts中\n此时再创建一个子组件\nchild.component.ts\n12345678910111213141516171819202122232425262728import &#123; Component, OnInit &#125; from @angularcore;import &#123; SomeSharedService &#125; from .SomeSharedService;@Component(&#123;  selector: app-root,  templateUrl: .child.component.html,  styleUrls: [.child.component.css],  providers: [SomeSharedService] 不用在child中的providers引入SomeSharedService&#125;)export class ChildComponent implements OnInit &#123;\tconstructor(\t\tpublic someSharedService: SomeSharedService\t)&#123;&#125;\tngOnInit() &#123;      this.getSharedService();先获取      this.updateSharedService();重新设置新的值\t&#125;\tgetSharedService() &#123;      let info = this.someShareService.globalVar;LinDaiDai      do something\t&#125;\tupdateSharedService() &#123;      setTimeout(() =&gt; &#123;        this.someShareService.updateSharedService(霖呆呆);        this.getSharedService();霖呆呆      &#125;, 3000)\t&#125;&#125;\n可以看到上面的案例,在子组件中再次引入SomeSharedService但是不要将其注入到子组件的providers中,子组件获取到的golobalVar就不会重新刷新,并且也可以直接改变someShareService中的bianl\n此时,在其它的子组件中获取到的someShareService.globalVar就是已经发生改变了的&#39;霖呆呆&#39;\n按照这个思路，创建一个自己的全局变量管理就不难了\n1.我们只需要定义一个ts文件，里面存放的是一些全局变量\n2.在app.component.ts中引用这个ts,并将其加入到app的providers中,不然在控制台中就会报错\n3.在要用到全局变量的地方引用这个ts，但不需要在providers中引入,不然会注入新创建的实例\n2.自定义的store如果你是angularcli Typescript的使用者,请参考以下\n1.在app根目录下创建文件夹store,在其中创建俩个文件：store.ts 和 state.ts\nstate.ts\n123456import &#123; Injectable &#125; from @angularcore;@Injectable()export class State &#123;    globalVar = &#123;&#125;某个全局变量&#125;\n\nstate.ts用于保存一些全局变量\n\nstore.ts\n12345678910111213141516171819202122232425262728import &#123; Injectable &#125; from @angularcore;import &#123; Http, Response, Headers, RequestOptions &#125; from @angularhttp;import &#123; State &#125; from .state;@Injectable()export class Store &#123;    constructor(        private http: Http    ) &#123;        this.state = new State()     &#125;    state: any;\tasync getGlobalVar() &#123;      if (!this.state.globalVar) &#123;若是没有这个全局变量则代表首次获取        this.state.globalVar = await this.thisIsPromise();        return this.state.globalVar;      &#125; else &#123;        return this.state.globalVar;      &#125;\t&#125;\tasync thisIsPromise() &#123;通过异步请求获取globalVar      await new Promise(() =&gt; &#123;        ....      &#125;)\t&#125;\tclearState() &#123;      this.state = &#123;...State&#125;;利用解构初始化state\t&#125;&#125;\n\n引入state.ts 并实例化一个state的全局对象\n\n2.在app.component.ts中引入store.ts并添加至providers中\n12345678910111213141516...import &#123; Store &#125; from ...appstorestore;...@Component(&#123;  selector: app-root,  templateUrl: .app.component.html,  styleUrls: [.app.component.css],  providers: [Store]&#125;)export class AppComponent &#123;  constructor(\t...    public store: Store,\t...  ) &#123; &#125;&#125;\n3.子组件child.component.ts中引入store.ts不添加至providers\n1234567891011121314151617181920import &#123; Component, OnInit &#125; from @angularcore;import &#123; Store &#125; from ...storestore;@Component(&#123;  selector: app-root,  templateUrl: .child.component.html,  styleUrls: [.child.component.css]&#125;)export class ChildComponent implements OnInit &#123;\tconstructor(\t\tpublic store: Store\t)&#123;&#125;\tngOnInit() &#123;      this.getSharedService();\t&#125;\tgetGlobalVar() &#123;      let info = this.store.getGlobalVar();      do something\t&#125;&#125;\n\n此时获取到的store.getGlobalVar()就是全局的变量了\n\n","tags":["前端进阶","Angular"],"path":"2017/12/15/webNotes/advanced/Angular/globalOfAngular/","external_link":""},{"title":"H5新标签","date":"2017-03-08T11:24:45.000Z","content":"1.DialogH5新增标签Dialog\n基本用法：\n123456789101112131415161718192021222324&lt;body&gt;\t&lt;dialog id=demo-modal&gt;        &lt;h3 class=modal-header&gt;A native modal dialog box&lt;h3&gt;        &lt;div class=modal-body&gt;            &lt;p&gt;Finally, HTML has a native dialog box element! This is fantastic.&lt;p&gt;            &lt;p&gt;And a polyfill makes this usable today.&lt;p&gt;        &lt;div&gt;        &lt;footer class=modal-footer&gt;            &lt;button id=close onclick=closeDialog() type=button&gt;close&lt;button&gt;        &lt;footer&gt;    &lt;dialog&gt;    &lt;button onclick=clickDialog()&gt;按钮&lt;button&gt; &lt;body&gt; &lt;script&gt; \tconst modal = document.querySelector(dialog);        function clickDialog() &#123;             使对话框出现（添加 `open` 属性）            modal.showModal();        &#125;        function closeDialog() &#123;             隐藏对话框（移除 `open` 属性）            modal.close();        &#125;  &lt;script&gt;\nshowModal()方法可以给Dialog标签添加一个open属性，也就是使得Dialog可见。\nclose()方法关闭Dialog\n123&lt;dialog open&gt;\t我是一个可见的dialog&lt;dialog&gt;\n","tags":["前端进阶","Html"],"path":"2017/03/08/webNotes/advanced/HTML/htmlNewTag/","external_link":""},{"title":"面试题","date":"2016-02-08T11:24:45.000Z","content":"面试题一","tags":["前端入门","面试"],"path":"2016/02/08/webNotes/advanced/Interview/interview1/","external_link":""},{"title":"nth伪类选择器","date":"2016-03-08T11:24:45.000Z","content":"1 :nth-child(){ }\n作用： 选择父元素的第几个子元素\n\n1234567&lt;body&gt;\t&lt;div&gt;\t\t&lt;p&gt;&lt;p&gt;\t\t&lt;p&gt;&lt;p&gt;\t\t&lt;p&gt;&lt;p&gt;\t&lt;div&gt;&lt;body&gt;\n用法1:所有子元素:123div:nth-child(n)&#123;\tcolor: red;&#125;\n用法2:所有奇数子元素:123div:nth-child(2n+1)&#123;\tcolor: red;&#125;\n用法3:所有偶数子元素 :123div:nth-child(2n)&#123;\tcolor: red;&#125;\n用法4:选择父元素的第几个子元素123div:nth-child(2)&#123;\tcolor: red;&#125;\n用法5:选择父元素标签内部第n个元素第n个元素必须的是:前面的这个标签才能生效 如果匹配失败，则不生效\n例：\n1234567891011121314&lt;style&gt;    ul p:nth-child(2) &#123;        background: red;*无效：想选择的是ul下的第二个p标签，但ul标签中没有p标签 所以不能生效;*    &#125;    ul li:nth-child(2) &#123;*有效：想选择的是ul下的第二个li标签，nth-child(2)前面也是li 所以能生效;*        background: red;    &#125;&lt;style&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;我是li1&lt;li&gt;        &lt;li&gt;我是li2&lt;li&gt;    &lt;ul&gt;&lt;body&gt;\n用法6 :nth-child(n+m){}\n表示从第m个值开始,取包裹m的之后的所有项\n\n例：\n1234:nth-child(n+2)&#123;&#125;     表示选取除了第一项的所有项:nth-child(-n+m)&#123;&#125;     表示选取前m项(包裹m)如：:nth-child(-n+2)     表示选取第一第二项;\n2 :nth-last-child(){}\n用法：与:nth-child()用法相似，不过是从后往前\n\n如：\n选择父元素的倒数第二个子元素的 div 标签\n1div:nth-last-child(2)&#123; &#125;\n3 :nth-of-type(){ }\n作用：选择属于其父元素的 第几个标签元素\n\n例：选择父元素的第二个p标签和第二个li标签\n12345678910111213141516&lt;style&gt;    ul p:nth-of-type(2) &#123;    \tbackground: red;    &#125;    ul li:nth-of-type(2) &#123;    \tbackground: red;    &#125;&lt;style&gt;&lt;body&gt;    &lt;ul&gt;        &lt;p&gt;我是p1&lt;p&gt;        &lt;p&gt;我是p2&lt;p&gt;&lt;!--红色--&gt;        &lt;li&gt;我是li1&lt;li&gt;        &lt;li&gt;我是li2&lt;li&gt;&lt;!--红色--&gt;    &lt;ul&gt;&lt;body&gt;\n4 :nth-last-of-type(){ }\n选择属于其父元素的倒数 第几个标签元素\n\n","tags":["css","前端入门"],"path":"2016/03/08/webNotes/primary/CSS/pseudo/","external_link":""},{"title":"基本的表单标签","date":"2016-02-08T11:24:45.000Z","content":"1. form双标签\n语义：定义表单\n\n代码⌨️\n\n12345&lt;form action=form_action.asp method=get&gt;  &lt;p&gt;First name: &lt;input type=text name=fname &gt;&lt;p&gt;  &lt;p&gt;Last name: &lt;input type=text name=lname &gt;&lt;p&gt;  &lt;input type=submit value=Submit &gt;&lt;form&gt;\n1.1 属性1. action\n作用：表单需要提交的地址,向何处发送表单数据\n\n\n代码⌨️\n\n1&lt;form action=URL&gt;\nURL为表单提交的地址,可能的值有：\n\n绝对 URL - 指向其他站点（比如 src=”www.example.comexample.htm&quot;）\n相对 URL - 指向站点内的文件（比如 src=”example.htm”）\n\n2. method\n作用：表单提交的方式\n\n\n代码⌨️\n\n12345&lt;form action=example.htm method=get&gt;  &lt;p&gt;First name: &lt;input type=text name=fname &gt;&lt;p&gt;  &lt;p&gt;Last name: &lt;input type=text name=lname &gt;&lt;p&gt;  &lt;input type=submit value=Submit &gt;&lt;form&gt;\n可能的值有：\n\nget 也是默认值,一般用于从服务器上获取数据,安全性上不如post\npost 一般用于向服务器传送数据\n\n2. input单标签\n语意: 输入型表单控件\n\n代码⌨️\n\n1&lt;input type=submit value=Submit &gt;\n2.1 属性1. type\n作用：规定input元素的类型\n\n\n代码⌨️\n\n1&lt;input type=submit &gt;\n可能的值：\n1.text  文本输入框,默认值\n\n属性✍️\n\nplaceholder   文本框提示语\nmaxlength     文本可输入最大长度\n1&lt;input type=text placeholder=请输入 maxlength=20 &gt;\n2.password    密文输入框\n也是一个文本输入框,与它的区别是密文输入框内输入的内容是不可见的,会被显示为一个个小黑点.\n\n属性✍️\n\nplaceholder   文本框提示语\nmaxlength     文本可输入最大长度\n3.radio   单选框\n相同类型的单选框，name 属性需要相同\n\n属性✍️\n\nname   设置radio的名称\nvalue 属性值\ndisabled 是否禁用 设置了这个属性之后单选框为禁用状态\nchecked    单选框的默认选项    checked=”checked”\n1234567891011121314&lt;input type=radio name=sex value=man&gt;男&lt;input type=radio name=sex value=girl&gt;女&lt;!--默认为男--&gt;&lt;input type=radio name=sex checked=checked&gt;男&lt;input type=radio name=sex&gt;女&lt;!--直接写checked也是和上面等效的--&gt;&lt;input type=radio name=sex checked&gt;男&lt;input type=radio name=sex&gt;女&lt;!--禁用状态--&gt;&lt;input type=radio name=sex disabled&gt;男&lt;input type=radio name=sex&gt;女\n4.checkbox   复选框\n\n属性✍️\n\nname   设置checkbox的名称\nvalue 属性值\ndisabled 是否禁用 设置了这个属性之后多选框为禁用状态\nchecked    复选框的默认选项    checked=”checked”\n1234&lt;input type=checkbox name=hobby value=eat checked&gt;吃饭&lt;input type=checkbox name=hobby value=sleep&gt;睡觉&lt;input type=checkbox name=hobby value=swim&gt;洗澡&lt;input type=checkbox name=hobby value=programme&gt;编程\n5.hidden   隐藏\n这种类型的输入元素实际上是隐藏的。\n这个不可见的表单元素的 value 属性保存了一个要提交给 Web 服务器的任意字符串。\n如果想要提交并非用户直接输入的数据的话，就是用这种类型的元素。\n\n属性✍️\n\nname  设置或返回隐藏域的名称\nvalue  设置或返回隐藏域的 value 属性的值\n1&lt;input type=hidden name=height value=100&gt;\n6.button   表单的普通按钮\n\n属性✍️\n\nvalue 按钮上显示的字 \ndisabled  是否禁用按钮\n1&lt;input type=button value=点击&gt;\n7.submit     表单的提交按钮\n\n属性✍️\n\nvalue 按钮上显示的字 \nname  设置或返回submit的名称\ndisabled  是否禁用按钮\n\n与button的区别\n\n\n&lt;input type=&quot;button&quot; &gt; 这就是一个按钮,如果你不写javascript 的话,按下去什么也不会发生\n&lt;input type=&quot;submit&quot; &gt; 这样的按钮用户点击之后会自动提交 form,除非你写了javascript 阻止它\n&lt;button&gt;&lt;button&gt;这个按钮放在 form 中也会点击自动提交,比前两个的优点是按钮的内容不光可以有文字,还可以有图片等多媒体内容.（当然，前两个用图片背景也可以做到）.它的缺点是不同的浏览器得到的 value 值不同;可能还有其他的浏览器兼容问题\n\n8.reset     重置按钮\n\n属性✍️\n\nvalue 按钮上显示的字,默认值为“重置“\nname  设置或返回重置按钮的名称\ndisabled  是否禁用按钮\n2. name\n作用：定义 input 元素的名称   (键值对：名称 = 数值 ，KEY = VALUE)\n\n\n代码⌨️\n\n1&lt;input name=firstName &gt;\n3. value\n作用： input输入内容的值\n\n\n代码⌨️\n\n1&lt;input type=submit value=Submit &gt;\n3. select下拉菜单\n双标签\n内部需要使用option 来作为菜单的列表项\nname设置给select , option 设置 value\n可以通过设置selected 属性来设置默认首选项\n1234&lt;select name=wd&gt;\t&lt;option value=选项1&gt;选项1&lt;option&gt;   \t&lt;option value=选项1&gt;选项1&lt;option&gt;&lt;select&gt;\n4. textarea文本输入域\n单标签\n\nCSS属性\n\nresize   设置文本框是否可拉伸,设置为 “none” 则不可以\n123textarea &#123;    resize: none;&#125;\n\n属性✍️\n\nname 设置并返回textarea的名称\nvalue 设置或返回在 textarea 中的文本\nplaceholder   文本框提示语\nmaxlength     文本可输入最大长度\ncols  文本框的宽度\nrows 文本框的高度\ndisabled  是否被禁用\n1&lt;textarea cols=3 rows=10 maxlength=20 placeholder=请输入&gt;&lt;textarea&gt;\n","tags":["Html","前端入门"],"path":"2016/02/08/webNotes/primary/HTML/form/","external_link":""},{"title":"盒模型","date":"2016-02-08T11:24:45.000Z","content":"盒模型的原理","tags":["Html","前端入门"],"path":"2016/02/08/webNotes/primary/HTML/box/","external_link":""},{"title":"微信小程序自定义组件","date":"2017-11-13T13:27:00.000Z","content":"前言微信小程序自1月19号发布后,可谓是有人欢喜有人忧啊.曾经对它一度抱有各种期待的前端工作者们在张总的一句句:”不行”,”不能”中小失所望.但它作为一种轻型应用工具,给我们开发者带来的便利也是无可厚非的.而自定义组件这个大功能呢也是从小程序基础库版本 1.6.3 开始支持的，低版本需做兼容处理,在搜了网上一堆微信小程序自定义组件的说明后,我好像发现都没有太好的介绍到它,所以今天在这里博主也是想给大家仔细的介绍介绍微信小程序的这个自定义功能,有说的不好的地方望小伙们指正,谢谢!(╹▽╹)\n使用自定义组件应用场景:当我们在设计我们项目的时候会发现在不同的页面中,有时候会用到相同的功能模块,此时我们就可以将这些相同的部分提取出来并且单独设为一个”页面”,然后在要应用到它的地方引用就可以了,以上就是我对自定义组件的个人理解,具体做法请阅读以下内容.\n1.创建自定义组件在上面我介绍了,自定义组件其实就像是一个页面,所以我们在编写它的时候也应该像设计页面一样,具备json  wxml  wxss  js这四个文件.\n在这里博主就以编写案例的形式向大家介绍自定义组件.\n一. 前期准备1.首先,新建一个名为wxcomponent的项目,2.在pages文件夹下创建一个components文件夹用来盛放我们所有的自定义组件.3.在components文件夹下创建一个cpt的文件夹用来盛放cpt这个自定义组件,并分别创建好对应的配置文件,如下图:\n二. 自定义组件声明要在cpt.json中进行自定义组件声明,也就是告诉开发者这是一个组件:123&#123;  component: true&#125;\n三. 设计组件结构在 wxml 文件中编写组件模版，在 wxss 文件中加入组件样式:cpt.wxml文件123456&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class=inner&gt;  &#123;&#123;innerText&#125;&#125;  &lt;button bindtap=customMethod&gt;点击&lt;button&gt;  &lt;slot&gt;&lt;slot&gt;&lt;view&gt;\ncpt.wxss文件1234* 这里的样式只应用于这个自定义组件 *.inner &#123;  color: red;&#125;\n这里的`暂时可以不用管它.\n并且自定义组件在设计结构的时候是不应该使用给便签加上id或者使用属性选择器和标签名选择器的.这是因为组件就是被我们那里重用的,而页面中只能允许有一个id.\n四: 注册组件\n在自定义组件的js文件中,需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法,如在cpt.js中:12345678910111213141516171819Component(&#123;  properties: &#123;     这里定义了innerText属性，属性值可以在组件使用时指定    innerText: &#123;      type: String,      value: default value,    &#125;  &#125;,  data: &#123;     这里是一些组件内部数据    someData: 1  &#125;,  methods: &#123;     这里是一个自定义方法    customMethod: function () &#123;      console.log(customMethod)    &#125;  &#125;&#125;)\n五: 使用自定义组件这里我为了简便一点,就直接用自带的logs页面来进行自定义组件的调用吧.首先,你应该在你要用组件的那个页面中引用声明.也就是在.json文件.如在logs.json中:123456&#123;  navigationBarTitleText: 查看启动日志,  usingComponents: &#123;    component-tag-name: ..componentscptcpt  &#125;&#125;\n接下来我们就可以在页面中像使用其他组件一样的使用自定义组件了.比如我在logs.wxml中使用:12345&lt;!--logs.wxml--&gt;&lt;view class=container log-list&gt;  &lt;!-- 以下是对一个自定义组件的引用 --&gt;  &lt;component-tag-name inner-text=Some text&gt;&lt;component-tag-name&gt;&lt;view&gt;\n跳转到logs页面如下图的效果:\n六: 使用slot在上面的例子中,在cpt.wxml中写入了标签,在引用cpt这个组件时我们要是不在组件的标签中写入其他的内容,是不会显示标签的\n也就是说如果我们把上面logs.wxml改动一下:1234567&lt;!--logs.wxml--&gt;&lt;view class=container log-list&gt;  &lt;!-- 以下是对一个自定义组件的引用 --&gt;  &lt;component-tag-name inner-text=Some text&gt;    &lt;view&gt;这里是插入到组件slot中的内容&lt;view&gt;  &lt;component-tag-name&gt;&lt;view&gt;\n此时查看logs页面:\n并且&lt;slot&gt;&lt;slot&gt;的位置在哪里也是由你在设计cpt组件时决定的上面的例子中我是将slot放在button之下:123456&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class=inner&gt;  &#123;&#123;innerText&#125;&#125;  &lt;button bindtap=customMethod&gt;点击&lt;button&gt;  &lt;slot&gt;&lt;slot&gt;&lt;view&gt;\n你也可以将它放在其他位置来达到不同的效果.\n七: 使用多个slot正常情况下,一个组件中只有一个slot,但有时候我们的自定义组件可能不止使用一个slot,别怕,我们的微信小程序也是可以允许你这样的.需要使用多slot时，可以在组件js中声明启用1.在cpt.json(你自定义组件的json文件)中声明1234567Component(&#123;  options: &#123;    multipleSlots: true  在组件定义时的选项中启用多slot支持  &#125;,  properties: &#123; * ... * &#125;,  methods: &#123; * ... * &#125;&#125;)\n2.此时，可以在这个组件的wxml中使用多个slot,以不同的 name 来区分:1234567&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class=inner&gt;  &lt;slot name=header&gt;&lt;slot&gt;    &lt;-- 一定要记得使用name属性 --&gt;  &#123;&#123;innerText&#125;&#125;  &lt;button bindtap=customMethod&gt;点击&lt;button&gt;  &lt;slot name=footer&gt;&lt;slot&gt;&lt;view&gt;\n3.使用时，用 slot 属性来将节点插入到不同的slot上。12345678&lt;!--logs.wxml--&gt;&lt;view class=container log-list&gt;  &lt;!-- 以下是对一个自定义组件的引用 --&gt;  &lt;component-tag-name inner-text=Some text&gt;    &lt;view slot=header&gt;头部的内容&lt;view&gt;    &lt;view slot=footer&gt;底部的内容&lt;view&gt;  &lt;component-tag-name&gt;&lt;view&gt;\n后语微信小程序中自定义组件的用法还有很多,比如组件生命周期,事件等等,更多的内容可以参考官方文档.\n","tags":["前端进阶","微信小程序"],"path":"2017/11/13/webNotes/advanced/Weixin/wxComponent/","external_link":""},{"title":"JQuery of Ajax","date":"2016-03-08T11:24:45.000Z","content":"第一章:load( )方法\n.load(url, [data], [callback])\n[ ]内的参数表示可选\nload一般用来读取静态html页面(动态也可以)。如果想方便传递数据到服务器，更多的使用get或post。\n\nurl:待装入 HTML 网页网址。\ndata:发送至服务器的 keyvalue 数据。在jQuery 1.3之后也可以接受一个字符串了。可选\ncallback:载入成功时回调函数。可选\n注意：默认使用 GET 方式 - 传递附加data参数时自动转换为 POST 方式\n12345678910111213141516171819202122例1:将test1.html中的div和p标签都加载到test2.html中的div标签里\t&lt;script&gt;        $(function()&#123;            $(&apos;#btn&apos;).on(&apos;click&apos;,function () &#123;              $(&apos;#box&apos;).load(&apos;test1.html p,div&apos;,function () &#123;\t若第一个参数后不传标签名,则加载的是整个页面                    console.log(&apos;加载完成&apos;)                &#125;)            &#125;)        &#125;)    &lt;script&gt;        &lt;button id=&quot;btn&quot;&gt;按钮&lt;button&gt;    &lt;div id=&quot;box&quot;&gt;&lt;div&gt;        =&gt; \t&lt;div id=&quot;box&quot;&gt;    \t\t&lt;div class=&quot;div&quot;&gt;我是div1&lt;div&gt;\t\t\t&lt;div class=&quot;div&quot;&gt;我是div2&lt;div&gt;\t\t\t&lt;div class=&quot;div&quot;&gt;我是div3&lt;div&gt;\t\t\t&lt;div class=&quot;div&quot;&gt;我是div4&lt;div&gt;    \t&lt;div&gt;\n第二章:get方法和post方法","tags":["前端进阶","JQuery"],"path":"2016/03/08/webNotes/primary/JQuery/JQuery of Ajax/","external_link":""},{"title":"微信小程序自定义组件","date":"2017-11-14T03:41:00.000Z","content":"前言在上一章节中我是给大家介绍了一下微信小程序的自定义组件,这一章我要说说小程序的另一个强大功能–自定义事件\n什么是自定义事件呢,你可以简单的理解为:在触发子组件的一些事件的时候,同时也能触发父组件对应的事件并对父组件中的某些数据进行修改的事件就是自定义事件.\n有翻阅学习过小程序官方给出的自定义组件教程的小伙们一定会有和我一样想爆粗口的冲动…\n因为上面说的真的有点乱…\n不过没事,今天在这里博主会详细的讲解讲解微信小程序的自定义事件.\n案例结构首先,我还是会以案例的形式向大家讲解(这样也能方便大家更好的理解)简单介绍一下案例项目的内容(以上一章自定义组件的案例为基础)项目名称:component自定义子组件cpt父组件:logs\n\n在子组件cpt中有一个按钮,按钮上显示的是当前这按钮组件存储的数值counter.\n父组件logs引用三个cpt子组件,在父组件有它自己的第一个变量total.\n每点击一次不同的按钮都让按钮上的数值不同大小的增加,\n同时total变量记录的是三个按钮的数值总和,如图:\n\n编写子组件cpt.wxml1234&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class=inner&gt;  &lt;button bindtap=_incrementCounter&gt;&#123;&#123;counter&#125;&#125;&lt;button&gt;&lt;view&gt;\n子组件cpt中有一个按钮,按钮添加点击事件_incrementCounter,同时按钮内容显示的是其数值counter\ncpt.js123456789101112131415161718192021222324Component(&#123;  properties: &#123;     这里定义了num属性，属性值可以在组件使用时指定    num: &#123;           num定义的就是点击每个按钮分别增加的数值,可以在调用组件的时候进行更改      type: Number,      value: 1    &#125;  &#125;,  data: &#123;     这里是一些组件内部数据    counter: 0       counter定义的是每个按钮上的数值  &#125;,  methods: &#123;     这里是一个自定义方法,每次点击按钮增加对应的数值    _incrementCounter (e) &#123;      let num = this.data.num      this.setData(&#123;        counter: this.data.counter + num      &#125;)      微信小程序中是通过triggerEvent来给父组件传递信息的      this.triggerEvent(increment, &#123;num: num&#125;)   将num通过参数的形式传递给父组件    &#125;  &#125;&#125;)\n编写父组件子组件编写完之后,就可以在父组件logs中引用了,并且给它设定自定义事件(别忘了在父组件的.json文件中进行引用哟)logs.json123456&#123;  navigationBarTitleText: 查看启动日志,  usingComponents: &#123;    component-tag-name: ..componentscptcpt  &#125;&#125;\nlogs.wxml12345678&lt;!--logs.wxml--&gt;&lt;view class=container log-list&gt;  &lt;!-- 以下是对一个自定义组件的引用 --&gt;   三个按钮总和: &#123;&#123;total&#125;&#125;  &lt;component-tag-name bindincrement=incrementTotal num=2&gt;&lt;component-tag-name&gt;  &lt;component-tag-name bindincrement=incrementTotal num=3&gt;&lt;component-tag-name&gt;  &lt;component-tag-name bindincrement=incrementTotal num=5&gt;&lt;component-tag-name&gt; &lt;view&gt;\n这里有一个坑要重点提一下,在官方给出的在父组件中调用子组件时,给其添加绑定事件使用的是bind:increment的形式,但是亲试之后,还是得用bindincrement的这种写法才有用.这里的increment就是你在定义子组件时通过triggerEvent传递过来的事件名.\nlogs.js12345678910111213Page(&#123;  data: &#123;    logs: [],    total: 0,   父组件中的数据total用以记录三个按钮总和  &#125;,  incrementTotal (e) &#123;     定义父组件的    console.log(e.detail)     通过e.detail获取点击的那个对象    var num = e.detail.num    this.setData(&#123;      total: this.data.total + e.detail.num    &#125;)  &#125;,&#125;)\n分别点击三个按钮时可以看到数值上都有变化的,并且控制台输出的e.detail中也有对应的num属性.\n\n后语通过一个简单的小案例,小程序中的自定义事件在这里就介绍完了,学过vue.js的小伙会发现怎么感觉又学了一遍vue.js  o(╥﹏╥)o  其实个人认为官方文档写的还是不错的,想学习小程序的同学也可以按着官方文档上的说明进行学习.\n","tags":["前端进阶","微信小程序"],"path":"2017/11/14/webNotes/advanced/Weixin/wxEvent/","external_link":""},{"title":"JQuery动画","date":"2016-03-08T11:24:45.000Z","content":"第一章:动画基础显示和隐藏1. hide( )js中隐藏元素ele.style.display = &#39;none&#39; jquery中从显示到隐藏元素调用hide方法 $ele.hide()\nhide( ) 方法中还可以传递参数,.传参之后,hide()就会成为一个动画方法。.hide()方法将会匹配元素的宽度，高度，以及不透明度，同时进行动画操作.\n12345例1:实现所有的li元素在隐藏的时候有一个渐变的效果,这是一个动画设置的快捷方式，fast 和 slow 分别代表200和600毫秒的延时，就是元素会执行200600毫秒的动画后再隐藏也可以直接传入毫秒数,\t.hide(3000)$(li).hide(fastslow);\n2. show( )\n让元素从隐藏到显示,用法和hide( )一样.\n\n12让元素执行3秒的隐藏动画，然后执行3秒的显示动画。$(&apos;elem&apos;).hide(3000).show(3000)\n3. toggle( )用于切换显示或者隐藏匹配的元素.\n1.基本操作:    \n​    处理元素显示或者隐藏,没有动画效果\n​    若匹配元素原先是显示则会隐藏,\n​    原先是隐藏,则会显示.\n2.提供参数:\n​    .toggle( [duration],[complete])\n​    参数1:周期(多长时间完成动画效果)\n​    参数2:回调函数(动画执行完之后执行的函数)\n​    同样是改变元素的高,宽,不透明度的一系列动画效果.\n12345678910111213鼠标移入第一个按钮,将class名为left的元素在3秒内隐藏,隐藏完之后打印出a;$(button:first).on(mouseover,function()&#123;       $(.left).toggle(3000,function () &#123;          console.log(a);       &#125;) &#125;);隐藏之后,再3秒内又显示$(button:first).on(mouseover,function()&#123;        $(.left).toggle(3000,function () &#123;            $(.left).toggle(3000);        &#125;) &#125;);\n​    \n3.直接定位:    \n12toggle(hide);\t\t直接定位隐藏toggle(show);\t\t直接定位显示\n第二章: 上卷下拉效果1.slideDown( )用滑动动画显示一个匹配的元素\n.slideDown([duration],[complete])\n参数1:动画周期    \n参数2:回调函数(动画执行完之后执行的函数)\n改变元素高度的动画,有一个从上至下的滑动效果\n12345点击button   执行3秒显示   $(&quot;button:first&quot;).click(function() &#123;       $(&quot;#a1&quot;).slideDown(3000)   &#125;);\n2. slideUp( )用滑动动画隐藏一个匹配的元素\n.slideDown([duration],[complete])\n12345点击button   执行3秒隐藏   $(&quot;button:first&quot;).click(function() &#123;       $(&quot;#a1&quot;).slideUp(3000)   &#125;);\n3.slideToggle( )1.基本操作:    \n​    处理元素显示或者隐藏,没有动画效果\n​    若匹配元素原先是显示则会隐藏,\n​    原先是隐藏,则会显示.\n2.提供参数\n.slideToggle([duration],[complete])\n第三章: 淡入淡出1.fadeOut( )淡出动画,透明度越来越小,直到0;\n1.fadeOut( [duration ], [ complete ] )\n2.fadeIn( )淡入动画,透明度越来越大,直到1;\n1.fadeIn( [duration ], [ complete ] )\n3.fadeToggle( )\nfadeToggle切换fadeOut与fadeIn效果，所谓”切换”，即如果元素当前是可见的，则将其隐藏(淡出)；如果元素当前是隐藏的，则使其显示(淡入)。\n\n1.fadeToggle( [duration ] ,[ complete ] )\n4.fadeTo( )指定透明度到多少\n1.fadeTo( duration, opacity ,callback)\n123456鼠标移入div,在1s内,透明度变为0.5$(div).on(mouseover,function()&#123;  $(this).fadeTo(1000,0.5,function()&#123;    alert(完成);  &#125;)&#125;)\n第四章: animateanimate(params[, speed][,easing][, callback])\n\n参数1：一个包含样式的属性和值的映射对。可以有多个映射。 必须\n参数2：可选。速度\n参数3：动画算子（字符串。jquery默认只有linear和swing）。更复杂的需要第三方支持。\n务必要先导入jquery再导入动画算子插件。\n参数4：回调函数。可选。表示动画执行完毕之后然后再执行的函数。\n\n12345678910例1:让div在1s内移动到left为300的位置,宽高都变为200px\t\t$(div).animate(&#123;              left:300,\t\tleft:300px,              width:200,              height:200,              opacity:0.5          &#125;,1000,linear,function () &#123;              console.log(wancheng);          &#125;)\n\n支持’+=’写法\n\n12345例2:让div在1s内width增加100px\t\t$(div).animate(&#123;          width:+=100\t\t最终值是在当前值的基础上加上100px\t\t&#125;)\n\n支持 toggle,hide,show\n\n12345678910例3:支持 toggle,hide,show$(div).animate(&#123;              left:toggle,              width:toggle,              height:toggle,              opacity:0.5          &#125;,1000,function () &#123;              console.log(完成)          &#125;)\n\n支持链式(动画序列)\n\n12345678910111213141516171819例4:支持链式:\t\t\t $(div).animate(&#123;                  left:300              &#125;,1000,function () &#123;                  console.log(第一步完成)              &#125;).animate(&#123;                  top:+=200              &#125;,1000,function () &#123;                  console.log(第二步完成);              &#125;).animate(&#123;                  left:-=300              &#125;,1000,function () &#123;                  console.log(第三步完成);              &#125;).animate(&#123;                  top:-=200              &#125;,1000,function () &#123;                  console.log(第四步完成);              &#125;)\n4.支持重复执行\n123456例5:$(function step()&#123;  $(div).animate(&#123;    left:+=10  &#125;,1000,step)\t在动画结束之后,回调step函数&#125;)\n5.停止动画\n12345stop有两个可选参数：                         参数1：truefalse true表示立即清除所有动画队列中的所有动画，并结束当前动画。已经执行到了什么                                 地方就停在什么地方。 默认是false，表示停止当前动画，并开始动画队列中的下一个。                         参数2：truefalse:  表示结束动画的时候，是否直接到达当前动画的末尾状态。true表示直接去当前动画的末尾状态，f                                 false,表示维持当前状态\n1(&apos;div&apos;).stop()\n6.检测动画执行状态\n12345if($box.is(&quot;:animated&quot;))&#123;                   alert(&quot;动画正在执行&quot;);               &#125;else&#123;                   alert(&quot;动画没有在执行&quot;);               &#125;\n第五章: JQuery插件注:引用任何JQuery插件都得先引入JQuery\n","tags":["前端进阶","JQuery"],"path":"2016/03/08/webNotes/primary/JQuery/JQuery of animation/","external_link":""},{"title":"Date对象基础知识","date":"2016-02-08T11:24:45.000Z","content":"日期对象和万年历1.创建Date()对象（日期和时间的对象）JavaScript中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。\n为此， Date类型使用自 UTC 1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。\n在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1月 1 日之前或之后的 285 616 年。\n\n使用new 和 Date()构造方法创建一个日期对象：\n\nvar box = new Date();  创建一个时间和日期对象；\nalert(box);  不同浏览器显示不同；\n支持格式:\n1234567891011&lt;body&gt;    &lt;script type=textjavascript&gt;      \tvar d = new Date(23231424214);\t\t\t\t\t支持格式1:毫秒        var d1 = new Date(May 31, 2016 09:00:00);    \t支持格式2：英文月 日,年 时:分:秒 例如：May 23, 2016 09:00:00        console.log(d1);    Tue May 31 2016 09:00:00 GMT+0800 (中国标准时间)        var d2 = new Date(2016-11-12);\t\t\t\t支持格式3：年-月-日 例如：2016-11-11        console.log(d2);    Sat Nov 12 2016 08:00:00 GMT+0800 (中国标准时间)        var d3 = new Date(20161112);\t\t\t\t支持格式4：年月日 例如：20161111        console.log(d3);    Sat Nov 12 2016 08:00:00 GMT+0800 (中国标准时间)    &lt;script&gt;&lt;body&gt;\n在调用Date构造方法里面是可以传参数的，不传参的情况下，新建的对象默认获取当前的时间和日期；\n注:    \nDate()的静态方法\n\nDate.parse() 和Date.UTC() 的使用方法:12345671.var box = new Date(Date.parse(1999,09,15));  alert(box);2.var box = new Date(1999,09,15);  alert(Date.parse(box));  \t\t ()里可以有参数\n\nDate()的其他方法:\n\nDate.toString();              ()里没有参数;\ntoString()方法一般返回带有时区信息的日期和时间。1234567如:  var box =new Date();     alert(box.toString());&gt; Date.toLocaleString();toLocaleString()\n\n返回符合本地习惯的日期和时间格式;\n\nvalueOf()\n\nvalueOf()方法不返回字符串，而是返回的代表这个时间的毫秒值。\n一般用用来比较两个日期的大小，就知道谁在前谁在后了。\n\ngetTime()\n\n和valueOf() 一样\n\n例:123456789var box = new Date(1996,09,15,14,13,12);  alert(box);                     Tue Oct 15 1996 14:13:12 GMT+0800 (中国标准时间)    alert(box.toString());          Tue Oct 15 1996 14:13:12 GMT+0800 (中国标准时间)    alert(box.toLocaleString());    19961015 下午2:13:12    alert(box.valueOf());           845359992000\n\nPS:不同浏览器显示的格式可能不同    \n2.Date()的“静态”方法情况一:    \n将一个20080908转换为标准的时间模式:\n方法一:\n直接利用Date(),系统会自动调用Date.parse()方法;12new box = new Date(20080908);正确写法 new box = new Date(20080908);错误写法\n方法二:    \n调用Date.parse()方法来实现;12345678alert(Date.parse(20080908));正确写法 alert(Date.parse(20080908));错误写法 ```    **情况二:将一个毫秒数转换为标准的时间模式:**```javascriptnew box = new Date(1175875200000);正确写法 new box = new Date(1175875200000);错误写法\n1.Date.parse()将’20080908’和毫秒数等格式转换为标准格式;\n正确格式:12345alert(Date.parse(2008,04));alert(Date.parse(2008,04));alert(Date.parse(200804));\n错误格式:123alert(Date.parse(200804));alert(Date.parse(11782882933));\n例1：12345var box = new Date();alert(Date.parse(472007);          返回的是一个毫秒数；\n2.Date.UTC()UTC  世界协调时间;按照它的区域基准来计算;\n北京东八区的时间比它早8个小时;\nDate.UTC()同样也返回毫秒数，\n但他与Date.parse()在构造时使用不同的信息；\n0表示1月,1表示2月,\n月[0~11]                 \n日[1~31]                 \n小时[0~23]\n(注:Date.UTC()必须传入年份和月份)\n\n写法一:\n\n放在Date()中返回的是世界协调时间;\n(Date()会自动再给获取到的毫秒数(此毫秒数为世界协调时间的毫秒数)转为标准时间)123new box = new Date(Date.UTC(2011,11))alert(box);\n\n写法二:\n\n直接当方法用返回的是毫秒数;1alert(Date.UTC(2011,11));     和Date.parse()一样，若是传参错误，返回NaN等错误信息，不同浏览器不同；\n3.日期组件方法1.getTime()​    获取表示这个时间的那个毫秒值\n12var d = new Date();d.setTime(8998778999)\n123456789定义一个函数计算你活了多少天function howD(birthday)&#123;            var nowTime = new Date();            var d = nowTime.getTime()-birthday.getTime();            return Math.floor(d(24*3600*1000));        &#125;        var birthday = prompt(请输入您的生日,生日格式为 年月日);        birthday = new Date(birthday);        document.write(howD(birthday));\n2.getFullYear()​    获取年份\n1d.getFullYear();\n​    setFullYear();\n如设置一个 获取是一年中的第几天    的函数\n1234567891011121314151617181920console.long(getDatesOfYear(new Date(2017,3,10)));\t\t注:要用new Date() 包着方法一:function getDatesOfYear(year,month,date)&#123;\t\t利用年月日来获取天数  var temp = 0;  for(var i = 1; i &lt; month ; i++)&#123;\t\t\t\t    temp+=getDatesOfMonth(year,month);\t\t\t调用了4.getDate()例题中的函数,用以获取这个月有几天  &#125;  temp += date;\t\t\t\t\t\t\t\t\t  return temp;&#125;方法二:function getDatesOfYear(date)&#123;\t\t\t\t\t利用组件来获取天数  var temp = 0;  for(var i = 1; i &lt; date.getMonth()+1 ; i++)&#123;    temp+=getDatesOfMonth(date.getFullYear(),i);  &#125;  temp += date.getDate();  return temp;&#125;=&gt;69\n3.getMonth()​    获取月份\n1d.getMonth();\t\t\t0 ~ 11 获取月份\n​    setMonth(-1);             1\n4.getDate()​    获取是一个月中的第几天\n1d.getDate();\n​    setDate();\n如设置一个  输入年月,获取这个月有几天  的函数\n123456console.log(2017,3)function getDatesOfMonth(year,month)&#123;  \t\t\t 年份,月份(1月即1)          var d = new Date(year,month,0);    \t 这里面的month是实际月份+1,0表示上个月最后一天          return d.getDate();      &#125;      =&gt; 31\n5.getDay()​    获取是一周中的第几天,只能获取不能设置    (0~6  0代表星期天)\n6.getHourse()​    获取小时\n1d.getHourse();\n​    setHourse();\n7.getMinutes()​    获取分钟\n1d.getMinutes();\n​    setMinutes();\n8.getSeconds()​    获取秒钟\n1d.getSeconds();\n​    setSeconds();\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/basicOfDate/","external_link":""},{"title":"利用JS制作万年历","date":"2016-02-08T11:24:45.000Z","content":"利用JS制作万年历我们知道,万年历在人们的生活中是在平常不过的一种东西了,那么怎样用JS来实现在网页中展示一个与众不同万年历呢\n1.HTML布局:\n12345678910111213141516&lt;div id=calendar&gt;    &lt;div id=month_year&gt;        &lt;select id=year&gt;&lt;select&gt;年        &lt;select id=month&gt;&lt;select&gt;月    &lt;div&gt;    &lt;ul id=title&gt;        &lt;li&gt;星期日&lt;li&gt;        &lt;li&gt;星期一&lt;li&gt;        &lt;li&gt;星期二&lt;li&gt;        &lt;li&gt;星期三&lt;li&gt;        &lt;li&gt;星期四&lt;li&gt;        &lt;li&gt;星期五&lt;li&gt;        &lt;li&gt;星期六&lt;li&gt;    &lt;ul&gt;    &lt;ul id=datesUl&gt;&lt;ul&gt;&lt;div&gt;\n1.首先在布局上,可以先用一个id为calender(日历)的div将你的万年历包住,以便我们对万年历的位置进行设置;\n2.在这个大的div中有三部分: 1. month_year 用以设置年月; 2.title 用以显示星期;\n 3.detesUl 用以显示具体的日期;\nCSS样式:\n1234567891011121314151617181920212223242526272829303132333435*&#123;            padding: 0;            margin: 0;            list-style: none;        &#125;        #calendar&#123;            width: 700px;            background-color: lightgray;            margin: 20px auto;        &#125;        #calendar::after&#123;            content: ;            display: block;            clear: both;        &#125;        #month_year&#123;            width: 700px;            height: 50px;            line-height: 50px;            text-align: center;        &#125;        ul &gt; li&#123;            float: left;            width: 100px;            height: 50px;            text-align: center;            line-height: 50px;        &#125;        #datesUl &gt; li:empty&#123;            opacity: 0;        &#125;        #datesUl &gt; li:hover&#123;            background-color: lightblue;        &#125;\nJS代码:\n JS代码分析:\n\n做一些初始化的处理,给俩个显示年月的选项卡中添加内容便于用户查找\n构造一些我们要用到的函数: 如输入年月计算出这个月有几天,创建添加option及li的函数\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;script&gt;    var yearSelect = document.getElementById(year);    var monthSelect = document.getElementById(month);    var datesUl = document.getElementById(datesUl);    初始化    function init()&#123;        for(var year=1990;year&lt;3000;year++)&#123;        初始化俩个选项卡            createOption(year,year,yearSelect);        &#125;        for(var month=1;month&lt;13;month++)&#123;            createOption(month,month,monthSelect);        &#125;        var now = new Date();                       获取当前的日期        showSelect(now.getFullYear(),now.getMonth()+1);   引用显示选项卡的函数        showDates();                                    调用显示日期的函数        yearSelect.onchange=function()&#123;                 当选项卡改变时            showDates();        &#125;;        monthSelect.onchange=function()&#123;            showDates();        &#125;    &#125;\tinit();                        调用初始化函数         创建option的函数    function createOption(text,value,parent)&#123;        var option = document.createElement(option);        option.innerHTML = text;        option.value = value;        parent.appendChild(option);    &#125;    获取当前的日期并显示在选项卡中    function showSelect(year,month)&#123;        yearSelect.value = year;        monthSelect.value = month;    &#125;    获取选择的年月的第一天是星期几    function getDays(year,month)&#123;        var d = new Date(year,month,1);        return d.getDay();    &#125;    根当前的select中的年和月来显示日期    function showDates()&#123;        datesUl.innerHTML= ;        var year = yearSelect.value;        var month = monthSelect.value;        创建空的li        for(var i=0;i&lt;getDays(year,month);i++)&#123;            createLi(,datesUl);        &#125;        创建有日期的li        for(var j=1;j&lt;=getDatesOfMonth(year,month);j++)&#123;            createLi(j,datesUl);        &#125;    &#125;    创建li并添加至对应的容器    function createLi(text,parent)&#123;        var li = document.createElement(li);        li.innerHTML = text;        parent.appendChild(li);    &#125;    创建一个输入年月计算出这个月有几天的函数    function getDatesOfMonth(year,month)&#123;        var d = new Date(year,month,0);        return d.getDate();    &#125;&lt;script&gt;","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/calendarOfJs/","external_link":""},{"title":"this","date":"2016-02-08T11:24:45.000Z","content":"1.this原理2.this222","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/this/","external_link":""},{"title":"面向对象入门","date":"2016-02-08T11:24:45.000Z","content":"对于很多初学JavaScript的小白来说,刚接触面向对象肯定是一脸懵逼的,博主也是一样.但经过一段时间的工作,还是对于面向对象有了一定的了解,下面就是这些天学习面向对象的一些心得与体会,希望对大家有所帮助.\n什么是面向对象?相信对于面向对象的一些概念大家在网上看的也都不少,什么学会了面向对象呀就能找对象之类的.好吧,言归正传,在JavaScript中,可以说所有东西都是对象,对象就是包含一组变量和函数的集合.函数是一个对象,数组是一个对象.而对于面向对象来说,我们把构成问题事务分解成各个对象,那么建立这些对象是为了描叙某个事物在整个解决问题的步骤中的行为,而不是为了完成一个步骤。 \n第一:如何创建对象\n对象的每个属性或者方法都有一个名字,而每个名字都映射到一个值如下面的对象:  123456例1:var person = &#123;          name: &quot;王先生&quot;,          age:22,          sex:&quot;男&quot;&#125;\n对于person(人)这个对象来说,每个人肯定是有名字的,有年龄,也有性别,也就是说person这个对象它有3个属性.那么像这种  name:”王先生” ,  属性名:属性值 , 我们就称之为键值对,一个键值对就是一个对象的属性.那么有人就会问了,向刚刚上面的例子中,不管是name还是age都只是一个简单的数据类型,像”王先生”是字符串,22是数字,这个对象中能不能有一些更牛的属性呢,比如函数?答案是可以的.对象中的属性不仅仅可以是一些简单数据类型,也可以是函数,也可以是对象.这里我要科普一下,哪些是简单数据类型呢?简单数据类型在JS中就是5种,分别是:    1.数字类型  number;    2.布尔类型  boolean;    3.字符串类型  string;    4.undefined    5.null除了以上5种数据类型,其他的所有元素的数据类型都是object类型所以我们想给对象person中添加函数应该怎么做?这里你可以理解为函数也只是我们给对象中添加的一个属性而已,所以用法也和添加简单数据类型一样.\n如,我要给person添加一个eat函数:  123456789例2:var person = &#123;          name: &quot;王先生&quot;,          age:22,          sex:&quot;男&quot;,          eat:function()&#123;                  alert(&quot;王先生爱吃&quot;);          &#125;&#125;\n这里要提醒的一点是,对象中各个属性直接是用逗号来隔开的,而不是分号.\n第二:如何访问对象中的属性\n如果我们现在想访问例2中的name属性,可以这样写:1234对象名.属性名console.log(person.name);另外也可以直接调用对象中的方法(函数):person.eat();        既然是调用方法(函数) 则一定还要添加()来表示方法的调用\n也可以这样写:12对象名[属性名]console.log(person[&quot;name&quot;])\n俩种方式都可以使我们访问到对象中的属性,但也有一定的区别:  对象名.属性名只适合知道了属性的名字时使用,如果一个属性名是个变量则会出现语法错误;  对象名[属性名]就没有限制了,不过当变量名是字符串常量,我们就要用” “引号引起来,是变量的话则可以直接使用1234person,age = 22;var a = &apos;age&apos;;console.log(person[a])=&gt;22\n第三:如何修改对象中的属性\n修改对象中的属性其实很简单,只需要获取到你想修改的对象的属性,然后给它重新赋值就可以了;比如修改例2中的sex属性和eat属性:12345678910person.sex = &quot;女&quot;person.eat=function()&#123;        alert(&quot;王先生不爱吃&quot;);&#125;```  **第四:如何给对象添加属性**上面我们了解到了怎么访问对象属性,修改对象属性,那么现在想给对象中添加属性应该怎么做呢?比如我现在还是想给例3中的person添加一个属性hobby和play;\n例3:var person = {          name: “王先生”,          age:22,          sex:”男”,          eat:function(){                  alert(“王先生爱吃”);          }}person.hobby=”yun”;person.favorite=function(){      alert(this.name+”favorite is”+this.hobby);}1234**第五:如何删除对象中的属性**删除对象中属性这里我们要用到一个操作符:delete;如我要删除例3中person的年龄属性:\ndelete person.age;此时我们再执行console.log(person.age)=&gt;undefined                    返回的是undefined ,说明age这个属性被删除了12345**第六:如何遍历对象**针对遍历对象,可以有俩种变量对象的方式1.通过for(...in...)来变量对象的各个属性名称\nfor(var proName in p){                var 可以省略    in前面表示的是p对象的属性名称  console.log(proName);                在此输出的只是p对象的各个属性名称}\nfor(var proName in p){  console.log(p[proName])            在此输出的是p对象的各个属性的值}12.通过for(...of...)来变量对象的各个属性的值\nfor(var pro of p){  console.log(pro);                    在此输出的是p对象的各个属性的值}123456789### 解析面向对象的几种创建方式上面我们只是简单的用             ```  var 对象名 = &#123;                      属性名:属性值,                      属性名:属性值,               &#125;\n来创建一个对象,这种方式称为字面量的创建方式,其实还有另外几种创建对象的方式.\n3.1 使用new Object( )12345var p = new Object();p.name = &quot;小王&quot;,p.eat = function()&#123;  alert(&apos;函数&apos;)&#125;\n3.2 工厂模式创建12345678910function createP(name,age,sex)&#123;  var p = new Object();  p.name = name;  p.age = age;  p.sex = sex;  return p;&#125;var p1 = createP(&quot;小王&quot;,&quot;22&quot;,&quot;男&quot;);var p2 = createP(&quot;小张&quot;,&quot;23&quot;,&quot;女&quot;);\n\ncreatePerson()函数可以多次调用，每调用一次这个函数就会返回一个对象，而且对象的类型仍然是Object类型的。虽然解决了多个相似对象的问题，但却没有解决对象类型识别的问题。\n\n3.3 构造函数创建\n为了解决对象类型识别问题，又提出了构造函数模式。\n通俗来说,就是用 new 的方式来调用函数的时候,就是构造函数.    如:    var p = new person();\n这种模式，其实在我们创建一些原生对象的时候，比如Array、Object都是调用的他们的构造函数。\n构造函数的使用:\n​    1.首先创建一个对象,这个对象的类型就是构造函数的名字    \n​        如例1中的p1就是创建的对象,这个对象的类型就是createP\n​    2.最后会把创建这个对象自动的返回,所以不需要return\n​    3.为什么使用构造函数:实际是给创建对象的一个初始化\n​    4.函数作为构造函数使用时,this指代的是创建的这个对象;函数作为正常调用时,this代指window\n\n123456789例1:function createP(name,age,sex)&#123;  this.name = name;\t\t\t\t\t\t在构造函数中,this就是指代创建这个对象  this.age = age;  this.sex = sex;&#125;var p1 = new createP(&quot;小王&quot;,&quot;22&quot;,&quot;男&quot;);\t使用new的方式来调用函数的时候,这个时候,这样的函数就叫构造函数var p2 = new createP(&quot;小张&quot;,&quot;23&quot;,&quot;女&quot;);\n构造函数与普通函数的区别上面我们在创建对象的时候用了一种通过构造函数创建的方式,那么构造函数与普通函数有什么区别呢?他们的调用方式不同:\n   构造函数:    new 函数( )\n\n            默认返回创建的那个对象\n\n            所有单词首字母大写\n\n普通函数:    函数( )\n\n            默认返回undefined\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/objectOriented/","external_link":""},{"title":"几种简单的设计模式","date":"2016-02-08T11:24:45.000Z","content":"第一章.设计模式简介作用：JavaScript设计模式的作用 - 提高代码的重用性，可读性，使代码更容易的维护和扩展。    \n一般只用于大型的项目.\n设计模式有六大原则：\n\n开闭原则。就是说模块应对扩展开放，而对修改关闭。\n里氏代换原则。如果调用的是父类的话，那么换成子类也完全可以运行。\n依赖倒转原则。把父类都替换成它的子类，程序的行为没有变化。\n接口隔离原则，每一个接口应该是一种角色，不多不少，不干不该干的事，该干的事都要干。\n单一职责原则。\n迪米特法则。 最少知识原则。\n\n第二章:常见设计模式1.聚合12345678910function A()&#123;       this.say = function()&#123;           console.log(a);       &#125;   &#125;   function B()&#123;       this.a = new A();   &#125;   var b = new B();   b.a.say();\n2.单例12345678910111.function A()&#123;        this.say = function()&#123;            console.log(a);        &#125;    &#125;    function B()&#123;        this.a = new A();    &#125;    var b = new B();    b.a.say();\n1234567891011121314151617181920212223242.    var createPerson = (function()&#123;        function Person(name) &#123;            this.name = name;        &#125;        var p;        return function (name) &#123;            if(!p)&#123;                p = new Person(name);            &#125;else &#123;                p.name = name;            &#125;            return p;        &#125;    &#125;());    var p1 = createPerson(张三);    var p2 = createPerson(李四);    console.log(p1);    console.log(p1==p2);    =&gt;李四    =&gt;true    后传入的是谁就是谁\n1234567891011function Person(name)&#123;       var p = this;       p.name = name;       Person = function()&#123;           return p;       &#125;   &#125;AQ\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   var person1 = new Person(张三);   var person2 = new Person(李四);   console.log(person1);   console.log(person2);\n3.替换构造函数法123456789复写了构造函数Personfunction Person()&#123;  var p = this;  p.name = name;  Person = function()&#123;    return p;  &#125;&#125;\n4.适配器模式\n用法:在不更改原有功能的前提下,来试用新的变化\n\n12345678910111213141516171819&lt;p id=p1&gt;&lt;p&gt;&lt;p id=p2&gt;&lt;p&gt;&lt;script type=textjavascript src=myAjax.js&gt;&lt;script&gt;   &lt;script&gt;       myAjax.get(data5.json,function(result)&#123;           showMsg(JSON.parse(result),p1)       &#125;);       myAjax.get(data4.json,function(result)&#123;           showMsgAdapter(JSON.parse(result),p2)       &#125;);       function showMsg(obj,p)&#123;           p.innerHTML = obj.name;       &#125;       适配器模式:       function showMsgAdapter(arr,p)&#123;           showMsg(arr[0],p)       &#125;   &lt;script&gt;\n5.观察者模式开服务器才行\n123456789101112131415161718&lt;button id=btn1&gt;发布&lt;button&gt;   &lt;script&gt;       var publisher = &#123;           register:function (subscriber) &#123;               this.subscriber = subscriber;           &#125;,           publish:function (msg) &#123;               this.subscriber(msg);           &#125;       &#125;;       向发布者订阅信息,订阅者使用函数来充当       publisher.register(function (msg) &#123;\t           console.log(msg);       &#125;);       btn1.onclick=function()&#123;           publisher.publish(我是发布的信息);       &#125;   &lt;script&gt;\n1234567891011121314151617181920212223242526272829303132333435363738394041&lt;button id=btn1&gt;发布1&lt;button&gt;&lt;button id=btn2&gt;发布2&lt;button&gt;  \t&lt;script&gt;      var publisher = &#123;          register:function (event,subscriber) &#123;              if(typeof subscriber != function) return;              先判断event是否存在              if(!this[event]) this[event] = [];              this[event].push(subscriber);          &#125;,          publish:function (event,msg) &#123;              if(!(event in this)) return;              for(var sub of this[event]) &#123;                  sub(msg)              &#125;          &#125;,          remove:function(event,sub)&#123;              if(!this[event] ||this[event].indexOf(sub)==-1) return;              this[event].splice(this[event].indexOf(sub),1)          &#125;      &#125;;      向发布者订阅信息,订阅者使用函数来充当      var f1 = function(msg)&#123;        console.log(我是第一个订阅者:+msg)      &#125;;      var f2 = function (msg) &#123;          console.log(我是第二个订阅者:+msg);      &#125;;      publisher.register(first,f1);      publisher.register(second,f2);      btn1.onclick=function()&#123;\t          publisher.publish(first,发布1);      &#125;;我是第一个订阅者:发布1      btn2.onclick=function () &#123;          publisher.publish(second,发布2)      &#125;;我是第二个订阅者:发布2      publisher.remove(first,f1);点击按钮1失去效果  &lt;script&gt;\n\n例:利用观察者模式来给按钮添加三击事件\n\n12345678910111213141516171819202122232425262728293031323334&lt;button id=btn1&gt;按钮1&lt;button&gt;   &lt;button id=btn2&gt;按钮2&lt;button&gt;   &lt;script&gt;   \t在按钮的原型对象中添加addMyEventListener方法,这个方法用来给按钮添加自定义事件.       HTMLButtonElement.prototype.addMyEventListener = function(event,f)&#123;           if(!this[event]) this[event] = [];           this[event].push(f);       &#125;;       调用addMyEventListener函数给按钮1添加自定义三击事件       btn1.addMyEventListener(threeclick,function()&#123;           console.log(您三击了);       &#125;);       定义变量times用来记录三次点击事件的时间       var times =[];              function step() &#123;           if(times.length ==3)&#123;               times.shift();           &#125;           times.push(new Date());           if(times.length ==3)&#123;               if(times[2]-times[0]&lt;=1000)&#123;                   times.length = 0;                   for(tc of this.threeclick)&#123;                       tc();                   &#125;               &#125;           &#125;       &#125;       给俩个按钮都添加三击事件       btn1.addEventListener(mousedown,step);       btn2.addEventListener(mousedown,step);       只有按钮1才有三击事件,按钮2会报错   &lt;script&gt;","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/designPattern/","external_link":""},{"title":"prototype","date":"2016-02-08T11:24:45.000Z","content":"通过上一章节&lt;面向对象入门&gt;相信大家对于面向对象都有了一些很直白的了解,那么面向对象中一个很重要的概念”原型”又是个什么玩意呢?可以说,如果把”原型”给吃透了,那么你对于面向对象的知识点以及掌握50%了(当然,只是对于我们这些新手入门而已…).\n我们知道,一切皆是对象,当然函数也不例外.那么既然是个对象,就一定有它的属性,只是很多隐藏的属性我们以前不知道而已.这里我就先说说函数的第一个比较重要的属性–prototype.\n当我们创建了一个函数A之后(也就是申明),这个函数A就有了它默认的一个属性prototype,这个属性是内置好了.这时浏览器就会在内存中创建一个”对象B”,而前面函数A的prototype的属性的值指向的就是这个”对象B”,此时我们就称”对象B”为函数A的原型对象.他们之间的这种联系并不是简单的prototype的值指向”对象B”,其实在”对象B”中也有一个默认的属性constructor,它的值指向了这个函数A!(注:其实任意函数中都有prototype，只不过不是构造函数的时候prototype我们不关注而已)\nOK,说到这里,小伙们可能有点绕,那么我直接上图吧!(博主还是有一定美术功底的)\n\n这是一张简易的原型解析图,就先看最上面俩个框吧.函数A创建完毕后,它的默认属性prototype指向的是浏览器自动生成的对象B,而对象B的内置属性constructor指向的是这个函数A,此时,对象B就是函数A的原型对象!\n好的,相信大家在博主生动形象的解析下对原型对象应该有了一个基本概念,那么这个原型对象它有什么用吗?诶,你们还别小看它,它的用处还真挺大的.\n这里要小伙们回忆一下了,在上节中,我们知道了创建一个对象可以通过构造函数的方式来进行创建.当我们用上面的函数A作为构造函数来创建一个对象A1时,也就是var A1 = new A(); new一个对象出来.这时,对象A1其实也会有一个默认的属性值[proto].就像上面描述的,构造函数A它的默认属性prototype指向的是原型对象B,[[proto]]属性指向的也是原型对象B.  同一个构造函数能用于创建不同的对象,再次利用构造函数A来创建一个对象A2,它的[[proto]]指向的当然也是原型对象B.(现在大家可以回头看看我的img1.png了)\n下面还是来看一个例子吧.\n1234567例1:function Person(name,age)&#123;  this.name = name;  this.age = age;&#125;var person1 = new Person(&quot;王先生&quot;,22);var person2 = new Person(&quot;张先生&quot;,23);\nperson1 和 person2都是通过构造函数Person创建出的对象,所以他俩的proto指向的都是Person的对象原型.\nhasOwnProperty( )方法用于判断一个对象中的属性是否来自对象本身,也就是能判断它的来源,它是来自对象本身,还是来自这个对象的[[proto]]属性指向的原型.\n若是来自于对象本身,则返回true,    来自于原型和不存在都返回fasle;\n将例1稍微改动一下,在Person的原型对象中添加一个eat函数.12345678910111213141516例2:function Person(name,age)&#123;    this.name = name;    this.age = age;&#125;Person.prototype.eat=function()&#123;    console.log(&apos;a&apos;);&#125;var person1 = new Person(&quot;王先生&quot;,22);var person2 = new Person(&quot;张先生&quot;,23);给person1对象添加属性sexperson1.sex = &quot;男&quot;;console.log(person1.hasOwnProperty(&apos;sex&apos;));console.log(person1.hasOwnProperty(&apos;eat&apos;));=&gt;true=&gt;false\n可以看到不管是name,age属性都是eat函数都是在构造函数时就写入了的,也就是都存在于Person的原型对象中,所以第二个console.log输出的就是false,而sex这个属性是我们在创建完对象person1之后添加的属性,所以可以理解为是person1的私有属性,是存在于person1对象本身,所以第一个console.log返回的就是true.\ninstanceof操作符和isPrototypeOf( )方法俩个方法非常相似,都是用于检测一个对象是否来自于一个构造函数12345678910使用instanceof操作符function A()&#123; &#125;var a1 = new A();console.log(a1 instanceof A);=&gt;truefunction A()&#123; &#125;var a1 = new A();console.log(A.prototype.isPrototypeOf(a1));=&gt;true\nisPrototypeOf()函数用于指示对象是否存在于另一个对象的原型链中。如果存在，返回true，否则返回false。\n可以简单理解为一个对象是否是通过这个构造函数来创建的.\n和instanceof相似,但instanceof是操作符,而isPrototypeOf( )是方法\n使用组合模型和动态模型组合模型\n简单来说,就是属性在构造函数中创建,而方法在构造函数的原型中创建,如:12345678910111213141516function Person(name,age)&#123;  this.name = name;\t\t\t\t\t\t直接在构造函数中封装属性;  this.age = age;&#125;Person.prototype.eat=function(food)&#123;\t在构造函数的原型(Person.prototype)中封装方法;  alert(this.name+&quot;like eat&quot;+food);&#125;Person.prototype.play=function(playName)&#123;  alert(this.name+&quot;like play&quot;+playName);&#125;var p1 = new Person(&quot;王先生&quot;,22);var p2 = new Person(&quot;张先生&quot;,23);p1.eat(&quot;拨娜娜&quot;);p2.play(&quot;皮革&quot;);\n动态模型\n优点:封装性好1234567891011121314151617function Person(name,age)&#123;  this.name = name;  this.age = age;  if(!Person.prototype.eat)&#123;\t\t\t\t\t\t\t判断原型中是否有eat函数    Person.prototype.eat=function(food)&#123;\t\t\t\t若没有的话则添加      console.log(this.name+&quot;like eat&quot;+food)    &#125;  &#125;  if(!Person.prototype.play)&#123;    Person.prototype.play=funciton(playName)&#123;      console.log(this.name+&quot;like play&quot;+playName)    &#125;  &#125;&#125;在此可以理解为每调用一次构造函数就执行构造函数,所以每执行一次就会把原先在原型中的函数舍弃,更改为和它一样的函数,则造成了有废弃的函数产生;var p1 = new Person(&quot;王先生&quot;,22);\t\tvar p2 = new Person(&quot;张先生&quot;,23);\n以上俩种模型都有其各自的优点和缺点,那么有没有好点的模型来完善这俩种模型呢,下面来看看这个动态组合模型:\n123456789101112131415function Person(name,age)&#123;  this.name = name;  this.age = age;&#125;Person.prototype = &#123;  eat:function(food)&#123;\t\t\t\t      console.log(this.name+&quot;like eat&quot;+food)    &#125;  play:funciton(playName)&#123;      console.log(this.name+&quot;like play&quot;+playName)    &#125;&#125;在此可以理解为每调用一次构造函数就执行构造函数,所以每执行一次就会把原先在原型中的函数舍弃,更改为和它一样的函数,则造成了有废弃的函数产生;var p1 = new Person(&quot;王先生&quot;,22);\t\tvar p2 = new Person(&quot;张先生&quot;,23);\n终极动态组合模型1234567891011121314151617181920function Person(ldy)&#123;  this._init(ldy);&#125;Person.prototype = &#123;  _init:function(ldy)&#123;    this.name = ldy.name;    this.age = ldy.age;  &#125;  eat:function(food)&#123;\t\t\t\t      console.log(this.name+&quot;like eat&quot;+food)    &#125;  play:funciton(playName)&#123;      console.log(this.name+&quot;like play&quot;+playName)    &#125;&#125;通过向构造函数中传递一个对象opt,这个对象中将要添加的属性添加进去var p1 = new Person(&#123;  name:&quot;王先生&quot;,  age:22,&#125;)\n最后这种终极动态组合模型摒弃了以往我们对于构造函数的看法,它在创建对象 p1的时候,传入进去的是一个对象,这样就可以传入不同数量的属性.并且将要获取的属性全部直接封装到Person的原型对象中,这样构造函数Person中就只需要调用一下原型对象中的_init()函数就可以了(注:_init一般用于表示初始化),想要后续添加什么方法直接在Person的原型对象中添加.\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/prototype/","external_link":""},{"title":"ES9已经来了 Are you ready?","date":"2018-08-06T14:48:00.000Z","content":"前言该篇文章主要是介绍了ES9新加的一些新特性。\n1. 异步迭代在asyncawait的某些时刻，你可能尝试在同步循环中调用异步函数。例如：\n123456async function process(array) &#123;  for (let i of array) &#123;    await doSomething(i);  &#125;&#125;复制代码\n这段代码不会正常运行，下面这段同样也不会：\n123456async function process(array) &#123;  array.forEach(async i =&gt; &#123;    await doSomething(i);  &#125;);&#125;复制代码\n这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。\nES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。例如：\n12345async function process(array) &#123;  for await (let i of array) &#123;    doSomething(i);  &#125;&#125;\n2. Promise.finally()在ES6中，一个Promise链要么成功进入最后一个then()要么失败触发catch()。而实际中，我们可能需要无论Promise无论成功还是失败，都运行相同的代码。例如清除，删除回话，关闭数据库连接等操作。\nES9中，允许使用finally()来指定最终的逻辑。\n如下：\n12345678910111213141516171819202122232425262728293031323334353637let count = () =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(100)        &#125;, 1000);    &#125;)&#125;let list = () =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve([1, 2, 3])        &#125;, 1000);    &#125;)&#125;let getList = async () =&gt; &#123;    let c = await count()    console.log(async)    let l = await list()    return &#123; count: c, list: l &#125;&#125;console.time(start);getList().then(res =&gt; &#123;    console.log(res)&#125;).catch(err =&gt; &#123;    console.timeEnd(start)    console.log(err)&#125;).finally(() =&gt; &#123;    console.log(finally)&#125;) 执行结果async&#123;count: 100, list: [1, 2, 3]&#125;finally\n3. RestSpread 属性3.1 ES6中(…)在ES6中引入了三点...，作用主要是Rest参数和扩展运算符:\n作用对象仅用于数组\n1.将一个未知数量的参数表示一个数组:\n1234567restParam(1, 2, 3, 4, 5);function restParam(p1, p2, ...p3) &#123;   p1 = 1   p2 = 2   p3 = [3, 4, 5]&#125;\n2.扩展运算符：\n12const values = [99, 100, -1, 48, 16];console.log( Math.max(...values) );  100\n3.2 ES9中(…)在ES9中为对象提供了像数组一样的Rest参数和展开运算符。\n\nRest参数用法\n\n12345678var obj = &#123;    a: 1,    b: 2,    c: 3&#125;const &#123; a, ...param &#125; = obj;console.log(a)     1console.log(param) &#123;b: 2, c: 3&#125;\n\nSpread用法，用于收集所有的剩余参数：\n\n123456789var obj = &#123;    a: 1,    b: 2,    c: 3&#125;function foo(&#123;a, ...param&#125;) &#123;    console.log(a);    console.log(param)&#125;\n跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。\n\n扩展运算符可以在其他对象内使用\n\n123const obj1 = &#123; a: 1, b: 2, c: 3 &#125;;const obj2 = &#123; ...obj1, z: 26 &#125;; obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125;\n3.3 Spread的使用场景\n1.浅拷贝\n可以利用(…)来进行一个对象的拷贝，但是这种拷贝只能拷贝对象的可枚举自有属性。\n\n1234567891011121314151617181920212223242526var obj = &#123;    name: LinDaiDai,    looks: handsome,    foo() &#123;        console.log(old);    &#125;,    set setLooks(newVal) &#123;        this.looks = newVal    &#125;,    get getName() &#123;        console.log(this.name)    &#125;&#125;var cloneObj = &#123;...obj&#125;;cloneObj.foo = function() &#123;    console.log(new)&#125;;console.log(obj)      &#123; name: LinDaiDai,looks: handsome, foo: f foo(), get getName:f getName(), set setLooks: f setLooks(newVal)&#125;console.log(cloneObj) &#123; name: LinDaiDai,looks: handsome, foo: f foo(), getName: undefined, setLooks: undefined &#125;obj.foo() oldcloneObj.foo() new\n如上所示，定义了一个对象obj 并使用(...)进行对象的拷贝，修改对象内的函数foo()，并不会影响原有的对象，但是原有对象的setter和getter却不能拷贝过去。\n\n2.合并俩个对象\n\n123const merged = &#123;...obj1, ...obj2&#125;;同：const merged = Object.assign(&#123;&#125;, obj1, obj2);\n4. 正则表达式命名捕获组4.1 基本用法Javascript正则表达式中使用exec()匹配能够返回一个对象，一个包含匹配字符串的类数组。\n如下面案例中的匹配日期格式：\n12345678910正则表达式命名捕获组    const reDate = (d&#123;4&#125;)-(d&#123;2&#125;)-(d&#123;2&#125;),            match = reDate.exec(2018-08-06);    console.log(match);     [2018-08-06, 2018, 08, 06]         这样就可以直接用索引来获取年月日：    match[1]  2018    match[2]  08    match[3]  06\n返回一个数组，数组第0项为与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。\n上面的案例，若是改变正则表达式的结构就有可能改变匹配对象的索引。\n如进行如下修改：\n12345678910正则表达式命名捕获组    const reDate = (d&#123;2&#125;)-(d&#123;2&#125;)-(d&#123;4&#125;),            match = reDate.exec(2018-08-06);    console.log(match);     [2018-08-06, 08, 06, 2018]         但此时年月日的索引就改变了    match[3]  2018    match[1]  08    match[2]  06\n可以看到上面写法的弊端，因此在ES9中允许命名捕获组使用符号?&lt;name&gt;,如下：\n123456789const reDate = (?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;),        match = reDate.exec(2018-08-06)console.log(match); [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]此时可以使用groups对象来获取年月日match.groups.year  2018match.groups.month  08match.groups.day   06\n命名捕获组的写法相当于是把每个匹配到的捕获组都定义了一个名字，然后存储到返回值的groups属性中。\n4.2 结合replace()命名捕获也可以使用在replace()方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：\n12345const reDate = (?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;),      d = 2018-08-06      USADate = d.replace(reDate, $&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;);console.log(USADate); 08-06-2018\n还可以将中文名的姓和名调换：\n12345const reName = (?&lt;sur&gt;[a-zA-Z]+)-(?&lt;name&gt;[a-zA-Z]+);      Chinese = Lin-DaiDai,      USA = Chinese.replace(reName, $&lt;name&gt;-$&lt;sur&gt;);console.log(USA); DaiDai-Lin\n5. 正则表达式反向断言5.1 基本用法先来看下正则表达式先行断言是什么：\n如获取货币的符号\n123456const noReLookahead = D(d+),\t  reLookahead = D(?=d+),\t  match1 = noReLookahead.exec($123.45),      match2 = reLookahead.exec($123.45);console.log(match1[0]);  $123   console.log(match2[0]);  $\n可以看到若是在正则表达式中加入?=的话，匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。\n在ES9中可以允许反向断言：\n123const reLookahead = (?&lt;=D)[d.]+,match = reLookahead.exec($123.45);console.log(match[0]);  123.45\n使用?&lt;=进行反向断言，可以使用反向断言获取货币的价格，而忽略货币符号。\n5.2 肯定反向断言上面的案例为肯定反向断言，也就是说D这个条件必须存在，若是:\n12345const reLookahead = (?&lt;=D)[d.]+,        match1 = reLookahead.exec(123.45),        match2 = reLookahead.exec(12345);console.log(match1[0]);  45console.log(match2);   null\n可以看到match1匹配到的是45,这是由于在123前面没有任何符合D的匹配内容，它会一直找到符合D的内容，也就是.然后返回后面的内容。\n而若是没有满足前面肯定反向断言的条件的话，则返回null.\n6. 正则表达式dotAll模式正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现:\n123456hello.world.test(&apos;hellonworld&apos;);   falsehello.worlds.test(&apos;hellonworld&apos;);  trueconsole.log(hello.worlds.test(`helloworld`))    true\n7. 正则表达式 Unicode 转义到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为p{...}和P{...}，在正则表达式中使用标记 u (unicode) 设置，在p块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。\n12const reGreekSymbol = p&#123;Script=Greek&#125;u;console.log(reGreekSymbol.test(&apos;π&apos;));  true\nGreek为希腊语的意思。\n8. 非转义序列的模板字符串最后，ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。\n之前，u开始一个 unicode 转义，x开始一个十六进制转义，后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 C:uuuxxx111。更多细节参考模板字符串。\n后语知识产权无价，支持原创。\n参考文章：\n[译] ES2018（ES9）的新特性\n【译】ES2018 新特性：RestSpread 特性\nES6ES7ES8ES9 可以看到javascript并没有让我们失望，这几年的更新没有落下，不间断的学习，才能保证自己不被这个社会淘汰…\n","tags":["前端进阶","ES9"],"path":"2018/08/06/webNotes/advanced/JavaScript/es9/","external_link":""},{"title":"前端上传文件及进行文件类型大小限制","date":"2018-06-06T10:28:45.000Z","content":"前言产品又提需求了~前段时间在公司的项目中接到这样一个需求：用户需要上传多个特定格式(只能是图片excalwordtxt)的文件存储至i服务器中，并可以进行查看。当然，在这个需求中，我们前端要做的只是给用户一个选择文件的按钮，让用户能够选择本地文件，且筛选出特定格式的文件，并对用户选择的文件进行格式、大小的限制，然后将这些文件通过Ajax发送给后台就可以了。\n一步一步来…\n一.选择文件的HTML代码博主项目使用的前端框架是angular4,所以其中可能使用了一些angular4的语法，不过前端框架之间都是异曲同工，相信一些简单的指令大家也能够猜到是什么意思。\n首先给大家演示一下我所要做的功能如下图所示，我在页面中设置了一个选择文件的 + 号按钮，用户点击 + 号可以按住Ctrl键进行多选文件，选择完毕之后，可以根据选择的文件类型的不同展示给用户不同的文件logo。\n\n这边先直接贴上所有HTML的代码，再来进行详细12345678910111213141516171819202122232425262728&lt;div class=ui-g-3 style=width: 100%;&gt;    &lt;div class=selectPic&gt;        选择文件    &lt;div&gt;    &lt;div class=addPic (click)=F_Open_dialog()&gt;        &lt;span class=plusSign&gt;+&lt;span&gt;    &lt;div&gt;    &lt;input type=file name=fileToUpload2 id=fileToUpload2 (change)=onSelectByButton()     multiple=multiple style=display:none  accept=image*,textplain ,    applicationvnd.ms-excel ,applicationvnd.openxmlformats-officedocument.spreadsheetml.sheet,     applicationmsword, applicationmsexcel,    applicationvnd.openxmlformats-officedocument.wordprocessingml.document,    applicationvnd.openxmlformats-officedocument.wordprocessingml.template&gt;    &lt;ul style=float:left; id=deal class=picList&gt;        &lt;li class=fl text_center margin_left_5 *ngFor=let data of fileUploaded; let idx=index&gt;            &lt;!--上传的文件不同的类型显示不同的logo--&gt;            &lt;img width=70 height=70 src=&#123;&#123;data.fileUrl&#125;&#125; &gt;            &lt;!--右上角的删除图片--&gt;            &lt;span class=fa fa-fw fa-close (click)=deletePicture(idx) style=float: right;&gt;&lt;span&gt;            &lt;!--文件名--&gt;            &lt;p style=display: block [title]=data.fileName class=fileName&gt;&#123;&#123;data.fileName&#125;&#125;&lt;p&gt;        &lt;li&gt;        &lt;!--上传文件时的loading--&gt;        &lt;li class=fl *ngFor=let dataLoading of loadingObj style=float:left;&gt;            &lt;img width=70 height=70 src=&#123;&#123;dataLoading.url&#125;&#125; &gt;        &lt;li&gt;    &lt;ul&gt;&lt;div&gt;\n1.1选择文件上面的HTML代码只是繁多，其实并不复杂。\n12&lt;div class=addPic&gt;&lt;div&gt;&lt;input type=file style=display: none &gt;\n这俩个标签构成了选择文件的加号这里我习惯在页面中写一个display为none的input标签，然后用其他标签来控制其样式，如在这里我就用了另一个class为addPic的div来显示选择文件的按钮效果。样式这里就不贴了很简单。\n当用户点击 + 号 会触发F_Open_dialog()这个方法：123F_Open_dialog() &#123;  document.getElementById(fileToUpload2).click();&#125;\n它其实也就是触发了input的选择文件的事件\n此时页面中就会出现本地文件夹供用户选择文件。\n2.input详解在上面的HTML代码中，最繁琐的就是input标签了，下面对其中的各种属性做一个说明：123456type=file --》类型为文件的input标签multiple=multiple --》 支持多选文件(change)=onSelectByButton()  --》选择了文件触发onSelectByButton()方法accept=image*,textplain, .......   --》用户能够看到的文件类型，定义了accept后，选择文件的类型会变为自定义文件，也就是只让用户能够看到你给其限制的类型的文件，但若是用户选择了全部文件，还是可以选择到其他类型的文件，所以我们在后面提交文件信息的时候在js中还要做一层判断\n\n更多的accpet的内容信息可以自行度娘…\n3.上传完文件之后的文件显示可以看到在HTML代码中是定义了ul标签和li标签来盛放上传成功之后的文件的。简单说一下angular4语法12345*ngFor=let data of fileUploaded; let idx=index   类似vue中的v-forfileUploaded 数组，所有已经上传的文件的集合，在js中定义data 每一个文件let idx = index 定义变量idx 为 index下标，其实也就是为了简写index单词而已\n可以看到我定义了俩种不同的li标签，一种是盛放上传成功的文件，一种盛放正在加载的图片\n###二.上传文件的js代码\n在上面的讲解中，我们在用户选择了文件之后会触发一个onSelectByButton()方法，该方法就是进行文件上传功能。首先定义几个变量…这里使用了TypeScript的写法，不过大家应该也能看懂1234fileObj: any = [];盛放所有要上传的文件fileUploaded: any = [];盛放已经上传成功的文件loadingObj: any = [];上传图片时的loading数组loadingImage = &#123; url: .assetsimagesloading.gif &#125;;上传图片时的loading\n然后就是设计上传的方法：123456789101112131415161718192021222324252627282930313233343536373839404142onSelectByButton() &#123;选择文件   let fileObjSelect = document.getElementById(fileToUpload2)[files];   let reg = (?:jpeg|png|jpg)|-officedocument.*|text.*|vnd.ms-exceli;判断文件类型是不是图片txtWord文档格式Excel格式   let postfixReg = .+.;获取文件名后缀的正则表达式   let formdata = new FormData();    *限制用户选择的文件类型和大小*   for (var i = 0; i &lt; fileObjSelect.length; i++) &#123;遍历所有选择的文件     let file = fileObjSelect[i];     if (reg.test(file.type)) &#123;判断文件类型       if (file.size &gt; 0 &amp;&amp; file.size &lt;= 10485760) &#123;判断文件大小         this.fileObj.push(file);将要上传的文件推进数组中         this.loadingObj.push(this.loadingImage);推进一个加载loading的图片         formdata.append(file, file);       &#125; else &#123;         this.growl(error, 错误信息, 上传的文件不能小于0kb且不能大于10mb！);growl是自己封装的一个错误提示的方法       &#125;     &#125; else &#123;       this.growl(error, 错误信息, 请选择excel、 word、 txt、 jpg、 png格式的文件！);     &#125;   &#125;   *这里是我自己封装的一个post请求的方法，第一个参数为所有要上传的文件，第二个为接口地址(后台会给你)*   this.httpService.httpPostAFile(formdata, filesetAttachment).then(data =&gt; &#123;      data就是你发送post请求之后后台返回给你的数据，其中可能包含所有你上传的文件的信息     if (data != null &amp;&amp; data[success] &amp;&amp; data[data]) &#123;       data.data.forEach(dataFile =&gt; &#123;遍历文件数组         let postfix = dataFile[fileName].replace(postfixReg, );获取到每一个文件的后缀         if (postfix === jpeg || postfix === png || postfix === jpg) &#123;                 这里拿到的是图片文件，你可以在这里做一些事情         &#125; else &#123;           这里拿到的是所有非图片的文件          我在这里定义了一个方法，用于对不同类型的文件显示给用户不同的logo           dataFile[fileUrl] = this.setFileUrl(postfix); dataFile是每一个文件，我定义一个属性fileUrl用于显示文件logo         &#125;         this.fileUploaded.push(dataFile);将上传成功的文件推进数组       &#125;);      this.loadingObj = [];清空加载loading     &#125;   &#125;) &#125;\n贴一下上面用到的setFileUrl()方法：1234567891011setFileUrl(postfix) &#123;设置文件在列表中的显示  if (postfix === docx || postfix === docm || postfix === dotx || postfix === dotm) &#123;Word文档    return .assetsimagesmemberdoc.png;  &#125; else if (postfix === xls || postfix === xlsx    || postfix === xlsm || postfix === xltx || postfix === xltm    || postfix === xlsb || postfix === xlam) &#123;    return .assetsimagesmemberexcel.png;  &#125; else if (postfix === txt) &#123;    return .assetsimagesmembertxt.png;  &#125;&#125;\n\n高清无码自己拿…更多的矢量图可以到阿里巴巴矢量图标库中拿前端应该都知道的iconfont\n三.删除文件在用户上传完了文件之后，可以点击右上角的删除图标删除要上传的文件1234567deletePicture(idx) &#123;删除文件  var oBox = document.getElementById(deal);  var aSpan = oBox.getElementsByTagName(span);  oBox.removeChild(aSpan[idx].parentNode);  this.fileUploaded.splice(idx, 1);  this.fileObj.splice(idx, 1);&#125;\n不管是在vue还是在angular中，在对数组或者对象进行操作时，都尽量使用数组对象自带的一些方法，如数组中的splice slice sort push pop等，而不要采用以下的方式：1234arr = [one, two, three];arr[0] = newOne;arr.length = 1;\n采用上面的方式会使得视图层不能够及时的更新之前在倔金上看到一篇有关不能更新数组视图的详解，还写了一些vue的小技巧，有需要的小伙可以移步：你或许不知道Vue的这些小技巧\n后语2018年6月6日  深圳 台风划水一天\n","tags":["前端进阶"],"path":"2018/06/06/webNotes/advanced/JavaScript/uploadFiles/","external_link":""},{"title":"webpack基础","date":"2017-02-16T12:54:40.000Z","content":"1. 安装webpack在配置webPack之前，先确保电脑中有没有安装node。\n全局安装webpack\n1$ npm install webpack -g\n在E:每日笔记vue新建文件夹    创建一个文件夹webpack1\n2. 配置webpack文件夹webpack1创建 webpack.config.js 它的作用和gulpfile.js一样就是一个配置项，设置 webpack 任务功能。\n\nentry 入口文件 让webpack用哪个文件作为项目的入口\noutput 出口 让webpack把处理完成的文件放在哪里\nmodule 模块 要用什么不同的模块来处理各种类型的文件\nplugins 是插件项\nresolve 用来设置路径指向\nwatch 用监听文件有改动后执行打包\n\n1.webpack.config.js文件\n123456module.exports = &#123;    entry:&apos;.modulemain.js&apos;,\t\t指定入口文件为main.js    output:&#123;        filename:&quot;.jsbundle.js&quot;\t指定处理完成的文件放在js文件夹下的bundle.js(无需我们手动创建)    &#125;&#125;\n2.main.js文件\n12var obj = require(.show);obj.show.show1(1,2);\n3.show.js文件\n123456exports.show = &#123;    show1 (a,b) &#123;      console.log(a+b)      return a+b    &#125;  &#125;\n4.webpack命令\n12在webpack1文件夹目录下输入一下指令来打包$ webpack\n完成之后,可以看到webpack1文件夹下多了一js文件夹,其中有一个bundle.js文件\n3. 创建主页面并应用bundle.js在webpack1下创建index.html并引用bundle.js\n12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;title&gt;&lt;head&gt;&lt;body&gt;  &lt;body&gt;&lt;script src=&quot;jsbundle.js&quot;&gt;&lt;script&gt;&lt;html&gt;\n打开页面,打开控制台,可以看到输出3.\n4. 配置多个入口文件上面的例子中,我们使用的只有一个main.js文件入口\n如何配置多个入口文件?\n需要引入CommonsChunkPlugin,这个属于webpack内置的一个插件，需要在当前目录安装webpack(使用指令npm install webpack)\n作用是：用于提取多个入口文件的公共脚本部分\n\n1.在E:每日笔记vue新建文件夹    创建一个文件夹webpack2\n\n\n2.在webpack2中创建webpack.config.js\n\n1234567891011121314151617181920212223用于提取多个入口文件的公共脚本部分var CommonsChunkPlugin = require(webpackliboptimizeCommonsChunkPlugin);var webpack = require(webpack);module.exports = &#123;  entry: &#123;    bundle1:.modulepage01,\t\tbundle2:.modulepage02  &#125;,  output: &#123;    *       [name]-&gt;entry的键名    *    filename: .js[name].js  &#125;,  *     plugins接收的是一个数组  *  plugins: [     不需要加.js，会自动添加.js后缀    new CommonsChunkPlugin(.common)  ]&#125;\n\n3.在webpack2创建一个module文件夹,文件夹中:\n\n​    1.page01.js\n12var show = require(.show)alert(show.sum(3, 8))\n​    2.page02.js\n12var show = require(.show)alert(show.sum(5, 9))\n​    3.show.js\n12345exports.sum = function (a, b) &#123;  console.log(a + b)  return a + b&#125;\n\n4.安装webpack\n执行指令:\n12&gt; $npm install webpack&gt;\n\n\n文件夹下出现node_modules文件夹,里面存放的就是一些依赖\n5.执行指令:\n\n1$ npm init\t\t回车,回车,回车....\n文件夹下出现package.json文件\n可以看到里面是一些配置信息\n1234567891011&#123;  name: webpack2,  version: 1.0.0,  description: ,  main: webpack.config.js,  scripts: &#123;    test: echo Error: no test specified &amp;&amp; exit 1  &#125;,  author: ,  license: ISC&#125;\n\n5.执行指令:\n\n1$ webpack\nwebpack2目录下出现一个js文件夹.文件夹中有:\n1bundle.js\tbundle.js\tcommon.js\n说明打包成功\n5.在webpack2目录下创建page01.html和page02.html文件\n1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;title&gt;&lt;head&gt;&lt;body&gt;  &lt;body&gt;&lt;script src=&quot;jscommon.js&quot;&gt;&lt;script&gt;&lt;script src=&quot;jsbundle1.js&quot;&gt;&lt;script&gt;&lt;html&gt;\npage02.html文件\n1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;page02&lt;title&gt;&lt;head&gt;&lt;body&gt;  &lt;body&gt;&lt;script src=&quot;jscommon.js&quot;&gt;&lt;script&gt;&lt;script src=&quot;jsbundle2.js&quot;&gt;&lt;script&gt;&lt;html&gt;\n分别打开page01和page02\n可以看到弹出不同的数字11 和14\n5. 安装es6转es5模块1.安装es6转es5模块\n1$ npm install babel-core babel-loader babel-preset-es2015\n2.配置设置webpack.config.js            \n123456789101112module.exports = &#123;    ...    module: &#123;                    loaders:[                            &#123;                 test: .js$,                 exclude: node_modules,                 loader: babel-loader             &#125;,        ]    &#125;&#125;\n3.配置设置.babelrc文件\n需要注意，在es6转es5的时候在webpack.config.js同级目录也要添加.babelrc文件，并写入：\n12345&#123;  presets: [    es2015  ]&#125;\n6. less1.打包样式和转换less或sass\n123456安装出来css模块$ cnpm install style-loader css-loader --save安装转less模块$ cnpm install less-loader less --save安装转sass模块$ cnpm install sass-loader node-sass --save\n如果你只想使用less,可以连写\n1cnpm i style-loader css-loader less-loader less --save-dev\n2.编写less和sass文件\nless\n1234@color:#666;body&#123;    background:@color2;&#125;\nsass\n1234$color: red;body&#123;    background:$color;&#125;\n3.配置设置webpack.config.js\n123456789101112131415161718192021222324module.exports = &#123;    entry:.modulemain.js,    output:&#123;        filename:.jsbundle.js    &#125;,    module: &#123;         webpack使用loader的方式来处理各种各样的资源，比如说样式文件，我们需要两种loader，css-loader 和 style－loader，css-loader会遍历css文件        loaders:[                   &#123;                test: .(css|less)$,                 loader: style-loader!css-loader!less-loader            &#125;        ]    &#125;,    resolve: &#123;         自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名        extensions: [.js, .css,.less],        模块别名定义，方便后续直接引用别名，无须多写长长的地址        alias: &#123;            style : ..cssstyle.less,后续直接 require(style) 即可        &#125;    &#125;,    watch:true监听文件一旦改变重新打包&#125;\n4.在main.js引用\n12require(&apos;..stylesstyle1.css&apos;);require(&apos;..stylesstyle2.less&apos;)\n案例:\n1.创建文件夹webpack4,并使用:\n1npm i webpack style-loader css-loader less-loader less\n出现node_modules\n2.\n1$npm install webpack\n出现package-lock.json\n3.\n1$npm init\t回车回车....\n出现package.json\n4.\n创建webpack.config.js并配置\n123456789101112131415161718192021222324module.exports = &#123;    entry:.modulemain.js,    output:&#123;        filename:.jsbundle.js    &#125;,    module: &#123;         webpack使用loader的方式来处理各种各样的资源，比如说样式文件，我们需要两种loader，css-loader 和 style－loader，css-loader会遍历css文件        loaders:[                   &#123;                test: .(css|less)$,                 loader: style-loader!css-loader!less-loader            &#125;        ]    &#125;,    resolve: &#123;         自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名        extensions: [.js, .css,.less],        模块别名定义，方便后续直接引用别名，无须多写长长的地址        alias: &#123;            style : ..cssstyle.less,后续直接 require(style) 即可        &#125;    &#125;,    watch:true监听文件一旦改变重新打包&#125;\n5.创建文件夹module里面有一个main.js文件    \n12require(&apos;..stylesstyle1.css&apos;);require(&apos;..stylesstyle2.less&apos;)\n6.创建index.html\n12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;title&gt;&lt;head&gt;&lt;body&gt;  我是Body&lt;body&gt;&lt;script src=&quot;jsbundle.js&quot;&gt;&lt;script&gt;&lt;html&gt;\n7.创建styles文件夹里面有一个style1.css文件和一个style2.less文件\n123body&#123;    background: red&#125;\n12345@color: gray;body&#123;    color:@color;&#125;\n现在打开index.html页面\n可以看到body变红,字体变灰\n如果在组件中,直接使用less的话,要在style中加上lang=&quot;less&quot;\n1&lt;style lang=&quot;less&quot;&gt;&lt;style\n","tags":["前端进阶","webpack"],"path":"2017/02/16/webNotes/advanced/JavaScript/webpack/","external_link":""},{"title":"CSS的基本知识","date":"2016-03-08T11:24:45.000Z","content":"1.CSS的作用:\n作用：将标签的样式进行修改\n\n2. CSS的引入方式2.1内联样式1&lt;div style=width:100px;height:100px;&gt; &lt;div&gt;\n​ 优点：优先级最高；\n​ 缺点： 代码冗余、代码混乱、维护困难；\n​ 使用场景：已经确定了的不会再有更改特定情况下才会使用。\n2.2.内部样式12345678&lt;head&gt;&lt;style&gt;    div&#123;        width:100px;        height:100px;    &#125;&lt;style&gt;&lt;head&gt;\n​ 优点：初步实现了结构与样式之间的分离、逻辑关系相对清楚、不会造成额外的服务器请求压力。\n​ 缺点：造成单个文件体积过大、造成前后端交互困难。\n​ 使用场景：大型网站的首页。\n3.外部样式\nlink: 用于引入其他文件；\n\n1&lt;link rel=stylesheet type=textcss href=csshtml.css &gt;\n属性： \n\nrel  引入文件和当前文件的关系stylesheet\nhref   引入文件的路径（地址）\ntype  引入文件的类型\n\n优点：结构与样式之间的分离、易于维护、一个样式库可以应用于多个页面缺点：会造成额外的服务器请求压力、可能会造成代码冲突、造成垃圾代码使用场景：大型网站的二三级页面。\n3. CSS的引入方式的优先级问题\n优先级问题 ：\n\n内联样式 &gt; 外部样式\n内联样式 &gt; 内部样式\n如果选择器优先级相同，则后加载的生效\n如果选择器优先级不同，则按选择器优先级\n4. CSS的选择器4.1 常用选择器\n1.继承权重：0.00001 (最低)\n\n1234567891011如&lt;style&gt;\t.father &#123;    \tfont-size: 14px;\t&#125;&lt;style&gt;&lt;body&gt;\t&lt;div class=fahter&gt;\t\t&lt;p&gt;我是p标签&lt;p&gt;\t&lt;div&gt;&lt;body&gt;\n上面的案例我给class为father的元素设置了字体大小为14px,则其子元素的字体大小也为14px,这就是继承。（并不是所有的css属性都可以继承给子元素,具体的能继承的属性请移步)\n\n2.通配符选择器权重：0.1\n*{ } 直接匹配所有的标签\n\n1234页面上所有的元素都有这个属性*&#123;    font-size: 14px;&#125;\n注意：通配符在执行的时候，会直接匹配所有的标签，这样也就导致了 通配符选择器的性能极其低下 平时开发时禁止使用该内容 如果需要清除对应的标签的样式，需要引用 reset.css\n\n3.标签名选择器权数重： 1\n\n123div &#123;\twidth: 100px;&#125;\n\n4.类选择器也称class选择器\n权重：10\n\n​ 用法 ：\n1.在标签内部设置一个 class 名称\n2.在css样式中使用. + class名称 + { }设置样式\n12345678910111213. +class 名称 + &#123; &#125;如&lt;style&gt;\t.father &#123;    \twidth: 100px;    \theight: 100px;    \tbackground: red;\t&#125;&lt;style&gt;&lt;body&gt;\t&lt;div class=fahter&gt;&lt;div&gt;&lt;body&gt;\n​ 生效范围： 针对所有class 名称相同的标签生效。\n\n5.ID选择器权重:100\n\n用法：\n1.设置 ID名称\n2.在css样式中使用# + id名称 +{ }设置样式\n12345678910111213# + id名称 +&#123; &#125;如&lt;style&gt;\t#father &#123;    \twidth: 100px;    \theight: 100px;    \tbackground: red;\t&#125;&lt;style&gt;&lt;body&gt;\t&lt;div id=fahter&gt;&lt;div&gt;&lt;body&gt;\n生效范围：同一个ID名称在一个页面中只能使用一次\n\n6.内联选择器权重：1000；\n\n用法：\n1&lt;div style=width: 100px&gt;&lt;div&gt;\n::: tip\n上面介绍的选择器都有它们各自的权重,选择器直接也是可以叠加的\n:::\n\n7.后代选择器（也称包含选择器）\n\n​ 注意事项:\n\n后代选择器可以嵌套多次\n放在后面的内容一定要属于前面内容的’子级’(选择内部的孩子)\n后代选择器时直接选择所有辈分 条件符合的孩子 不区分是 儿子 还是孙子\n\n用法：\n1234567891011121314&lt;style&gt;\t.father p &#123;       color: red; \t&#125;&lt;style&gt;&lt;body&gt;    &lt;div class=father&gt;        &lt;div&gt;        \t&lt;p&gt;我是p标签&lt;p&gt;        &lt;div&gt;        &lt;p&gt;我是p标签&lt;p&gt;    &lt;div&gt;&lt;body&gt;\n上述案例中的class为father下的所有p标签的字都会变为红色\n\n8.子代选择器 ： 只选择直系的后代 .class_1 &gt; p { }\n\n用法：\n1234567891011121314&lt;style&gt;\t.father&gt;p &#123;       color: red; \t&#125;&lt;style&gt;&lt;body&gt;    &lt;div class=father&gt;        &lt;div&gt;        \t&lt;p&gt;我是p1&lt;p&gt;        &lt;div&gt;        &lt;p&gt;我是p2&lt;p&gt;    &lt;div&gt;&lt;body&gt;\n上述案例中,只有class为father的直系后代的p标签的字才会变为红色,也就是p2\n\n9.相邻兄弟选择器用法： 选择器1+选择器2{ }\n\n注意：\n\n俩个选择器必须是兄弟关系(也就是要有同一个父级)\n俩个选择器必须是紧挨着的\n选择的是相连接的后面的兄弟\n\n12345678910111213141516171819202122&lt;style&gt;\t.item2 + li &#123;        font-weight:bold;        color: red;    &#125;&lt;style&gt;&lt;body&gt;    &lt;div&gt;        &lt;ul&gt;          &lt;li&gt;List item 1&lt;li&gt;          &lt;li class=item2&gt;List item 2&lt;li&gt;          &lt;li&gt;List item 3&lt;li&gt;&lt;!--红色--&gt;          &lt;li&gt;List item 4&lt;li&gt;        &lt;ul&gt;        &lt;ol&gt;          &lt;li&gt;List item 1&lt;li&gt;          &lt;li class=item2&gt;List item 2&lt;li&gt;          &lt;li&gt;List item 3&lt;li&gt;&lt;!--红色--&gt;          &lt;li&gt;List item 4&lt;li&gt;        &lt;ol&gt;      &lt;div&gt;&lt;body&gt;\n上面这个选择器只会把列表中的class为item2的后面的item3变为红色。第一个列表项和item2本身不受影响。\n\n10.同级元素通用选择器用法：选择器1~选择器2{ }\n\n注意：\n\n俩个选择器之间需要有相同的父级\n选择器2必须处于选择器1的后面\n选择具有相同的父级，并且加载顺序处于后面的内容\n\n12345678910111213141516171819202122&lt;style&gt;\t.item2 ~ li &#123;        font-weight:bold;        color: red;    &#125;&lt;style&gt;&lt;body&gt;    &lt;div&gt;        &lt;ul&gt;          &lt;li&gt;List item 1&lt;li&gt;          &lt;li class=item2&gt;List item 2&lt;li&gt;          &lt;li&gt;List item 3&lt;li&gt;&lt;!--红色--&gt;          &lt;li&gt;List item 4&lt;li&gt;&lt;!--红色--&gt;        &lt;ul&gt;        &lt;ol&gt;          &lt;li&gt;List item 1&lt;li&gt;          &lt;li class=item2&gt;List item 2&lt;li&gt;          &lt;li&gt;List item 3&lt;li&gt;&lt;!--红色--&gt;          &lt;li&gt;List item 4&lt;li&gt;&lt;!--红色--&gt;        &lt;ol&gt;      &lt;div&gt;&lt;body&gt;\n上面这个选择器会把列表中的class为item2的后面的列表项变为红色。第一个列表项和item2本身不受影响。\n可以看到选择器 +和~的区别就是+只针对一项元素,而~可能是多项的。\n\n11.属性选择器\n\n用法：\n\n[属性名称] + { }\n\n[属性名称 = 属性值] + { }\n\n\n12345678910111213141516171819202122&lt;style&gt;    [blue] &#123;        color: blue;    &#125;    input[type=text] &#123;        width:150px;        display:block;        margin-bottom:10px;        background-color:yellow;        font-family: Verdana, Arial;     &#125; &lt;style&gt; &lt;body&gt; \t&lt;input type=text &gt; \t&lt;ul&gt;        &lt;li blue&gt;List item 1&lt;li&gt;&lt;!--蓝色--&gt;        &lt;li&gt;List item 2&lt;li&gt;        &lt;li&gt;List item 3&lt;li&gt;        &lt;li&gt;List item 4&lt;li&gt;    &lt;ul&gt; \t &lt;body&gt;\n只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择\n\n12.群组选择器权重：不涉及\n\n目的： 省略代码(通过将不同选择器中相同部分抽离，统一设置)\n使用方式:\n12345678选择器1,选择器2, 选择器3... 选择器n&#123;\t某些相同的样式&#125;.div1, .div2, .div3&#123;\twidth:300px;\theight:300px;&#125;\n4.2 权重的计算权重的计算规则：相加\n\n目的: 为了选择属于某一个”内容之中”的某些元素\n\n​ 使用方式:\n123选择器1 + 空格 + 选择器2 + 选择器n &#123; \t需要设置的内容&#125;\n5. CSS选择器的优先级ID &gt; class &gt;标签名\n描述越精确，优先级越⾼高\n权位相加 权位越大 优先级越高\n6. overflow属性\n作用：规定超出范围的内容如何进行显示,不可继承\n\n\n代码⌨️\n\n12345div&#123;  \twidth:150px;  \theight:150px;  \toverflow:scroll;&#125;\n\n属性值✍️\n\n6.1 visible超出部分不做处理,内容不会被修剪,会呈现在元素框之外（默认样式）\n6.2 scroll让超出部分以滚动条的方式来显示；\n6.3 hidden让超出部分隐藏\n6.4 auto如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容\n6.5 inherit规定应该从父元素继承 overflow 属性的值\n\noverflow-x和overflow-y\n\noverflow实际上包含的是x 轴和y轴俩个方向,也可以将俩个方向分别设置\n12345div &#123;    width: 200px;    height: 200px;    overflow-x: scroll;&#125;\noverflow 在不同浏览器中呈现方式不一样，有兼容性问题\n7. float属性\n作用：设置元素浮动\n\n7.1 属性值\nleft 左浮动\n\nright 右浮动\n\nnone 不浮动\n\n\n7.2 浮动的特性\n浮动会使元素脱离“文档流”；（和绝对定位一样）\n\n文档流：我们页面布局排列的时候所在一个层级，所有基础内容的布局全部都是处于这一层级当中\n\n浮动会使元素脱离文档流“半级”（压住属性压不住内容   和绝对定位的区别）\n浮动会使没有设置宽度的元素，由内容来撑开宽度，宽度为父级元素的宽度；（和绝对定位一样）\n浮动会使内联元素重新支持宽高；（和绝对定位一样）\n浮动会使内联元素正常显示padding和margin；（和绝对定位一样）\n\n浮动是针对它的下一个元素生效，对前一个对象无影响；\n\n浮动的停止：1.浮动元素遇到父级的边界会停止；2.浮动元素碰到相同浮动方向的元素\n\n可以设置clear属性来清除浮动\n\n\n7.3 清除浮动1.在浮动元素的下一个元素设置clear属性\n\nclear: 属性\n\nleft 清除左浮动\nright 清除右浮动\nboth 清除左右俩边的浮动\nnone 不清除浮动\n2.清除浮动第二个方法：\n在要清除浮动的标签加上:after{ } 原因是clear针对浮动元素的下一个元素 在父级后面加一个空的元素并清除他的浮动就可以解决父级塌陷的问题；\n12345.father:after&#123;\tcontent:;\tdisplay:block;\tclear:both;&#125;\n例：\n12345678910111213141516171819202122232425262728&lt;style&gt;\t.father&#123;        width:1000px;        border:5px solid black;\t&#125;    .son_1&#123;        width:200px;        height:200px;        float:left;    &#125;    .son_2&#123;        width:200px;        height:200px;        float:left;    &#125;    .father:after&#123;        content;        display:block;        clear:both;    &#125;&lt;style&gt;&lt;body&gt;    &lt;div class=father&gt;        &lt;div class=son_1&gt;&lt;div&gt;        &lt;div class=son_1&gt;&lt;div&gt;    &lt;div&gt;&lt;body&gt;\n3.其他清除浮动方法：\n\n给父级float:left;  弊端： 会影响后面的元素如：给父级height:500px; 子级高度改变父级也要改变\n\n给父级overflow:hidden; 弊端：不同浏览器会有兼容性问题\n\n给父级display:inline-block; 弊端：改变了父级原本的盒子类型\n\n\n8. Zoom修改页面加载时的倍率；\n为了触发 IE 浏览器的 haslayout 特性；\n9. ! important!important是CSS1就定义的语法，作用是提高指定样式规则的应用优先权。\n\n语法格式 { cssRule !important }，\n\n即写在定义的最后面，例如：\n123456.box&#123;\tcolor:red;!important;&#125;&lt;body&gt;\t&lt;div class=box style=color: blue;&gt;Im a box&lt;div&gt;&lt;!--最终显示的还是红色--&gt;&lt;body&gt;\n在CSS中，通过对某一样式声明! important ，可以更改默认的CSS样式优先级规则，使该条样式属性声明具有最高优先级，也就是相当于写在最下面。\n10. z-index\n作用：设置内容在z轴上的数值,也就是设置元素的层级,这个数值不限制正负，但是负数会导致用户事件无法被传递（所有不要设定为负数）；z-index未设置时  默认为auto\n\n123.box&#123;    z-index: 100;&#125;\n","tags":["css","前端入门"],"path":"2016/03/08/webNotes/primary/CSS/basicCSS/","external_link":""},{"title":"HTML的基本结构","date":"2016-02-08T11:24:45.000Z","content":"1.页面的三要素 页面的结构 HTML\n 页面的样式 CSS\n 页面的行为 JS\n2.HTML的基本结构2.1 最简单的HTML文件\n以下是一个最简单的HTLML文件\n\n12345678910&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;Document&lt;title&gt;&lt;head&gt;&lt;body&gt;    &lt;body&gt;&lt;html&gt;\n2.2 结构说明对其中的各个结构做说明\n(1) 文档头声明文档头声明, 也叫文档类型声明\n\n代码⌨️\n\n1&lt;!DOCTYPE html&gt;\n\n注意⚠️\n\n\n文档头类型的英文缩写非常好记：  DOC + TYPE (document + type)\n不是标签\nhtml 代指 以 HTML5 的标准来解析当前页面\n文档头类型声明一般会放在文档最开始的位置,浏览器的解析方式从上至下,从左至右\n\n(2) &lt;html&gt;标签HTML的根元素\n\n代码⌨️\n\n1&lt;html&gt;&lt;html&gt;\n\n注意⚠️\n\n\nHTML的根元素\n除了文档头声明,其他所有内容都应当放在 HTML 的根元素当中\n\n(3) &lt;head&gt;标签HTML的头部\n\n代码⌨️\n\n1&lt;head&gt;&lt;head&gt;\n\n注意⚠️\n\n\nhead 当中绝大部分内容都是不可见的\nhead 当中主要是用于辅助\n\n(4) &lt;title&gt;标签设置页面的标题\n\n例如\n\n\n\n代码\n\n1&lt;title&gt;&lt;title&gt;\n(5) &lt;meta&gt;标签定义页面的元数据,元数据本身没有任何含义,它的含义是根据后面的属性来决定的\n\n代码\n\n123456&lt;head&gt;&lt;meta name=&quot;description&quot; content=&quot;我的第一个页面&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;HTML,CSS,XML,JavaScript&quot;&gt;&lt;meta name=&quot;author&quot; content=&quot;LinDaiDai&quot;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;head&gt;\n例如属性charset: 规定 HTML 文档的字符编码\n1&lt;meta charset=&quot;UTF-8&quot;&gt;\n表示以UTF-8的字符编码进行解析\n\n注意⚠️\n\n\n&lt;meta&gt;标签通常位于&lt;head&gt;区域内\n元数据通常以 名称值 对出现\n如果没有提供 name 属性，那么名称值对中的名称会采用 http-equiv 属性的值\n\n\n实例\n\n实例 1 - 定义文档关键词，用于搜索引擎：1&lt;meta name=keywords content=HTML, CSS, XML, XHTML, JavaScript&gt;\n实例 2 - 定义web页面描述：1&lt;meta name=description content=Free Web tutorials on HTML and CSS&gt;\n实例 3 - 定义页面作者：1&lt;meta name=author content=Hege Refsnes&gt;\n实例 4 - 每30秒刷新页面：1&lt;meta http-equiv=refresh content=30&gt;\n(6) &lt;body&gt;标签HTML的身体, 用于向页面中展示内容\n\n代码⌨️\n\n1&lt;body&gt;&lt;body&gt;\n\n注意⚠️\n\n\n&lt;body&gt;标签定义文档的主体\n&lt;body&gt;标签包含文档的所有内容(比如文本、超链接、图像、表格和列表等等)\n\n3.HTML的发展史HTML(第一版)\n • 1993年6月，互联网工程工作小组发布 HTML 工作草案\n • 2.0\n • 1995年11月作为 RFC 1866发布\n • 3.2\n • 1996年1月14日由 W3C 发布，是 HTML 文档第一个被广泛使用的标准\n • 4.0\n • 1997年12月18日有 W3C 组织发布，也是 W3C 推荐标准\n • 4.01\n • 1999年12月24日由 W3C 组织发布，是 HTML 文档另一个重要的，广泛使用的标准\n • XHTML 1.0\n • 发布于2000年1月26日，是 W3C组织 的推荐标准，后来经过修订于2002年8月1日才重新发布\n • 拓展的超文本标记语言\n • 更严格，更纯净的 HTML 代码\n • 为什么要被设计出来？\n • HTML 已经发展到一种极度混乱的程度\n • W3C制定了 XHTML ，它的目的是取代 HTML\n • 例子：找一段非常混乱的代码\n • 代码规范\n • 但是后来失败了，没有人喜欢约束\n • “存在即是合理”\n • WHATWG 开始制定一种“妥协式”的\n • web applications 1.0\n • 2008年 W3C 认可 该草案\n • html5\n • 优势\n • 解决跨浏览器的问题\n • 部分替代了原来的 JS\n • 更明确的语义支持\n • 增强了 WEB 应用程序的功能\n4.注释：4.1 注释的作用 解释和说明\n 给开发者看（给人看的）\n4.2 HTML 部分的注释：1234&lt;!-- 需要注释的内容--&gt;&lt;!--第一行第二行--&gt;\n4.3 注释的快捷键1ctrl + \n5.标记以及标签 ：5.1 标记单标记：&lt;&gt;\n如：\n1&lt;img&gt;\n 双标记 &lt;&gt; &lt;&gt;\n如：\n1&lt;div&gt;&lt;div&gt;\n5.2 标签\n将特定的英语单词放入我们的标记中，这样我们的标记就有了特殊的含义，这时候，我们将有含义的标记称之为“标签”。\n\n1.块元素标签div\n 双标签 语义: 无意义;\n h1~h6\n 双标签 语义:一级标题至六级标题;\n 默认样式: margin-top 和 margin-bottom;\n p\n 双标签 语义: 段落;\n 默认样式: \n12margin-top:16px;margin-bottom:16px;\n blockquote\n 双标签 语义: 定义长段的引用;\n 默认样式: \n1234margin-top:16px;margin-bottom:16px;margin-left :40px;margin-right:40px;\n address\n 双标签 语义: 定义地址\n 默认样式:\n1font-style: italic;\nul &gt;li\n 双标签 语义: 定义无序列表;\n 默认样式: \n123margin-top：16px;margin-bottom:16px;padding-left:40px;\n ol &gt;li\n 双标签 语义: 定义有序列表;\n 默认样式: \n123margin-top：16px;margin-bottom:16px;padding-left:40px;\n dl &gt;dd 和 dt 双标签 语义:\n dl: 语义: 定义段落\n 默认样式:\n12margin-top：16px;margin-bottom:16px;\n dt 语义 : 定义标题列表项;\n 默认样式: none ;\n dd: 语义: 定义普通列表项\n dd: 是针对dt的解释和说明\n 默认样式: \n1margin-left；40px;\n::: tip 块元素的特性:\n 1.块元素 默认独占一行;\n 2.块元素 如果没有设置宽度，默认继承父级的宽度\n 3.块元素可以正常的显示margin 和 padding\n 4.块元素 可以设置宽度和高度;\n:::\n2.内联元素标签span\n 双标签 语义 ; 无意义\n 一般使用span来设置某些文字或局部内容的样式;\n em\n 双标签 语义: 强调语气\n 显示方式； 斜体\n strong\n 双标签 语义: 重要的文本 \n 语气强烈程度高于&lt;em&gt;\n 显示方式； 粗体 ;\na\n双标签 语义: 超链接\n 1.属性href\n href=&quot; &quot;: 指定超链接所关联的另一个资源的地址;\n\n作用1:用于和网络上的另一个资源”保持关联”;\n\n\n绝对路径\nhttps:www.baidu.com\nhttpshttp: 超文本传输协议;\n\n相对路径\n\n\nimg1.jpg\n\n物理路径:\nfile:\n\n\n\n作用2:锚点\n\n(例1) \n点击”回到标记处” 回到锚点处   只能作用于id\n12345&lt;a href=#maodian1&gt;&lt;a href=#maodian2&gt;&lt;div id=maodian1&gt;&lt;div id=maodian2&gt;\n点击第一个a标签, 页面则跳到id为maodiao的标签处\n(例2) \n1&lt;a href=# &gt;&lt;a&gt;\n\n地址栏链接污染 会在地址栏的最末尾加上#\n\n会造成点击后刷新网页\n\n\n(例3)\n1&lt;a href=### &gt;&lt;a&gt;\n\n地址栏链接污染 会在地址栏的最末尾加上###\n\n不会造成点击后刷新网页\n\n\n(例4)\n1&lt;a href=javascript:void(0); &gt;&lt;a&gt;\n\n地址栏链接不会污染\n\n不会造成点击后刷新网页\n\n会使浏览器默认记录内容是否被点击过的功能失效\n\n\n 2.属性target \ntarget=&quot;&quot;:指定使用哪种框架去装载新资源\n\n属性值：\n\n\n_self 当前网页进行加载;\n\n_blank 新建页面进行加载;\n\n\n\n例\n\n1&lt;a href=https:www.baidu.com target=_blank&gt;打开百度&lt;a&gt;\n表示点击这个 a标签,则已一个新窗口打开百度首页\n q\n双标签\n语义: 定义短 的引用\n浏览器一般以双引号的方式来显示该内容\n cite\n双标签\n语义: 定义作品的名称 浏览器一般会以斜体的方式来显示该内容\ncode\n双标签\n定义一段计算机代码\npre\n双标签\n语义: 预文本格式化内容\n::: tip 内联元素的特征:\n 内联元素默认会在一行显示，直至一行放不下时才会另起一行;\n 内联元素空格和回车会被解析;\n 内联元素不支持设置宽度和高度; “的；(是由内容来”撑开设置float:left就可以设置宽高)\n 内联元素无法正常的显示margin 和 padding ；(设置float:left就可以设置宽高)\n:::\n3.内联块元素标签img\n单标签 \n语义 定义图片\n\n属性\n\n\nsrc 指定”图片资源文件”所在的地址\n\nalt 指定图片无法正常加载时所提供的用户信息,便于 SEO (搜索引擎) 搜索\n\n\n\n注意⚠️\n\n 会有小间隙 解决 \n12width:100%; height:100%;\n::: tip 内联块元素的特征:\n 1.可以设置宽高\n 2.可以放在同一行显示\n 3.代码换行也会被解析\n:::\n 元素与元素之间会有空白 ： 原因 内联元素空格和回车会被解析\n 解决:\n\n手动把回车空格去掉 \n\n把父级的font-size:0;\n\n\n5.3 写标签的简便方法\n设置3个div :\n\n1div*3 + tab\n123&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;\n\n设置一个div 内 有三个子div:\n\n+tab1div&gt;div*3 + tab\n12345&lt;div&gt;\t&lt;div&gt;&lt;div&gt;\t&lt;div&gt;&lt;div&gt;\t&lt;div&gt;&lt;div&gt;&lt;div&gt;\n\n设置一个div内有 一个子div 和一个 p 标签:\n\n1div&gt;p+div + tab\n1234&lt;div&gt;\t&lt;p&gt;&lt;p&gt;\t&lt;div&gt;&lt;div&gt;&lt;div&gt;\n\n给div 设置一个类名:\n\n1.wrap +tab\n1&lt;div class=wrap&gt;&lt;div&gt;\n\n给 p 设置一个类名 :\n\n1p.p1 +tab\n1&lt;p class=p1&gt;&lt;p&gt;\n\n给一个div 内设置俩个子div 并分别 加上 类名:\n\n1.father&gt;.son1+.son2 +tab\n1234&lt;div class=father&gt;    &lt;div class=son1&gt;&lt;div&gt;    &lt;div class=son2&gt;&lt;div&gt;&lt;div&gt;\n\n设置三个内容相同的div:\n\n1div&#123;我是 div &#125;*3 +tab\n123&lt;div&gt;我是 div &lt;div&gt;&lt;div&gt;我是 div &lt;div&gt;&lt;div&gt;我是 div &lt;div&gt;\n\n设置三个内容依次递增的div :\n\n1div&#123;我是世界第 $ 帅&#125;*3 +tab\n123&lt;div&gt;我是世界第1帅&lt;div&gt;&lt;div&gt;我是世界第2帅&lt;div&gt;&lt;div&gt;我是世界第3帅&lt;div&gt;\n\n设置三个类名依次递增的div:\n\n1.div_$*3 +tab\n123&lt;div class=div_1&gt;&lt;div&gt;&lt;div class=div_2&gt;&lt;div&gt;&lt;div class=div_3&gt;&lt;div&gt;\n\n设置三个ID名依次递增的div:\n\n1#div_$*3 +tab\n123&lt;div id=div_1&gt;&lt;div&gt;&lt;div id=div_2&gt;&lt;div&gt;&lt;div id=div_3&gt;&lt;div&gt;\n\n设置3个href为javascript:; 内容为 百度 的a标签\n\n1a[href=javascript:;]&#123;百度&#125;*3 +tab\n123&lt;a href=javascript:;&gt;百度&lt;a&gt;&lt;a href=javascript:;&gt;百度&lt;a&gt;&lt;a href=javascript:;&gt;百度&lt;a&gt;\n6.标签类型之间的转换在css中使用display属性来进行标签与标签之间的转换\n\ndisplay: 修改当前标签的类型\n\n常用的属性值有：\n\nblock 块元素;\n\ninline 内联元素:\n\ninline-block 内联块元素;\n\nnone 让当前元素完全消失 在布局当中不在占有位置;\n\n\n7.标签之间的嵌套1.块元素\ndiv 里面可以套p 、 p 不能嵌套 div\n\n如以下做法是可以的：\n123&lt;div&gt;\t&lt;p&gt;我是p表签&lt;p&gt;&lt;div&gt;\n以下做法是错误的：\n123&lt;p&gt;\t&lt;div&gt;&lt;div&gt;&lt;p&gt;\n\nh1 ~ h6、 dt 同样不能嵌套其他块元素\n\n2.内联元素\n超链接当中不能嵌套超链接;\n\n如以下做法是错误的：\n123&lt;a&gt;\t&lt;a&gt;&lt;a&gt;&lt;a&gt;\n8.HTML的加载顺序谨记两点：\n从上至下 从左至右\n后加载的内容会覆盖前面加载的内容\n9.前端规范1、所有书写均在英⽂文半⻆角状态下的⼩小写；\n2、id，class必须以字⺟母开头；标签的命名必须以字母、下滑线、$作为开头\n3、所有标签必须闭合；\n4、html标签⽤用tab键缩进；\n5、属性值必须带双引号；\n6、\n7、 css注释 \n8、ul,liol,lidl,dt,dd拥有⽗父⼦子级关系的标签；\n9、p,dt,h标签 ⾥里里⾯面不不能嵌套块属性标签；\n10、a标签不不能嵌套a；\n11、内联标签不不能嵌套块标签；\n10.对seo有意义的标签1.页面的标题title 标签\n1&lt;title&gt;页面标题&lt;title&gt;\n2.页面的关键字\n1&lt;meta name=keywords content=HTML5 &gt;\n3.页面的描述\n1&lt;meta name=description content=LinDaiDai&gt;\n4.h1标签和h2标签\n12&lt;h1&gt;&lt;h1&gt;&lt;h2&gt;&lt;h2&gt;\n5.重要的文本strong标签\n1&lt;strong&gt;&lt;strong&gt;\n6.图片img标签的alt属性\n1&lt;img src=imgimg1.png alt=我是图片1 &gt;\n7.友情链接\n经常看到网页最下面的友情链接\n如w3c的官网下面：\n\n","tags":["Html","前端入门"],"path":"2016/02/08/webNotes/primary/HTML/tag/","external_link":""},{"title":"JQuery of DOM","date":"2016-03-08T11:24:45.000Z","content":"第一章:创建节点#### 1.创建元素节点\n12$body = $(&apos;body&apos;);\t\t\t\t获取body$(&apos;&lt;div&gt;&lt;div&gt;&apos;)\t\t\t\t创建div元素节点\n2.创建文本节点与创建元素节点一样,可以直接把文本内容一并写上\n1$(&apos;&lt;div&gt;我是新创建的元素节点&lt;div&gt;&apos;)\t\t创建有文本内容的元素节点\n3.创建属性节点与创建元素节点一样\n1$(&apos;&lt;div id=&quot;son&quot; class = &quot;father&quot;&gt;&lt;div&gt;\t\t创建带有类名和id的元素节点\n例:点击body 创建带有class 和 id 的div\n12345$body = $(&apos;body&apos;);$body.click(function()&#123;  var div = $(&apos;&lt;div id=&quot;son&quot; class=&quot;father&quot;&gt;新建&lt;div&gt;&apos;);  $body.append(div);&#125;)\n第二章.添加元素节点1.父子之间添加至元素节点\n\n\n选择器\n功能\n\n\n\n\nappend(content)\n向每个匹配的元素内部追加内容\n\n\nappendTo(content)\n把所匹配的元素从开始的位置移到另一个元素里\n\n\n\n注:$(A).append(B)是把B添加到A中,并且是作为最后一个子元素    \n​    $(A).appendTo(B)是把A追加到B中,也是作为最后一个子元素\n\n\n\n选择器\n描述\n\n\n\n\nprepend( )\n向每个匹配的元素内前置内容\n\n\nprependTo( )\n把所有匹配的元素前置到另一个指定的元素集合中\n\n\n\n注:$(A).prepend(B)是把B添加到A中,并且是作为第一个子元素    \n​    $(A).prependTo(B)是把A追加到B中,也是作为第一个子元素\n2.兄弟之间插入元素节点​    \n\n\n\n选择器\n作用\n\n\n\n\n.after(content)\n在匹配元素集合中的每个元素后面插入参数所指定的内容,作为其兄弟节点\n\n\n.before(content)\n据参数设定,在匹配元素的前面插入内容\n\n\n\n注:\n1.都是用来对相对选中元素外部增加相邻的兄弟节点\n2.都可以接收 HTML字符串,DOM元素,元素数组,JQuery对象\n3.都支持多个参数传递,如:after(div1,div2…)\n123例1:在class 名为test的元素后面插入p标签$(&apos;.test&apos;).after(&apos;&lt;p style=&quot;color:red&gt;新插入的p标签&lt;p&gt;&apos;);\n\n\n\n选择器\n作用\n\n\n\n\ninsertBefore\n在目标元素前面插入集合中每个匹配的元素\n\n\ninsertAfter\n在目标元素后面插入集合中每个匹配的元素\n\n\n\n123例1:将p标签插入class名为test的元素后面$(&apos;&lt;p style=&quot;color:red&gt;新插入的p标签&lt;p&gt;&apos;).insetBefore($(&quot;.test&quot;));\n3.添加DOM包裹#####1.wrap( )\n\nwrap(wrappingElement)  或者 wrap(funciton)\n\n\n在集合中匹配的每个元素周围包裹一个HTML结构\n\n123456789101112例1:\t写法一&lt;p&gt;p元素1&lt;p&gt;&lt;p&gt;p元素2&lt;p&gt;$(&apos;p&apos;).wrap(&apos;&lt;div&gt;&lt;div&gt;&apos;)\t\t\t\t给每个p标签都添加一个父元素div包裹层&lt;div&gt;\t&lt;p&gt;p元素1&lt;p&gt;&lt;div&gt;&lt;div&gt;    &lt;p&gt;p元素2&lt;p&gt;&lt;div&gt;\n12345678910例2: 写法二&lt;p&gt;p元素&lt;p&gt;\t\t$(&apos;p&apos;).wrap(function()&#123;\t\t\t\t给p标签添加一个父元素div包裹层,写法不同 \treturn &apos;&lt;div&gt;&lt;div&gt;&apos;;&#125;)\t\t\t\t&lt;div&gt;    &lt;p&gt;p元素&lt;p&gt;\t\t\t\t\t效果相同&lt;div&gt;\n#####2.  wrapAll( )\n\nwrapAll(wrappingElement)  或者 wrapAll(funciton)\n\n\n给集合中匹配的元素,他们的总体添加一个外面包裹HTML结构\n如匹配到的p元素在不同的父级元素中,则会把所有的p标签都提出来并添加到匹配的第一个P元素的父级中\n\n   123456789&lt;p&gt;p标签1&lt;p&gt;&lt;p&gt;p标签2&lt;p&gt;$(&apos;p&apos;).wrapAll(&apos;&lt;div&gt;&lt;div&gt;&apos;)\t给匹配到的所有p标签都添加一个共同的父级元素&lt;div&gt;\t&lt;p&gt;p标签1&lt;p&gt;\t&lt;p&gt;p标签2&lt;p&gt;&lt;div&gt;\n3.wrapInner( )\nwrapInner(wrappingElement)  或者 wrapInner(funciton)\n给匹配到的所有元素的内部添加一个包裹层\n\n123456789101112例1:&lt;div&gt;p元素&lt;div&gt;&lt;div&gt;p元素&lt;div&gt;$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;p&gt;&apos;)&lt;div&gt;    &lt;p&gt;p元素&lt;p&gt;&lt;div&gt;&lt;div&gt;    &lt;p&gt;p元素&lt;p&gt;&lt;div&gt;\n注:若要删除包裹层请参照第三章的删除DOM包裹 unwrap( )\n4.$( )集合对象中添加元素1. add( )\n$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？\njQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中\n\n12345678例1:如在$(&apos;li&apos;)这个以及确定的集合对象中再添加p元素&lt;ul&gt;    &lt;li&gt;list item 1&lt;li&gt;    &lt;li&gt;list item 3&lt;li&gt;&lt;ul&gt;&lt;p&gt;新的p元素&lt;p&gt;$(&apos;li&apos;).add(&apos;p&apos;);\n第三章:删除元素节点1. empty( )\n移除了指定元素中的所有子节点\n不仅移除了子元素(和其他后代元素),同样移除元素里的文本\n\n123456例1:&lt;div class = &quot;father&quot;&gt;&lt;p&gt;王先生&lt;p&gt;&lt;div&gt;使用empty() $(&apos;.father&apos;).empty()输出:&lt;div class = &quot;father&gt;&lt;div&gt;\n2. remove( )\n移除元素自身包过元素内部的一切以及绑定的事件及与该元素相关的jQuery数据\n\n1234567例1:$(&apos;button:first&apos;).on(&apos;click&apos;,funciton()&#123;  $(&apos;.test&apos;).remove();\t\t\t\t\t\t\t点击第一个按钮,移除class名为test的元素&#125;)$(&apos;button:last&apos;).on(&apos;click&apos;,function()&#123;  $(&apos;p&apos;).filter(&quot;contains(&apos;3&apos;)&quot;).remove();\t\t点击第二个按钮,移除内容中有3的p标签&#125;)\n3. detach( )1会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。\n123456789101112131415例1:$(&apos;p&apos;).on(&apos;click&apos;,funciton(e)&#123;  \talert(e.target.innerHTML);\t\t将点击的那个p的内容弹出;&#125;)$(&apos;button:first&apos;).on(&apos;click&apos;,function()&#123;  if(!$(&apos;p&apos;).lenght) return;\t\t去重\t\t\t\t  通过detach方法删除元素  只是页面不可见，但是这个节点还是保存在内存中  数据与事件都不会丢失  p = $(&apos;p&apos;).datech();&#125;)$(&apos;button:last&apos;).on(&apos;click&apos;,function()&#123;  $(&apos;body&apos;).append(p);\t\t\t\t\t\t把p添加到body中,证明事件还是存在的.&#125;)\n4.删除DOM包裹\n.unwrap( )    \n作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。\n\n12345678例1:&lt;div&gt;    &lt;p&gt;p元素&lt;p&gt;&lt;div&gt;$(&apos;p&apos;).unwrap();\t\t\t找到p元素,并调用unwrap() 方法,只删除父辈div&lt;p&gt;p元素&lt;p&gt;\n第四章: 元素节点替换1. replaceWith(newContent)\n用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合\ntarget.replaceWith(newContent);\n\n12345678例1:&lt;div&gt;    &lt;p&gt;第一段&lt;p&gt;    &lt;p&gt;第二段&lt;p&gt;    &lt;p&gt;第三段&lt;p&gt;&lt;div&gt;$(&quot;p:eq(1)&quot;).replaceWith(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;a&gt;&apos;)\t将第二个p标签替换\n2.replaceAll(target);与replaceWith( ) 功能相似,但目标和源相反\nnewContent.replaceAll(target);\n12例1改:$(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;a&gt;&apos;).replaceAll(&quot;p:eq(1)&quot;);\n第五章:元素遍历子元素选择器:\n1$(&quot;div&gt;.box&quot;)\n1. .children( )\njQuery是一个合集对象，所以通过children是匹配合集中每一个元素的所有第一级子元素(即仅父子关系)\n\n12例1:$(#right-well).children().css(color,orange);\t\t匹配id为right-well下的所有子元素\n12345678910111213例2:class名为father的3个div &lt;div class = father&gt;\t&lt;p&gt;p标签&lt;p&gt;&lt;div&gt;&lt;div class = father&gt;\t&lt;p&gt;p标签&lt;p&gt;&lt;div&gt;&lt;div class = father&gt;\t&lt;p&gt;p标签&lt;p&gt;\t&lt;span&gt;span标签&lt;span&gt;&lt;div&gt;$(father).children().css(color,red)\t\t\t\t所有的p标签以及span标签都会被匹配改变颜色\n\nchildren(.selected)内还可以传参\n\n123如例2中,若在最后一步的children()中加入参数$(father).children(:last).css(color,red)\t\t则只匹配到了所有集合中的最后一个元素,即只有span标签会变色\n2. .find( )通过find( )是匹配合集中每一个元素的所有的后代元素(即所有的儿子,孙子元素)\n参数:必需.    target.find(“*”)    所有的后代元素   \n​            target.find(“HTML标签名”)        target中的所有HTML标签名的元素\n​            target.find(“HTML标签名:selected”)        target中的所有HTML标签名的并符合selected的元素;\n12345例:$(&apos;.father&apos;).find(&apos;*&apos;);\t\t\t\t\tclass名为father的所有元素的所有后代元素$(&apos;.father&apos;).find(&apos;li&apos;)\t\t\t\t\tclass名为father的所有元素的所有li标签$(&apos;.father&apos;).find(&apos;li:last&apos;)\t\t\tclass名为father的所有元素的最后一个li标签\n3. .each( )\n.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。\n每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)\n\n注:    \n123each是一个for循环的包装迭代器each通过回调的方式处理，并且会有2个固定的实参，索引与元素,若不用到俩个参数index,element,可不用写each回调方法中的this指向当前迭代的dom元素\n123456789例1:\t\t\t\t\t遍历.father下所有的li元素,给其添加样式\t$(&apos;.father&apos;).children(&apos;li&apos;).each(function(index,element)&#123;\t对所有的.father的子级为li的元素遍历  $(this).on(&apos;mouseover&apos;,function()&#123;\t\t\t\t\t\t给所有li添加mouseover事件    $(this).css(&apos;background&apos;,&apos;red&apos;);  &#125;);  $(this).on(&apos;mouseout&apos;,function()&#123;\t\t\t\t\t\t\t给所有li添加mouseout事件    $(this).css(&apos;background&apos;,&apos;&apos;);  &#125;);&#125;);\n12345678例2:\t\t\t\t\t给所有偶数项的li元素添加样式$(&apos;.father&apos;).children(&apos;li&apos;).each(function(index,element)&#123;\t对所有的.father的子级为li的元素遍历  $(this).on(&apos;mouseover&apos;,function()&#123;\t\t\t\t\t\t给所有li添加mouseover事件   if(index%2)&#123;\t\t\t\t\t\t\t\t\t\t\t\t再次index从0开始,所以index为奇数实际是li项数里的偶数\t\t\t      $(this).css(&apos;background&apos;,&apos;red&apos;);   &#125;  &#125;);&#125;);\n3.查找父级元素\n\n\n方法名\n参数\n起始位置\n遍历目标\n返回值\n\n\n\n\nparent( )\n可选selected\n父元素\n父级元素\n包含零个或一个或多个元素的jquery对象\n\n\nparents( )\n可选selected\n父元素到文档根元素\n所有父级,祖父级元素\n包含零个或一个或多个元素的jquery对象\n\n\nclosest( )\n可选selected\n指定的目标\n所有父级,祖父级元素\n包含零个或一个元素的jquery对象,\n\n\n\n1.parent( )\n某个元素的父元素\n参数,可选        target.parent()    匹配target集合中的所有元素的父元素\n​                target.parent(“selected”)       匹配target集合中的所有元素的并满足selected要求的父元素\n\n1$(&quot;#target1&quot;).parent().css(&quot;background-color&quot;,&quot;red&quot;);\t\t\t\t匹配id为target1的父元素\n1$(&quot;.target1&quot;).parent(&quot;:last&quot;).css(&quot;background-color&quot;,&quot;red&quot;);\t\t匹配所有class名为target1的父级元素集合中的最后一个\n2.parents( )\n .parents( ) 方法,匹配的是所有元素的祖辈元素,查找模式从里向外,包括body html document\n\n3.closest( )\n从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素\n若( )内无参数,则返回document(整个文档)\n\n12例：在div元素中，往上查找所有的li元素，可以这样表达$(&quot;div&quot;).closet(&quot;li&quot;)\n4.查找兄弟元素1.next( )\n取得一个包含匹配的元素集合中每一个元素紧邻的下一个同辈元素的元素集合\n\n1$(&apos;li.test&apos;).next().css(&apos;border&apos;,&apos;1px solid red&apos;);\t\t设置class名为test的li的下一个兄弟元素\n2.prev( )\n取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合\n\n3.siblings( )\n取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合\n\n123$(&quot;button:first&quot;).click(function() &#123;    $(&apos;li.item-2&apos;).siblings().css(&apos;border&apos;,&apos;1px solid red&apos;);\t\t\t选取class名为item-2 的所有兄弟元素,不包裹它自身\t&#125;)\n第六章: 滚动条1234567$(window).scroll(function (event) &#123;     获取窗口的高度    var windowH = $(window).height()     获取滚动条的位置    var WindowScrollTop = $(window).scrollTop()&#125;)\n","tags":["前端进阶","JQuery"],"path":"2016/03/08/webNotes/primary/JQuery/JQuery of DOM/","external_link":""},{"title":"JQuery事件","date":"2016-03-08T11:24:45.000Z","content":"第一章:鼠标事件1. .click( )\n鼠标点击事件\nele.click(function( ){\n})\nclick事件其实是由mousedown于mouseup 2个动作构成，所以点击的动作只有在松手后才触发\n\n12345例1:&lt;div id=&quot;test&quot;&gt;点击触发&lt;div&gt;$(&quot;#test&quot;).click(function() &#123;    this指向 div元素&#125;);\n2. .dbclick( )\n鼠标双击事件,语法与.click( )相同\n与click( ) 的区别,类似于由俩个click( )事件组成,中间间隔的时间由系统设定\n\n3. .mousedown( )\n监听用户鼠标按下的操作\n\n12345例1:&lt;div id=&quot;test&quot;&gt;点击触发&lt;div&gt;$(&quot;#test&quot;).mousedown(function() &#123;    this指向 div元素&#125;);\n4. .mouseup( )\n监听用户鼠标抬起时的操作\n\n5. .mousemove( )\n监听用户鼠标移动时的操作\n\n6. .mouseover( )\n监听用户鼠标移入时的操作(冒泡)\n\n1#绑定的元素触发了mouseover事件后,它会一直向上找父级元素的mouseover事件,如果父级元素也有mouseover事件则会被触发\n7. .mouseout( )\n监听用户鼠标移出时的操作(冒泡)\n\n8. .mouseenter( )\n监听用户鼠标移入时的操作(不冒泡)\n\n1# \t.mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发\n9. .mouseleave( )\n监听用户鼠标移出时的操作(不冒泡)\n\n10. .hover( )\n$(selector).hover(handlerIn, handlerOut)\n在元素上移入移出,打到mouseenter 和 mouseleave 同时使用的效果\n参数:     \n\nhandlerIn(eventObject)：当鼠标指针进入元素时触发执行的事件函数\nhandlerOut(eventObject)：当鼠标指针离开元素时触发执行的事件函数\n\n\n123456789例1:\t\t\t\t\t$(p).hover(\t\t\t\t\t\t\t\t\t\t\t\t\t hover()方法是同时绑定 mouseenter和 mouseleave事件        function() &#123;            $(this).css(background, red);\t\t\t\t\t 我们可以用它来简单地应用在 鼠标在元素上行为        &#125;,        function() &#123;            $(this).css(background, #bbffaa);        &#125;    );\n第二章: 表单事件1. .focusin( )\n当一个元素，或者其内部任何一个元素获得焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作\n冒泡\n\n方法一:    $ele.focusin( handler )    \n​    参数: handler    回调函数\n方法二:  $ele.focusin( [eventData ], handler )\n​    参数:  eventData    数据参数            handler    回调函数\n12345&lt;div id=&quot;test&quot;&gt;点击触发&lt;div&gt;$(&quot;#test&quot;).focusin(function() &#123;    this指向 div元素&#125;);\n2. .focusout( )\n当一个元素，或者其内部任何一个元素失去焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作\n\n\n用法与focusin( ) 相同,冒泡\n\n3. .focus( )\nfocusin( )的不冒泡版\n\n4. .blur( )\nfocusout( )的不冒泡版\n\n5. .change( )\n元素，和元素的值都是可以发生改变的，开发者可以通过change事件去监听这些改变的动作\n\n\n        value( ) 元素发生改变时 ,失去焦点后发生\n         当用户鼠标做出选择时,该事件立即触发\n     当输入框中有发生改变时,失去焦点后发生\n\n1234567891011&lt;select id = &quot;target&quot;&gt;\t\t&lt;option value=&quot;option1&quot; selected=&quot;selected&quot;&gt;Option 1&lt;option&gt;    &lt;option value=&quot;option2&quot;&gt;Option 2&lt;option&gt;&lt;select&gt;&lt;div id = &quot;result&quot;&gt;&lt;div&gt;$(&apos;#target&apos;).change(function(e)&#123;\t\t\t\t\t\t\t\t当选项框发生改变时,在div中输出被选中的选项的值  $(&apos;#result&apos;).html(e.target.value);&#125;)=&gt;\tOption 2\n6. .select( )\n当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。\n$ele.select(eventDate,handler(eventObject));\n参数:    eventDate    数据参数            handler(eventObject)    回调函数\n\n12345监听input元素中value的选中   触发元素的select事件   $(&quot;input&quot;).select(function(e)&#123;       alert(e.target.value)   &#125;)\n7. .submit( )\n监听提交表单事件\n$ele.submit( [eventData ], handler(eventObject) )\n\n具体能触发submit事件的行为：\n\n\n\n\n当某些表单元素获取焦点时，敲击Enter（回车键）\n\n阻止默认行为:\n123456传统的方式是调用事件对象  e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可例:$(&quot;#target&quot;).submit(function(data) &#123;    return false; 阻止默认行为，提交表单&#125;);\n第三章:    键盘事件1.  .keydown( )\n当用户在一个元素上第一次按下键盘上字母键的时候，就会触发它\n\n123456直接绑定事件$elem.keydown( handler(eventObject) )传递参数$elem.keydown( [eventData ], handler(eventObject) )手动触发已绑定的事件$elem.keydown()\n2. .keyup( )\n当用户在一个元素上第一次松手键盘上的键的时候，就会触发它。\n使用方法与keydown是一致的只是触发的条件是方法的\n\n3. keypess( )\n当浏览器捕获键盘输入时,触发它\n\n12345监听键盘按键    获取输入的值    $(&apos;.target1&apos;).keypress(function(e) &#123;        $(&quot;em&quot;).text(e.target.value)    &#125;);\n注:KeyPress主要用来接收字母、数字等ANSI字符，而 KeyDown 和 KeyUP 事件过程可以处理任何不被 KeyPress 识别的击键。诸如：功能键（F1-F12）、编辑键、定位键以及任何这些键和键盘换档键的组合等。    \n第四章: 事件的绑定与解绑1. .on( )\n给元素绑定事件\n\n\n基本用法：.on( events ,[ selector ] ,[ data ] )\n\n12$(&quot;#elem&quot;).click(function()&#123;&#125;)  快捷方式$(&quot;#elem&quot;).on(&apos;click&apos;,function()&#123;&#125;) on方式\n多个事件绑定同一函数\n1$(&quot;#elem&quot;).on(&quot;mouseover mouseout&quot;,function()&#123; &#125;);\n多个事件绑定不同函数\n1234$(&quot;#elem&quot;).on(&#123;    mouseover:function()&#123;&#125;,      mouseout:function()&#123;&#125;&#125;);\n2. .off( )\n卸载事件\n\n123456789101112131415绑定2个事件$(&quot;elem&quot;).on(&quot;mousedown mouseup&quot;,fn)删除一个事件$(&quot;elem&quot;).off(&quot;mousedown&quot;)删除所有事件$(&quot;elem&quot;).off(&quot;mousedown mouseup&quot;)快捷方式删除所有事件，这里不需要传递事件名了，节点上绑定的所有事件讲全部销毁$(&quot;elem&quot;).off()\n3.  event.type\n获取事件的类型\n\n123$(&quot;a&quot;).click(function(event) &#123;  alert(event.type);  &quot;click&quot;事件&#125;);\n4. event.preventDefault( )\n阻止默认行为\n\n1234$(&quot;#content&quot;).click(function(event) &#123;        $(&quot;#msg&quot;).html($(&quot;#msg&quot;).html() + &quot;&lt;p&gt;外层div元素被单击&lt;p&gt;&quot;);        event.stopPropagation(); 阻止事件冒泡      &#125;);\n5. event.currentTarget在事件冒泡过程中的当前DOM元素\n冒泡前的当前触发事件的DOM对象, 等同于this.\n6.trigger\n根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为\n像click  mouseover 等事件需要用户交互才能完成,而trigger能够获取这些事件用以模拟用户交互\n\n1234567891011给class名为son1的元素添加点击事件$(&apos;.son1&apos;).on(&apos;click&apos;,function()&#123;          console.log(&apos;a&apos;);      &#125;);      给class名为son2的元素添加点击事件,触发son1元素的点击事件      $(&apos;.son2).on(&apos;click&apos;,function()&#123;          $(&apos;.son1&apos;).trigger(&apos;click&apos;);      &#125;            =&gt;a\t\t\t点击.son1        =&gt;a\t\t\t点击.son2也可以触发.son1的点击事件\n7.triggerHandler和trigger用法一样,但是也有不同之处\n\ntriggerHandler不会触发浏览器的默认行为，.triggerHandler( “submit” )将不会调用表单上的.submit()\n.trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素\n使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理\n与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler() 返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined\n\n","tags":["前端进阶","JQuery"],"path":"2016/03/08/webNotes/primary/JQuery/JQuery of Event/","external_link":""},{"title":"Ajax实用篇","date":"2016-02-08T11:24:45.000Z","content":"在介绍ajax之前,博主想先介绍一些关于HTTP协议的知识.例如百度的网址: http:www.baidu.com  我们可以看到,在整个域名地址的开头,有一个http协议,类似的还有https协议.\n1.什么是Ajax?Ajax全称:Asynchronous JavaScript+XML\n它不是一个技术,实际上是几种技术的结合,合在一起就成了一个功能强大的新技术.\n主要作用是在无刷新页面的情况下向服务器读取数据,可以应用在用户登入,在线聊天室等地方\n2.编写一个AjaxAjax的核心实际是一个XMLHttpRequest对象,这个对象在目前的所有浏览器都支持，只是IE6 和 IE5的写法不一样而已。既然是一个对象的话,就存在它内置的属性和方法.\n1.创建XMLHttpRequest对象首先,我们要先创建XMLHttpRequest这么一个对象.出于兼容性考虑,为了照顾IE5,6在这呢,我做了一个兼容性的处理1var  xhr = window.XMLHttpRequest ? XMLHttpRequest( ) : ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\nXMLHttpRequest对象实际也是属于window的,所以出于严谨并避免不必要的麻烦,还是window.XMLHttpRequest比较好.XMLHttpRequest()各大浏览器都支持ActiveObject(&quot;Microsoft.XMLHTTP&quot;)是IE5.6的写法\n2.连接到服务器当xhr对象创建完毕之后,我们要使用一个open()的方法来连接到服务器先来看下写法:1xhr.open(&apos;GET&apos;, &apos;msg.txt&apos;, true)\nopen()方法中有3个参数,我们分别来看下什么意思第一个参数:请求方法,一般是get或post第二个参数:请求是url第三个参数:是否为异步,默认true是异步,false是同步\n3.监听请求状态使用onreadystatechange方法,来监听请求状态.请求状态xhr.readyState的值保存了xhr的状态然而xhr一共有5种状态,分别是:\n\n0    未初始化。对象new出来了，但是还没有调用open方法\n1    启动。 已经调用open，但是还没有调用send方法\n2    发送。 已经send方法，但是还没有接收到相应\n3    接收。 已经开始接收数据，但是还没有完全接收。\n4    完成。 已经完全接收数据。我们主要监听的的第5种状态,也就是完全接收数据的状态.注:xhr.readyState==4只是表示接收数据完成,可以对数据进行处理了,此时还得再做一个判断看看服务器是否响应成功,也就是判断xhr.status是否为200,200表示成功,304虽然也表示成功,但是有缓存.\n\n12345678910xhr.onreadystatechange=function()&#123;            if(xhr.readyState==4)&#123;                if(xhr.status==200||xhr.status==304)&#123;                    onSuccess(xhr.responseText);                &#125;else&#123;                    if(typeof onFail==&quot;function&quot;)&#123;                        onFail(xhr.status);                    &#125;                &#125;            &#125;\nxhr.responseText指的是ajax向服务器请求之后返回的请求结果.\n4.发送请求使用xhr.send()方法来向服务器发送请求send()方法内也可以传递参数,当使用get请求时,只要传递null就行了(若是使用post请求方式的时候,()内可以传入一个数据参数data,后面会提到)1xhr.send(null)\n通过以上四个步骤,我们已经会简单的使用ajax,但是在实际运用中,不可能要用到ajax的时候就再写一遍,那样很没有效率,所以我们可以将整段ajax代码封装到一个js代码中,在我们每次要用到ajax的时候,只需要调用这段js代码就可以了.如下,我将以上的四个步骤封装到了一个myAjax对象中,这个对象中提供了俩个方法,一个是针对get调用,一个是针对post调用,俩个方法异曲同工,只不过在参数的使用上有一些的不同.具体代码如下:文件名:    myAjax.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var myAjax = &#123;    **     * 负责get请求     * @param url      url地址     * @param onSuccess ajax请求成功时候的回调     * @param onFail    ajax请求失败时候的回调     *    get:function (url,onSuccess,onFail) &#123;        if(!(typeof onSuccess==&quot;function&quot;)) return;        var xhr = XMLHttpRequest ? new XMLHttpRequest():new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);        xhr.open(&apos;GET&apos;,url);        xhr.onreadystatechange=function()&#123;            if(xhr.readyState==4)&#123;                if(xhr.status==200||xhr.status==304)&#123;                    onSuccess(xhr.responseText);                &#125;else&#123;                    if(typeof onFail==&quot;function&quot;)&#123;                        onFail(xhr.status);                    &#125;                &#125;            &#125;        &#125;;        xhr.send(null);    &#125;,    **     * 负责get请求     * @param url      url地址     * @param data     请求的数据     * @param onSuccess ajax请求成功时候的回调     * @param onFail    ajax请求失败时候的回调     *    post:function (url,data,onSuccess,onFail) &#123;\t\t if(!(typeof onSuccess==&quot;function&quot;)) return;        var xhr = XMLHttpRequest ? new XMLHttpRequest():new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);        xhr.open(&apos;POST&apos;,url);        xhr.onreadystatechange=function()&#123;            if(xhr.readyState==4)&#123;                if(xhr.status==200||xhr.status==304)&#123;                    onSuccess(xhr.responseText);                &#125;else&#123;                    if(typeof onFail==&quot;function&quot;)&#123;                        onFail(xhr.status);                    &#125;                &#125;            &#125;        &#125;;        在发送请求之前必须添加这个请求头,表示表单数据进行url编码        xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;applicationx-www-form-urlencoded&apos;);        xhr.send(data);    &#125;    &#125;&#125;;\n这样当我们要用到ajax对象的时候,引用这段js代码就ok了.例:编写一个剪短的登入程序,当用户输入的用户名和密码和后台设置的一样,即显示登入成功.1234567891011121314151617181920212223242526272829303132333435361.编写一段php代码:文件名:    data.php&lt;?php$name = $_POST[&quot;name&quot;];$age = $_POST[&quot;pwd&quot;];header(&apos;Content-type:texthtml; charset=&quot;UTF-8&quot;&apos;);header(&quot;Access-Control-Allow-Origin:*&quot;);if($name == &quot;李四&quot;&amp;&amp;$pwd==&quot;123456&quot;)&#123;    echo $name . &quot;登入成功&quot; ;&#125;else&#123;    echo $name . &quot;登入失败&quot;;&#125;?&gt;2.HTML代码&lt;form action=&quot;data2.php&quot; method=&quot;post&quot; id=&quot;form1&quot; enctype=&quot;applicationx-www-form-urlencoded&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;pwd&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;form&gt;3.引入ajax.js并编写js代码&lt;script type=&quot;textjavascript&quot; src=&quot;myAjax.js&quot;&gt;&lt;script&gt;&lt;script&gt;    var form1 = document.querySelector(&apos;#form1&apos;);    form1.onsubmit=function (e) &#123;        e.preventDefault();阻止事件默认行为        var msg = &quot;name=&quot; + this.name.value+&apos;&amp;age=&quot;+this.age.value;        myAjax.post(&apos;data2.php&apos;,msg,function (result) &#123;            console.log(result);        &#125;)    &#125;&lt;script&gt;\n同源通过博主上面的描述,相信大家对ajax都有了一定的了解,那么ajax这么牛能够使Web页面不用打断交互流程进行重新加载，就可以动态地更新,就没有什么限制吗?答案是有的,ajax访问网页的时候,ajax的地址,必须和当前页面同源,否则ajax就不能访问.那么这里就要介绍一下同源.在页面的地址栏里,我们经常可以看到我们输入的地址,都有一些相似之处,简单来说,一个网页的地址主要有这样几个组成部分:协议:域名:端口号资源路径?查询参数https:www.baidu.coms?ie=UTF-8&amp;wd=王那么只要俩个网址的 协议  域名  端口号  三个部分相同,这俩个网址就同源.如:同源​ http:www.baidu.com​ http:www.baidu.comabca.html​    不同源:​ http:www.baidu.com​ https:www.baidu.comabca.html\n不受同源策略的影响有:\n1.img标签加载图片\n2.script标签加载js文件\n打破同源现在主要是用俩种方式来打破同源,一直是利用jsonp,还有一种是服务器打破同源\n1.jsonpjsonp:  json padding的简称,实际就是把json数据伪造为一个合理的js代码.我们在正常读取json数据,得通过ajax来从服务器读取,但对于一些不同源的json数据,我们就无法正常读取,所以这时可以采用一个投机取巧的办法吧,就是把json数据伪造为一个合理的js代码,这样就能通过调用js代码来成功读取json数据,如看下面的例子:123456789101112&lt;script&gt;function foo(obj)&#123;  console.log(obj)&#125;&lt;script&gt;&lt;script type= &quot;textscript&quot; src= &quot;data.json&quot;&gt;&lt;script&gt;data.json:foo(&#123;  name:&apos;王先生&apos;&#125;)\n将json数据用一个foo的函数封装起来,只要在要读取json数据的时候将json文件用script标签来引用,并通过foo函数调用就可以了.\n2.服务器打破同源就像前面说的,判断是否同源只要看协议域名端口号三个地方相同不相同,要是相同的话就是同源,我们的ajax就可以访问到.那么如果我们将服务器端口设置一下,也就是直接在我们的php文件中修改123在php文件的判断之前加上: *代表的就是所有域名都可以访问header(&quot;Access-Control-Allow-Origin:*&quot;);\nencodeURIComponent编码其实每个汉字都有对应的URI编码,window提供了一个全局的方法encodeURIcomponent(),将中文转换为URI编码一个中文由3个%号组成,如:123var name = encodeURIComponent(&apos;李四&apos;);console.log(name);=&gt;%E6%9D%8E%E5%9B%9B\n后文Ajax实际就是通过get或者post方法在js中从php文件或者json文件读取到数据,然后在js中对这些数据进行操作.在实际的开发中,我们看到页面上的很多图片信息或者产品信息,都是通过Ajax读取数据然后添加到页面中.另外,要是有小伙学过JQuery的话,会知道JQuery有它内置的Ajax,我们可以直接利用$.get(url,function(result){ })来读取数据.\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/ajax/","external_link":""},{"title":"DOM基础","date":"2016-02-08T11:24:45.000Z","content":"第一章:DOM概述1.1DOM以及节点概念​    \n文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。\n​    DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。\n​    \n​    HTML文档可以说由节点构成的集合，DOM节点有:\n\n元素节点：上图中、、等都是元素节点，即标签。\n​\n\n文本节点:向用户展示的内容，如…中的JavaScript、DOM、CSS等文本,即标签内部的纯文本.\n​\n\n属性节点:元素属性，如标签的链接属性href=”http:www.imooc.com&quot;,即标签的属性.\n\n\n document节点是每个文档的根节点\ndocument节点下面只有一个 html节点，我们称之为文档元素。\n(documentElement)文档元素是文档的最外层元素，其他元素都包含在文档元素中。\n一个文档只能有一个文档元素，在html中文档元素永远是 &lt;html&gt;元素。\n在DOM树中，html文档中每一处标记都可以用树中的一个节点来表示。\nhtml(元素)标签，通过元素节点表示属性，通过属性节点来表示文档类型，通过文档类型节点来表示注释，通过注释类型来表示\n1.2节点的属性(特性)每一个节点都有三个特点: \n​    1.nodeName      节点名称(只读)    \n​    2.nodeValue     节点值(设置或返回节点的值)     \n​    3.nodeType      节点类型\n1.nodeName：节点名称(nodeName 始终包含 HTML 元素的大写字母标签名) nodeName 是只读的\n2.元素节点的 nodeName 与标签名相同\n3.属性节点的 nodeName 与属性名相同（元素.getAttributeNode(“属性名”)获取属性节点）4.文本节点的 nodeName 始终是 #text（通过元素的子节点获取）\n5.注释节点的nodeName是#comment（通过元素的子节点获取）\n6.文档节点的 nodeName 始终是 #document\n7.nodeValue：节点值 （设置或返回节点的值）\n8.元素节点的 nodeValue 是 undefined 或 null\n9.属性节点的 nodeValue 是属性值\n10.文本节点的 nodeValue 是文本本身\n11.注释节点的nodeValue是注释里面的内容\n12.文档节点的nodeValue 是null\n13.nodeType：节点类型\n14.元素 element 1\n15.属性 attr 2\n16.文本 text 3\n17.注释 comments 8\n18.文档 document 9\n例:    \n1234567891011121314151617&lt;body&gt;&lt;p id = &quot;p&quot; class = &quot;abc&quot;&gt;您好&lt;p&gt;&lt;script&gt;    var p = document.getElementById(&apos;p&apos;);    p.nodeName      P    p.nodeValue     null    p.nodeType     1     元素节点    var text = p.firstChild;    text.nodeName     #text    text.nodeValue     您好    text.nodeType     3     文本节点    var attrNode = p.getAttributeNode(&quot;id&quot;);    attrNode.nodeName     id    attrNode.nodeValue     p    attrNode.nodeType     2     属性节点 &lt;script&gt; &lt;body&gt;\n第二章:document对象2.1获取节点1.getElementById(‘id名’)​    根据元素的id名来获取节点\n​    IE5以下不兼容\n 我是span \n\n  \n\nvar box = document.getElementById(‘box’);\n  alert(typeof(box));  \n正常浏览器显示:   [object HTMLDivElement]; \n IE6                      [object]\n2.getElementsByTagName(‘标签名’)​    根据元素的标签名来获取节点.一个文档中可能会存在很多相同的标签名,因此用此方法获取到的是多个element组成的集合\n3.getElementsByName(‘name’)​    根据标签的name属性来获取节点,返回的也是多个element组成的集合;\n​    注:不是所有标签都有name属性,只有 表达标签 才有name属性(切某些低版浏览器不支持)\n4.querySelector(‘css选择器’)​    参数:指定一个或多个匹配元素的css选择器.可以用id, 类, 类型,属性,属性值等来选取元素.\n对于多个选择器,使用逗号隔开,返回一个匹配的元素,\n返回值:匹配指定css选择器的第一个元素, 若没找到,返回null.\ndocument.querySelector   获取第一个      \n var p = document.querySelector(“#box &gt; p”); box 这个 id 下的 p标签       \nconsole.log(p);\n=&gt;abc  \n5.querySelectorAll(‘css选择器’)​    获取满足选择器里的所有标签\n6.documentElement(元素)\ndocumentElement 属性以一个元素对象返回一个文档的文档元素。HTML 文档返回对象为 HTML元素。\n\n1234567&lt;body&gt;    &lt;script type=&quot;textjavascript&quot;&gt;        alert(document.documentElement.nodeName);     html        alert(document.documentElement.nodeValue);     null        alert(document.documentElement.nodeType);     1    &lt;script&gt;&lt;body&gt;\n2.2 Node关系 获取操作1.节点与节点之间的关系父（parent）节点 父节点拥有任意数量的子节点\n子（child）节点 子节点拥有一个父节点\n兄弟（sibling）节点 同级的子节点被称为同胞（兄弟或姐妹）。\n同胞是拥有相同父节点的节点根 (root) 节点 \n一个文档只能有一个根节点。\n对html文档来说，根节点就是documentElement。\n根节点不可能有父节点\n\n2.获取操作12345678910111213141516171819var div = document.querySelector(&quot;div&quot;);var allNodes = div.childNodes;          childNodes会把所有类型节点都获取到,包裹元素节点,文本节点(空格换行符等),属性节点;但主要是为了获取元素节点(nodeType为1)方法1:for( var c in allNode)&#123;if( c.nodeType ==1)&#123;document.write(c)&#125;&#125;方法2:var allNodes = div.children;          div的所有子节点(只有元素节点,不包裹文本等其他节点)var count = div.childElementCount;     div的所有子节点的个数 ,也可以之间用 allNodes.length;var firstChild = div.firstElementChild;     div的第一个元素节点var lastChild = div.lastElementChild;          div的最后一个元素节点var secondChild = div.firstElementChild.nextElementSibling;     div的第二个元素节点var lastSecondChild = div.lastElementChild.previousElementSibling;     div的倒数第二个元素节点div == div.firstElementChild.parentNode;                              div的第一个元素节点的父节点就是div本身注:若把 children 换为childNodes 以及把后面全部的Element去掉,则会选取所有类型的节点\n3.创建修改操作3.1 createTextNode( )​        创建文本节点\n​    var text = document.createTextNode(&quot;这个是文本节点&quot;);\n3.2 createElement( )​        创建元素节点    \n​        可以是 div  p   span  ul  li 等\n​    var ele = document.createElement(&quot;div&quot;);\n3.3 appendChild( )​    给一个元素追加child节点\n​    document.body.appendChild(ele); 添加到body的最后一个子节点之后;\n3.4 insertBefore( )​    fatherNode.insertBefore(newNode, existingNode);\n​    参数:    1.要插入的节点    2.目标节点\n​    在一个节点前插入一个节点\n将一个新创建的元素插入到某个元素之前\n如:在ul中,有3个li ,要将新创建的一个li 插入到第一位,\n     ul.insertBefore(li,ul.firstElementChild);\n   将li 插入到最后一位:\n     1.ul.appendChild(li);\n     2.ul.insertBefore(li,nullundefined);            \n3.5 removeChild( )​    移除子节点\n​    fatherNode.removeChild(node)\n3.6 replaceChild( )​    fatherNode.replaceChild(newNode,existingNode)\n​    替换子节点\n3.7 cloneNode( )​    node.cloneNode(deep)\n​    克隆节点\n​    参数 deep 可以指定节点的精确克隆\n​        1.若不写参数,只拷贝当前的这个元素节点,不包过它的子节点\n​        2.参数为 true ,它还将递归复制当前节点的所有子孙节点.    \n4.元素属性操作##### 4.1 getAttribute( ):获取属性值\n\n\n\n&lt;ul id = &quot;abc&quot; class = &quot;one&quot;&gt;\n如 获取 ul 的 id \n     console.log(ul.getAttribute(&quot;id&quot;));\n =&gt; abc\n##### 4.2 setAttribute( ):\n添加或设置属性值\n      1.如将 ul 的 id 名更换  \n          div.setAttribute(&quot;id&quot; , &quot;box&quot;)\n          ul 的 id 变为 box \n      2.将 ul 的class 再添加俩个类名\n           div.setAttribute(&quot;class&quot; , div.getAttribute(&quot;class&quot;) + &quot; two&quot;);\n##### 4.3 removeAttribute( )\n​    element.removeAttribute(attributename)\n​    参数：必需。规定要删除的属性的名称\n​    例: 一个可以转换形态的按钮\n&lt;body&gt;  \n&lt;input id=&quot;input1&quot; type=&quot;button&quot; value=&quot;点我可以转换我的状态&quot; onclick=&quot;myFunction();&quot;&gt;\n&lt;script&gt;\n    function myFunction() {            \n        var input1 = document.getElementById(&quot;input1&quot;);\n        var typeValue = input1.getAttribute(&quot;type&quot;);\n        if(typeValue){\n            input1.removeAttribute(&quot;type&quot;);    如果type属性有值就把这个属性去掉\n        }else {\n            input1.setAttribute(&quot;type&quot;, &quot;button&quot;);    如果type属性不存就添加属性。\n        }\n    };\n&lt;script&gt;   \n&lt;body&gt;\n4.4 hasAttribute( )​    element.hasAttribute(attributename)\n​    参数：必须。判断指定的属性名是否存在。\n5.元素节点的常用属性5.1 基本属性​    div.nodeName   所有节点都有\n​    div.tagName     只针对元素节点\n​    div.id           获取id\n​    div.id = “abc”    增加替换 id\n​    div.className = “one”    增加替换 class\n​    checked 属性     表单标签特有的\n5.2 innerHTML属性​    innerHTML 属性设置或返回标签的开始和结束标签之间的 HTML。\n​    值为为文本    \n​    若要改变innerHTML(要改变的值一定要放在.innerHTML之后); \n12345var num =5;  num=&quot;我是字符串&quot;;   num=true;var span = document.getElementById(&apos;span&apos;).innerHTML=num;     正确写法alert(typeof(span));     num是什么属性或者赋值给它的是什么属性, span就是什么属性;var span = document.getElementById(&apos;span&apos;).innerHTML;span = num;                                                  错误写法\n1234567891.利用innerHTML 获取标签内的所有内容,返回一个字符串alert(box.innerHTML); 获取这个元素节点里的文本(包含HTML标签),类型为string正常浏览器显示:    &lt;span&gt;我是span&lt;span&gt;IE                 &lt;SPAN&gt;我是span&lt;SPAN&gt;2.利用innerHTML 设置一个字符串,会把字符串中的有效的标签解析出来.  如,给div标签中添加一个内容是 &quot;abc&quot; 的p 标签        var div = document.querySelector(div);        div.innerHTML = &quot;&lt;p&gt;abc&lt;p&gt;&quot;;\n​    \n5.3 innerText属性​    1.innerText值获取标签中的文本内容，子标签本身不会获取到。\n​    2.去修改的时候，即使带有标签也会把标签作为纯文本来对待，而不会解析为标签\n​    注:和innerHTML不同,它并不会解析有效的标签,而是把它作为纯文本对待\n5.4 outerHTML​    1.读取值 把包过标签自身和它里面的内容都获取到    \n​    2.设置值 把标签用字符串来替换掉,如果字符串中有有效的标签,会被解析.\n​    注:和innerHTML不同,它可以读取包过标签自身\n5.5 value​        如果一个标签可以拥有value值，则可以可以通过element.value来获取。\n​        一般表单数据才具有vlaue：input、textarea、select\n5.6 获取元素的属性(offset)​    注: 以下四个属性只能读取 不能对元素进行修改;\n​    1.offsetWidth      获取元素的实际宽度    包含border 和 padding 在内\n​    2.offsetHeight     获取元素的实际高度    包含border 和 padding 在内\n​    3.offsetLeft         元素定位之后相对于参照物父容器的偏移\n​    4.offsetTop         元素定位之后相对于参照物父容器的偏移\n​    \n6.样式表的属性–css脚本化6.1 获取和修改行内样式表​    2种方式访问到行内样式:\n​        1.element.style.css属性名    \n​           2.element.style[“css属性名”]\n6.2 获取内部样式表和外部样式表​    1.对于IE: 对象.currentStyle[“属性名”]     \n​        2.其他浏览器: window.getComputedStyle(对象,null)[“属性名”]\n6.3 字符串模板字符串${变量}\n12345element.style.backgroundColor = `rgba(         $&#123;randomInt(0,255)&#125;,       $&#123;randomInt(0,255)&#125;,       $&#123;randomInt(0,255)&#125;,       $&#123;Math.random()*0.+0.4&#125;`;\n​\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/basicOfDOM/","external_link":""},{"title":"Event事件对象基础","date":"2016-02-08T11:24:45.000Z","content":"事件对象第一章: DOM2事件1.addEventListener()\n​    语法:    element.addEventListener( event,function(){ },boolean);\n\n​    参数1:    必写    要添加的事件        这里直接用” “或者 ‘ ‘ 将事件名添加进去就行, 如  ‘click’    ‘mouseover’    等等.\n​    参数2:     必写    事件处理程序的函数        \n​    参数3:    可选    truefalse    true : 捕获    false不写: 冒泡(默认)\n如给按钮添加click事件,以下三个例题效果相同\n把事件名和函数都写在DOM2内:\n例1:\n123btn.addEventListener(&apos;click&apos;, function( )&#123;\t\t\tconsole.log(&apos;click  1&apos;);&#125;)\n也可以把函数写在DOM2事件外面, 并在DOM2内引用:\n如例2:\n1234\tfunction foo()&#123;\t\tconsole.log(&apos;click  1&apos;);&#125;\tbtn.addEventListener(&apos;click&apos;, foo );\n函数在外声明,并在DOM2事件内部赋值:    \n如例3:\n1234\tvar foo;\tbtn.addEventListener(&apos;click&apos;, foo = function( )&#123;\t\t\t\tconsole.log(&apos;click  1&apos;);&#125;)\n2.removeEventListener()​    移除事件\n​    语法以及参数和addEventListener相同\n​    但要移除的事件,它的事件处理程序的函数名必须相同\n​    \n第二章:event​    \n\n\n\n属性方法\n类型\n说明\n\n\n\n\ntype\nstring\n被触发的事件类型\n\n\ntarget\nelement\n指的是目标元素,最内层元素\n\n\ncurrentTarget\nelement\n其事件处理程序当前正在处理事件的那个元素(注册事件处理程序的元素)\n\n\nbubbles\nboolean\n事件是否冒泡\n\n\neventPhase\ninteger\n得到事件所处的阶段,1:捕获 2:目标节点 3:冒泡\n\n\nstopPropagation\nFunction\n取消事件的进一步向其他元素节点捕获或者冒泡\n\n\nstopImmediatePropagation\nFunction\n立即停止传播,效果和stopPropagation一样,但它也会取消同一元素的其他监听器捕获或冒泡\n\n\npreventDefault\nFunction\n取消事件的默认行为(如阻止submit事件的提交行为)\n\n\ncancelable\nBoolean\n表明是否可以取消事件的默认行为\n\n\ndefaultPrevented\nBoolean\n表明是否调用了preventDefault事件,即是否取消了事件的默认行为\n\n\n\n\n\n\n\n\n\n\n\n\n实例:\n123&lt;div class=div&gt;\t\t\t\t\t给div添加样式: width:100px;height:100px;background:red;    &lt;button class=btn&gt;点击&lt;button&gt;&lt;div&gt;\n1.type:\n被触发的事件类型\n\n返回类型string\n123456var div = document.querySelector(.div);var btn = document.querySelector(.btn);    btn.addEventListener(click,function(event)&#123;        console.log(btn事件);       btn事件        console.log(event.type);      click    &#125;)\n2.target 和 currentTarget :\n指的是目标元素,最内层元素\n\n 返回的是整个元素\n12345678div.addEventListener(click,function(event)&#123;\t给div添加点击事件    console.log(event.target);      \tconsole.log(event.currentTarget);\t&#125;)若点击的是div,没点在按钮上 ,俩个返回的都是 &lt;div&gt;..&lt;div&gt;若点击的是按钮:  \t\t\ttarget\t&lt;button class=btn&gt;点击&lt;button&gt;返回的是div的最内层元素btn            currentTarget\t&lt;div&gt;..&lt;div&gt; 返回的是当前正在处理的元素,也就是add前面的元素\n3.bubble:\n是否是冒泡事件\n\n返回布尔类型,是否是冒泡事件\n123456btn.addEventListener(click,function(event)&#123;  console.log(event.bubble);\ttrue;\t\t\tclick事件是冒泡事件,所有返回true;\t&#125;)btn.addEventListener(mouseenter,function(event)&#123;  console.log(event.bubble);\tfalse;&#125;)\n4.stopPropagation:一个方法   event.stopPropagation( );\n\n取消事件的进一步向其他元素节点捕获或者冒泡\n\n1234567891011例1:btn.addEventListener(click,function(event)&#123;   console.log(btn);\t   event.stopPropagation();\t\t\t\t给按钮添加&#125;)div.addEventListener(click,function(event)&#123; \t\t给div添加第一个点击事件   console.log(div1);\t\t\t\t\t&#125;)div.addEventListener(click,function(event)&#123;\t\t给div添加第二个点击事件   console.log(div2);\t\t\t\t&#125;)\n\n\n\n事件类型\n事件元素\n是否添加event.stopPropagation();\n返回值\n\n\n\n\n点击\nbtn\n是\nbtn\n\n\n点击\ndiv\n\ndiv1  div2\n\n\n\n1234567891011例2:btn.addEventListener(click,function(event)&#123;   console.log(btn);\t&#125;)div.addEventListener(click,function(event)&#123;\t\t给div添加第一个点击事件   console.log(div);\t   event.stopPropagation();\t\t\t\t给div添加&#125;)div.addEventListener(click,function(event)&#123;\t\t给div添加第二个点击事件   console.log(div2);\t\t\t\t&#125;)\n\n\n\n事件类型\n事件元素\n是否添加event.stopPropagation();\n返回值\n\n\n\n\n点击\nbtn\n\nbtn   div1  div2\n\n\n点击\ndiv\n是\ndiv1  div2\n\n\n\n5.stopImmediatePropagation一个方法   event.stopImmediatePropagation( );\n\n立即停止传播,效果和stopPropagation一样,但它也会取消同一元素的其他监听器捕获或冒泡\n\n1234567891011例3:btn.addEventListener(click,function(event)&#123;   console.log(btn);\t&#125;)div.addEventListener(click,function(event)&#123; \t\t给div添加第一个点击事件   console.log(div1);\t   event.stopImmediatePropagation();\t\t\t\t&#125;)div.addEventListener(click,function(event)&#123;\t\t给div添加第二个点击事件   console.log(div2);\t\t\t\t&#125;)\n\n\n\n事件类型\n事件元素\n是否添加event.stopImmediatePropagation()\n返回值\n\n\n\n\n点击\nbtn\n\nbtn div1\n\n\n点击\ndiv\n是\ndiv1\n\n\n\n可以看到例2和例3中,同样是给div 和 btn 添加相同的事件,但event事件的类型不同,\n例2中的stopProgation( ) 只能阻止它传播给给其他元素节点捕获或者冒泡,对于自身元素要还有其他的监听事件则不能阻止\n例3中的stopImmediatePropagation( ) 既可以阻止前者,也能阻止后者;\n6.preventDefault一个方法 event.preventDefault( );\n\n取消事件的默认行为(如阻止submit事件的提交行为)\n\n123456789&lt;form action=http:www.baidu.com&gt;    &lt;input type=text name=user&gt;    &lt;input type=submit value=提交&gt;&lt;form&gt;&lt;script&gt;\tvar form = document.querySelector(form);    form.addEventListener(submit, function (event)&#123;        event.preventDefault();   阻止默认行为\t点击按钮,不能提交    &#125;);\n若没有event.preventDefault( );     点击提交按钮,网页则会跳转到百度首页\n7.cancelable\n表明是否可以取消事件的默认行为\n\n返回布尔类型\n8.defaultPrevented\n表明是否调用了preventDefault事件,即是否取消了事件的默认行为\n\n返回布尔类型\n9.事件的触发可以在一个定时器内放入点击事件,从而达到模拟用户点击按钮\n的效果\n1234567btn.onclick = function (e)&#123;        console.log(&quot;click...&quot;);        console.log(e.isTrusted);    &#125;    setInterval(function ()&#123;        btn.click();   模拟用户的点击    &#125;, 500)\n第三章:event事件的高级属性1.offsetX和offsetY\n​    光标相对于触发元素边界的X、Y坐标\n​    其实是光标相对于触发元素的==左上角==的坐标。(把左上角的位置看做0，0)\n\n2.screenX和screenY\n​    当前光标相对于屏幕边缘的x、y坐标\n​    其实就是相对于屏幕左上角的坐标。(可以看出是绝对坐标)\n\n3.clientX和clientY\n当前光标相对于浏览器浏览器窗口客户区域左上角的坐标(客户区域不包括状态栏、菜单栏等。)\n\n\n第四章: 事件代理(委托)\n​    事件委托的原理：\n\n 假设现在要处理多个具有并列关系元素的click事件，当我点击这些元素中的任何一个元素，则事件一定会通过冒泡的方式，冒泡到他的上层的父节点元素然后一直冒到window，所以这个时候我们就可以在他的上层元素中添加事件处理程序，来统一处理这些事件，在处理的过程中可以通过获取target的id来知道是点击的哪个具体的元素。这种方式就称之为事件委托。\n123456789101112131415161718192021222324&lt;ul id=item&gt;    &lt;li id=item1&gt;1&lt;li&gt;    &lt;li id=item2&gt;2&lt;li&gt;    &lt;li id=item3&gt;3&lt;li&gt;    &lt;li id=item4&gt;4&lt;li&gt;&lt;ul&gt;&lt;script&gt;    item.onclick=function(e)&#123;        switch (e.target.id)&#123;\t\t\t\t\t\t使用target来获取目标元素,也就是点击的那个li 并通过id来判断            case item1:                console.log(你点击了第一个li);                break;            case item2:                console.log(你点击了第二个li);                break;            case item3:                console.log(你点击了第三个li);                break;            case item4:                console.log(你点击了第四个li);                break;        &#125;    &#125;&lt;script&gt;\n\n注:\n\n完全可以考虑给document添加一个事件处理程序，用来处理页面上发生的某种特定类型的事件。\n比较适合事件委托的事件：click 、 mousedown 、 mouseup 、 keydown 、 keyup 和 keypress;\n\n\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/basicOfEvent/","external_link":""},{"title":"JS中常见的几种轮播","date":"2016-02-08T11:24:45.000Z","content":"轮播图1.无缝不停轮播​1. body布局:\n123456789&lt;div class=container&gt;\t\t\t\t\t\t将ul和li包住,起显示图片的作用       &lt;ul&gt;\t\t\t\t\t\t\t\t\t           &lt;li&gt;&lt;img src=img1.png&gt;&lt;li&gt;           &lt;li&gt;&lt;img src=img2.png&gt;&lt;li&gt;           &lt;li&gt;&lt;img src=img3.png&gt;&lt;li&gt;           &lt;li&gt;&lt;img src=img4.png&gt;&lt;li&gt;           &lt;li&gt;&lt;img src=img5.png&gt;&lt;li&gt;       &lt;ul&gt;   &lt;div&gt;\n​    2. css样式:\n12345678910111213141516171819202122232425262728&lt;style&gt;       *&#123;           margin: 0;           padding: 0;       &#125;       .container&#123;           position: relative;\t\t给要动的元素也就是ul 它的父级加上相对定位           width: 600px;\t\t\t           height: 400px;           overflow: hidden;\t\t给要动的元素也就是ul 它的父级加上溢出隐藏       &#125;       .container &gt; ul&#123;           position: absolute;\t\t给要动的元素也就是ul 加上绝对定位,才能保证用left和top;           width: 3000px;\t\t\tul 的宽度为 li 的个数 * li 的宽度           height:100%;           list-style: none;       &#125;       .container &gt; ul &gt;li&#123;           float: left;\t           width: 600px;           height: 100%;       &#125;       .container &gt; ul &gt;li img&#123;           width: 100%;           height: 100%;       &#125;   &lt;style&gt;\n3. JS代码:\n1234567891011var ul = document.querySelector(.container &gt; ul);\t 获取ul        setTimeout(function step()&#123;\t\t\t\t\t设置定时器             if(ul.offsetLeft&lt;=-2400)&#123;\t\t\t\t判断:若ul走到倒数第二张图的时候,让left从0开始运行                ul.style.left=0+px;            &#125;else&#123;                var left = ul.offsetLeft -3;\t\t给ul设置速度                ul.style.left=left+px;\t\t\t            &#125;            var time = 10;\t\t\t\t\t\t\t设定一个时间,以控制其轮播的速度            setTimeout(step,time);\t\t\t\t\t定时器内部调用定时器        &#125;,0)\n2.无缝停顿轮播\n停顿轮播在不停轮播的基础上加以改进,判断当ul走到li宽度的倍数时,让定时器的时间加大,就可以起到停顿的效果\n\n​    body布局以及css样式不变\nJS代码:\n12345678910111213141516var ul = document.querySelector(.container &gt; ul);\t 获取ulsetTimeout(function step()&#123;\t\t\t\t\t设置定时器      if(ul.offsetLeft&lt;=-2400)&#123;\t\t\t\t判断:若ul走到倒数第二张图的时候,让left从0开始运行         ul.style.left = 0 +px;     &#125;else&#123;         speed = -3;\t\t给ul设置速度\t\t\t     &#125;     var time;\t\t\t\t     if(ul.offsetLeft%600==0)&#123;\t\t\t\t做判断:当ul走到li宽度的倍数时       time = 3000;\t\t\t\t\t\t\t设定一个很大的时间,也就是很小的速度     &#125;else&#123;\t\t\t\t\t\t\t\t\t       time = 10;     &#125;  \tul.style.left=ul.offsetLeft+speed+px     setTimeout(step,time);\t\t\t\t\t定时器内部调用定时器 &#125;,0)\n3.无缝停顿反向轮播\n反向轮播在停顿轮播的基础上加以改进,判断当ul最左边和ul走到最右边,将速度反向;\n将最后一张重复的li去掉并修改ul的宽度\n\n123456789101112131415var ul = document.querySelector(.container &gt; ul);      var speed = 3;          setTimeout(function step()&#123;             if(ul.offsetLeft&lt;=-1800||ul.offsetLeft&gt;=0)&#123;\t\t判断当ul最左边和ul走到最右边,将速度反向;                  speed*=-1;             &#125;             var time = 0;             if(ul.offsetLeft%600==0)&#123;\t\t\t\t\t做判断:当ul走到li宽度的倍数时        \t\t   time = 3000;\t\t\t\t\t\t\t    设定一个很大的时间,也就是很小的速度             &#125;else&#123;                  time=10;             &#125;             ul.style.left=ul.offsetLeft+speed+px;\t             setTimeout(step,time);\t\t\t\t\t\t定时器内部调用定时器          &#125;,0)\n4. 透明度普通轮播​    1.body布局上一样:\n​    2.css样式\n​    将所有li 绝对定位,重叠在一起\n​    3.JS:    \n​        先获取到ul 和 li   并对 li的数组进行遍历    赋值每个的opacity        \n​        注:要在js中遍历li 再给它赋值opacity,而不是在css中直接设置属性\n​            是为了在js中好获取到opacity并给它进行修改设置                \n123456789101112131415161718192021222324var ul = document.querySelector(&quot;.container &gt; ul&quot;);\t 获取ul        var lis = document.querySelectorAll(&apos;.container &gt; ul &gt;li&apos;);        var i = 0;        for(var i=0;i&lt;lis.length;i++)&#123;            if(i==0)&#123;\t\t\t\t\t默认显示第一张图,让其透明度为1;                lis[i].style.opacity=1;            &#125;else&#123;\t\t\t\t\t\t其他图片透明度为0;                lis[i].style.opacity=0;            &#125;        &#125;        var i=0;\t\t\t\t\t\t重新赋值i         var time = 50;\t\t\t\t\t设置时间,控制图片转换的速度,时间越大,速度越慢        setTimeout(function step()&#123;\t\t\t\t\t设置定时器            lis[i%4].style.opacity-=0.05;\t            lis[(i+1)%4].style.opacity=parseFloat(lis[(i+1)%4].style.opacity)+0.05;            if(lis[i%4].style.opacity==0)&#123;                i++;                time = 1000;            &#125;else&#123;                time =50            &#125;            setTimeout(step,time);        &#125;,0)\n​    \n5.透明度指示器轮播1.body布局:\n12345678910111213141516171819202122232425&lt;body&gt;&lt;div class=container&gt;\t\t\t\t\t\t        &lt;ul id=picture&gt;\t\t\t\t\t\t\t轮播图片区            &lt;li&gt;![](img1.png)&lt;li&gt;            &lt;li&gt;![](img2.png)&lt;li&gt;            &lt;li&gt;![](img3.png)&lt;li&gt;            &lt;li&gt;![](img4.png)&lt;li&gt;            &lt;li&gt;![](img5.png)&lt;li&gt;            &lt;li&gt;![](img6.png)&lt;li&gt;        &lt;ul&gt;        &lt;ul class=arrow&gt;\t\t\t\t\t\t\t左右切换            &lt;li class=arrowLeft&gt;&lt;li&gt;            &lt;li class=arrowRight&gt;&lt;li&gt;        &lt;ul&gt;         &lt;div class=bottom&gt; \t\t\t\t\t\t指示器            &lt;ul&gt;                &lt;li&gt;1&lt;li&gt;                &lt;li&gt;2&lt;li&gt;                &lt;li&gt;3&lt;li&gt;                &lt;li&gt;4&lt;li&gt;                &lt;li&gt;5&lt;li&gt;                &lt;li style=margin:0&gt;6&lt;li&gt;            &lt;ul&gt;          &lt;div&gt;&lt;div&gt;\n2.css样式\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;style&gt;        * &#123;            margin: 0;            padding: 0;        &#125;        .container &#123;\t\t\t\t\t\t整体样式            position: relative;            width: 600px;            height: 400px;            overflow: hidden;            margin: 20px auto;        &#125;        .container &gt; .picture &#123;\t\t\t\t轮播图片区样式            position: absolute;            width: 600px;            height: 100%;            list-style: none;        &#125;        .container &gt; .picture &gt; li &#123;            position: absolute;            width: 600px;            height: 100%;        &#125;        .container &gt; .picture &gt; li img &#123;            width: 100%;            height: 100%;        &#125;        .container &gt; .arrow&#123;\t\t\t\t\t左右切换区样式            position: absolute;            height: 70px;            width: 100%;            top: 40%;            left: 0;            list-style: none;        &#125;        .container &gt; .arrow &gt; li &#123;            width: 40px;            height: 70px;            padding: 0;            margin: 0;            cursor: pointer;        &#125;        .container &gt; .arrow &gt; li:nth-child(1) &#123;            float: left;            background: url(imgarrow_left1.png);        &#125;        .container &gt; .arrow &gt; li:nth-child(2) &#123;            float: right;            background: url(imgarrow_right1.png);        &#125;        .container &gt; .arrow &gt; li:nth-child(1):hover &#123;            background: url(imgarrow_left2.png);        &#125;        .container &gt; .arrow &gt; li:nth-child(2):hover &#123;            background: url(imgarrow_right2.png);        &#125;        .container .bottom &#123;\t\t\t\t\t\t\t指示器样式            position: relative;            margin: 0 auto;            width: 215px;            height: 40px;            top: 350px;            border-radius: 20px;            background-color: grey;        &#125;        .container &gt; .bottom &gt; ul&#123;            position: absolute;            height: 30px;            width: 205px;            bottom: 20px;            list-style: none;            top: 5px;            left: 5px;        &#125;        .container &gt; .bottom &gt; ul &gt; li&#123;            float: left;            height: 100%;            width: 30px;            margin: 0 5px 0 0;            padding: 0;            border-radius: 50%;            background-color: white;            font-size: 20px;            line-height: 30px;            text-align: center;            cursor: pointer;        &#125;    &lt;style&gt;\n3.JS代码:    \n​    代码分析:        \n​                1.先进行准备工作,    利用for循环将初始化的图片透明度已经指示器的背景色设定好\n​                2.给整个container添加事件,当鼠标上来的时候,让自动播放停止\n​                3.给左,右”按钮” 点击事件,用以切换上一张下一张图片;\n​                4.给指示器onmouseenter事件,使得图片与你的指示器同步,达到随意切换图片的效果;\n​                5.定义 图片切换的函数 ,使得以上事件都可以调用它\n​                6.定义自动播放的函数\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script&gt;    var container = document.querySelector(.container);    var pictureLis = document.querySelectorAll(.container &gt; .picture &gt; li);    var optionLis = document.querySelectorAll(.container &gt; .bottom &gt;ul &gt; li);    var arrowLeft = document.querySelector(.container .arrow  &gt; .arrowLeft);    var arrowRight = document.querySelector(.container .arrow &gt; .arrowRight);    var showIndex = 0;  当前正在显示的图片的下标    初始化    function init() &#123;        for (var j = 0; j &lt; pictureLis.length; j++) &#123;            if (j == 0) &#123;                optionLis[j].style.backgroundColor=red;                pictureLis[j].style.opacity = 1;            &#125; else &#123;                pictureLis[j].style.opacity = 0;            &#125;        &#125;        给整个container添加事件,当鼠标上来的时候,让自动播放停止        container.onmouseenter = function () &#123;            clearTimeout(autoPlayId);        &#125;;        container.onmouseleave = function () &#123;            auto();        &#125;;        给左按钮和右按钮添加点击事件        arrowLeft.onclick=function()&#123;            optionLis[showIndex % optionLis.length].style.backgroundColor=white;            var preIndex = showIndex-1+pictureLis.length;            move(showIndex,preIndex);            showIndex=preIndex;            optionLis[showIndex%optionLis.length].style.backgroundColor=red;        &#125;;        arrowRight.onclick=function()&#123;            optionLis[showIndex % optionLis.length].style.backgroundColor=white;            move(showIndex,showIndex+1);            showIndex++;            optionLis[showIndex%optionLis.length].style.backgroundColor=red;        &#125;;        给指示器添加onmouseenter事件,使得图片与指示器同步        for(let i=0;i&lt;optionLis.length;i++)&#123;            optionLis[i].onmouseenter=function()&#123;                move(showIndex,i);                optionLis[showIndex%optionLis.length].style.backgroundColor=white;                optionLis[i%optionLis.length].style.backgroundColor=red;                showIndex=i;            &#125;        &#125;    &#125;    init(); 调用初始化        图片移动    function move(showIndex,nextIndex) &#123;        setTimeout(function step() &#123;            pictureLis[showIndex % pictureLis.length].style.opacity -= 0.05;            pictureLis[nextIndex % pictureLis.length].style.opacity =                +pictureLis[nextIndex % pictureLis.length].style.opacity + 0.05;            if (pictureLis[showIndex % pictureLis.length].style.opacity &lt;= 0||pictureLis[nextIndex%pictureLis.length].style.opacity&gt;=1) return;            setTimeout(step, 5)        &#125;, 0)    &#125;    自动播放    var autoPlayId;     自动播放定时器id    function auto() &#123;        autoPlayId = setTimeout(function autoStep() &#123;            optionLis[showIndex].style.backgroundColor = white;            move(showIndex,showIndex+1);    切换下一张图片            showIndex++;            if (showIndex == pictureLis.length) showIndex = 0;            optionLis[showIndex%optionLis.length].style.backgroundColor = red;            autoPlayId = setTimeout(autoStep,2000);        &#125;, 2000)    &#125;    auto();&lt;script&gt;","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/WheelPlanting/","external_link":""},{"title":"作用域和闭包","date":"2016-02-08T11:24:45.000Z","content":"第一章:匿名函数123456 var foo =function()&#123;  console.log(我是匿名函数);&#125;我们可以把变量 f 当做一个函数名来调用foo();=&gt;我是匿名函数\n匿名函数的自执行作用:把全局的变量封装成局部的 , 保证你的数据不会被不小心更改\n1234567(function()&#123;  var a = 10;&#125;)();或者(function()&#123;  var a = 10;&#125;());\n12345678910111213141516alert(a)a();var a=3;function a()&#123;    alert(10)&#125;   alert(a)a=6;a();=&gt; function a()&#123;  \t\talert(10)&#125;=&gt;3=&gt;6=&gt;报错,a已经被重新赋值了,不是一个函数\n第二章:作用域量2.1区分全局变量和局部变量:​    是否在函数内声明\n1234567891011例1:console.log(a);console.log(typeof a);function foo()&#123;\ta = 20;\t\t\t\t若没有声明而直接赋值,这个变量就会自动为全局变量,若在严更模式下则会报错&#125;foo();console.log(a);=&gt;报错\t\t\t\t\t没有a这个元素=&gt;undefined\t\t\t\t  typeof 是个安全的测试方式,就算没有这个元素也不会报错=&gt;20;\t\t\t\t\t  返回的是a这个全局变量\n123456789例2:\t在函数中访问重名的全局变量var a = 20;function()&#123;  var a = 10;  console.log(a);  console.log(window.a);\t可以理解为全局变量a是window的一个属性&#125;=&gt;10;\t\t\t\t\t\t访问的是局部变量a=&gt;20;\t\t\t\t\t\t访问的是全局变量a\n2.2块级作用域123456var m = 10;if(m==10)&#123;  var n =20;&#125;console.log(n);=&gt;20\n2.3执行环境每个执行环境中都有一个变量对象,这个变量对象决定了变量或者函数能够访问的范围\n12345var a = 10;\tconsole.log(a);在全局的环境下声明了a,那么在全局的执行环境中就有一个变量对象,这个变量对象把执行环境中定义的变量存储为这个变量对象的一个属性,访问对象就相当于访问变量对象的一个属性在全局的执行环境下,变量对象就是window对象\n1234567function foo()&#123;  var a = 20;  console.log(a);&#125;在函数中声明了a,此时a就是局部变量,那么此时在函数的这个执行环境中也有了一个变量对象,这个变量对象在执行环境中定义的变量存储在这个变量对象的一个属性访问对象就相当于访问变量对象的一个属性在局部的执行环境下,变量对象就是活动对象\n2.4作用域链作用域链与一个执行环境相关,作用域链用于变量查找.\n作用:函数内查找变量从里向外查找就是因为作用域链的存在.\n每个函数都有一个属性[[scope]],这个属性是不可见的,它指向的是作用域链,作用域链实际也是一个对象,类似于数组,作用于域链中存储的是与每个执行环境相关   变量对象 (函数内部也是活动对象)\n\n内部函数可以访问外部函数的局部变量,即使已经执行结束,是因为作用域链的存在\n\n12345678910111213141516171819202122232425var a = 10;function foo()&#123;  var a = 20;  function inner()&#123;    console.log(a);   &#125;  return inner;&#125;var f = foo();f();\t\t=&gt; 20\t\t\t\t\t此时foo()的返回值也就是函数inner()赋值给f,但f还是能够访问到foo中的局部变量a;若:var a = 10;function foo()&#123;  var a = 20;  function inner()&#123;    console.log(a);   &#125;  a = 30;  return inner;&#125;var f = foo();f()=&gt; 30\n第三章:闭包广义上的闭包:\n​    只要一个函数,访问这个函数外的变量,那么就这个函数就是一个闭包;\n1234567891011121314151617181920212223242526272829303132333435363738&lt;button&gt;按钮1&lt;button&gt;&lt;button&gt;按钮2&lt;button&gt;&lt;button&gt;按钮3&lt;button&gt;&lt;script&gt;\tvar btns = document.querySelectorAll(button);\tfor(var i = 0;i&lt;btns.length;i++)&#123;      btns[i].onclick=function()&#123;          console.log(i);      &#125;\t&#125;\t=&gt;3\t=&gt;3\t=&gt;3\t输出了3个3,是因为点击事件的匿名函数访问的是他外部的局部变量i,并且这个i是最新的(也就是i=3),所以输出的全是3;\t\t解决方案一:利用闭包\tfor(var i = 0;i&lt;btns.length;i++)&#123;      btns[i].onclick=(function(i)&#123;        return function()&#123;          console.log(i);\t\t用一个匿名函数包住,并且返回的也是一个函数,这样返回的函数它访问的局部变量就是它外部的函数(onlick=后面的函数)内的变量i;        &#125;      &#125;)(i);\t&#125;\t=&gt;0;\t=&gt;1;\t=&gt;2    \t解决方案二:用一个变量来存储每次循环的i\tfor(var i = 0;i&lt;btns.length;i++)&#123;      btn[i].index = i;      btn[i].onclick = function()&#123;        console.log(this.index);      &#125;\t&#125;\t=&gt;0;\t=&gt;1;\t=&gt;2    解决方案三:\t将var 改为let\n狭义上的闭包:\n​    如果一个函数,访问了他的外部函数的局部变量,那么这个函数就是一个闭包;(可以理解为这个函数是在一个函数内声明的函数,即嵌套在一个函数内的函数)\n123456789101112如:\t\t\t\t\tfunction foo()&#123;  var b = 20;  function inner()&#123;\t\t这个匿名函数就是foo函数内部声明的函数;    console.log(b);\t\t\t它可以访问到他的外部函数(也就是foo函数)的局部变量b,并且这个局部变量是最新的  &#125;  b = 30;  return inner;&#125;var f = foo();f();=&gt;30;\t\t\t\t\t访问的是最新的局部变量\n闭包的特点    \n​    闭包可以访问它的外部函数作用域内的任何的变量,而且访问到的变量的值一定是最新的,即使外部函数执行结束了,也能访问外部函数的局部变量.\n可以用闭包封装返回值\n1234567891011121314151617181920212223242526272829303132function foo()&#123;  var p = &#123;    name:李四,    age:40  &#125;  return &#123;    getName:function()&#123;      return p.name;    &#125;    getAge:function()&#123;      return 20;    &#125;    setName:function(name)&#123;      p.name = name;    &#125;    addAttr:function(key,value)&#123;      p[key] = value;    &#125;    getAttr:function(key)&#123;      return  p[key];    &#125;  &#125;&#125;var p = foo();console.log(p.getName());\t\t=&gt;李四console.log(p.getAge());\t\t=&gt;20\t返回值传的是谁就返回谁,达到输出假的值的效果;p.setName(王先生);console.log(p.getName());\t\t=&gt;王先生p.addAttr(sex,男);console.log(p.getAttr(sex));\t=&gt;男\n第四章:高阶函数\n如果一个函数接受一个或多个函数作为参数,或者可以返回一个函数,则这样的函数就叫高阶函数\n自己本身不调用,等到别人来调用\n\n123456function  foo(f) &#123;     f();&#125;foo(function()&#123;     console.log(我是传给别人函数);&#125;)\n常见的高阶函数1.map( )作用:对数组中的每一项都做出相应的改变并输出改变后的数组;\nArray.map(function(){});\nmap( )内可以传入任何的函数\n比如想将将     var arr = [1,2,3,4,5] 数组中的每一项都平方得到一个新的数组[1,4,9,16,25];\n( )内可以传入一个函数,如传入一个计算平方的函数\n123456789101112131415若是利用常规方法来将数组arr的每一项都求平方并输出:var arr = [1,2,3,4,5];var arr1 = [];for(var a of arr)&#123;  arr1.push(a*a);&#125;consoloe.log(arr1);使用map()方法:var arr = [1,2,3,4,5];var arr1 = arr.map(function(a)&#123;\t\t\t\t()内传入一个计算平方的函数,a和上面的a一样,代表的是数组中的每一项;  return a*a;&#125;)console.log(arr1);=&gt;\t[1,4,9,16,25]\t\t\t\t返回的是一个数组,数组中的每一项都被平方了\n也可以传入Math内置的方法 sqrt( ) ,一个用于计算开平方的函数\n123var arr = [1,2,3,4,5];console.log(arr.map(Math.sqrt));=&gt;[1, 1.4142135623730951, 1.7320508075688772, 2, 2.23606797749979]\t返回的是一个数组,数组中的每一项都被开平方了\n2.reduce( )Array.reduce(function(sum,ele,index,array){\n},sum0)\nsum 归总\nsum0归总的初始值\nele     数组中的每一个元素\nindex 数组汇总每一个元素的下标\n123456var arr = [0,1,2,3];var value = arr.reduce(function(sum,ele,index)&#123;  return sum*ele;\t\t\t\t\t\t\t\t数组中的每一项相乘,并输出相乘之后的积sum&#125;)console.log(value);=&gt;6;\n3.filter( )过滤\n并不会更改原数组,而是取到你想得到的元素并返回一个数组;\n1234567var arr = [1,2,3,4,5];var a1 = arr.filter(function(ele,index,array)&#123;  return ele%2==0;\t\t\t\t\t\t\t\t获取数组中的所有值为偶数的项  return index%2==0;\t\t\t\t\t\t\t获取数组中所有下标为偶数的项&#125;)console.log(a1);=&gt;[2,4]","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/basicOfScope/","external_link":""},{"title":"JS正则基本知识","date":"2016-02-08T11:24:45.000Z","content":"第一章:基本概念概念:\n 正则表达式(regular expression)是一个描述字符模式的对象，ECMAScript的RegExp 类表示正则表达式，\n 而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。\n 正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。\n作用:\n\n提高用户体验\n减轻服务器的压力\n\n第二章:创建正则表达式1.使用new来创建1var exp = new RegExp(box , gi );\n第一个参数是字符串；\n第二个参数可选模式修饰符\n\n\n\n参数\n含义\n\n\n\n\ng\n全局匹配\n\n\ni\n忽略大小写\n\n\nm\n多行匹配\n\n\n\n2.使用字面量1var exp = boxgi;\n直接用2个   ;\n在俩个斜杠后加上模式修饰符；\n俩种创建方式比较:    \n1.使用字面量方式创建用的更加广泛;\n2.当要匹配的内容是变量时,只能使用new来创建.\n第三章:正则表达式的测试1.test( )\n正则表达式对象.test(字符串)\n\n\n参数：要匹配的字符串\n返回值：匹配成功返回true，失败返回false\n\n12345例1:var exp = Boxi;var str = box ;alert(exp.test(str));=&gt;   true     忽略大小写 ；\n12345678910例2:var exp = abcg;var str = abcab;var res = exp.test(str);console.log(res);console.log(exp.test(str));console.log(exp.test(str));=&gt;\t true\t\t从第一个开始匹配,匹配到了abc 返回true;\t =&gt;\t false\t\t由于开启了全局匹配,所以从上次匹配之后的位置开始匹配(也就是从第二个a开始);\t若没有g 则每次都会从头开始匹配=&gt;\t true\t\t由于上次匹配是false并且已经将字符串str查找完了,所以又从头开始匹配\n注:    \n​    开启了全局匹配g后,正则表达式内部有一个lastIndex的属性,用以记录下次开始查找的下标,保证其每次从lastIndex的位置开始查找\n12345678例3:var exp = abcg;\t\t\t\t\t同一正则表达式匹配不同字符串var str1 = abc;var str2 = abcab;console.log(exp.test(str1));console.log(exp.test(str2));=&gt; \t true;\t\t\t\t从str1的0位开始匹配,匹配到了abc,返回true,\t此时lastIndex为3=&gt;\t false;\t\t\t\t从str2中lastIndex的位置开始匹配,也就是从第二个a开始\n12345678例4:var exp1 = abcg;\t\t\t\t\t不同正则表达式匹配同一字符串var exp2 = abcg;var str = abc;console.log(exp1.test(str));console.log(exp2.test(str));=&gt; \t true;\t\t\t\t从str1的0位开始匹配,匹配到了abc,返回true=&gt;\t true;\t\t\t\t从str1的0位开始匹配,返回true\n2.exec( )\nexec(字符串)：该方法为专门为捕获组而设计的\n\n\n参数：要匹配的字符串\n返回值：返回的是一个数组。如果不匹配则返回null\n\n关于返回值数组的说明：\n\n它确实是Array的实例。\n但是这个数组有两个额外的属性：index和 input\nindex：表示匹配的字符串在源字符串中的索引\ninput：表示匹配的源字符串。\n数组的第一项是与整个模式匹配的字符串，其他项是与模式中捕获组匹配的字符串\n如果没有捕获组，则数组中只有第一项。关于捕获组的概念以后再说\n\n1234567例1:\t\tvar exp = abcgi;        var str = aaabcccdabcAbcAdaBc;        var strNew = ;        while (strNew=exp.exec(str))&#123;\t\t\t使用while循环,将所有匹配到字符串输出来            console.log(strNew[0])\t\t\t\t由于返回的是一个带有很多属性的数组,所以我们只要数组中的字符串,也就是索引为0.        &#125;\n第四章:正则表达式的规则123456字符类:单个字母数字下划线.\t\t\t\t\t\t\t\t\t匹配除换行符外的任意字符(当点放在[]中是，没有特殊意义)var exp = dg;\t\t\t\t\t [0-9]var exp = Dg;\t\t\t\t\t[^0-9]var exp = wg;\t\t\t\t\t[a-zA-Z0-9_];var exp = Wg;\t\t\t\t\t[^a-zA-Z0-9_];\n12345678字符类:空白字符0                             匹配null 字符b                             匹配退格字符n                             匹配换行符r                             匹配回车字符t                             匹配制表符s                             匹配空白字符、空格、制表符和换行符S                             匹配非空白字符\n123元字符元符号                    匹配情况^                             行首匹配$                             行尾匹配\n123456789字符类：重复字符元字符元符号                                匹配情况?  例如（x?）                            匹配0个或1 个x*  例如（x*）                            匹配0个或任意多个x+  例如（x+）                            匹配至少一个x(xyz)+                                     匹配至少一个(xyz)&#123;m,n&#125; 例如x&#123;m,n&#125;  n&gt;=次数&gt;=m            匹配最少m个、最多n个x&#123;n&#125;                                        匹配前一项n次     &#123;n,&#125;                                    匹配前一项n次，或者多次\n1.[ ]\n匹配[ ]内的任意一个字符\n\n1var exp = [abc]gi;\t\t\t\t []内代表匹配其中的一个字符: a 或 b 或 c\n1var exp = [a-zA-Z0-9_$]g;\t\t\t匹配26个大小写字母,0-9数字,下划线_  美元符$ 中的任意一个;\n1var exp = [^a-zA-Z]g\t\t\t\t匹配任意不在括号中的字符集中的字符;\n[ ]也可以配合?  *  +  {} 来使用;  如[a-z]+ 匹配至少一个[a-z]范围内的任意一个;\n2. ^俩种用法:    \n\n1.放在[ ] 内 表示非\n\n1var exp = [^a-zA-Z]g\t\t\t\t匹配任意不在括号中的字符集中的字符;\n\n2.放在[ ] 外,表示行首匹配\n\n12345var exp = ^dg;\t\t\t\t\t规定行首必须是数字\t\tvar str = &apos;123qq&apos;;\t\t\t\t\tconsole.log(exp.test(str));\t\t\t行首为数字1,返回true;  console.log(exp.lastIndex);\t\t\t此时lastIndex 为1console.log(exp.test(str));\t\t\t从下标为1的位置开始匹配,虽然下标为1的位置是数字,但却不是行首,返回false;\n3. $\n表示行尾匹配,用法与^ 相近\n\n^ 和 $ 合用\n123456789var exp = ^dd$g;\t\t\t\t规定行首和行尾必须是数字var str = 12;var str2 = 123;        console.log(exp.test(str));\t\t true        console.log(exp.lastIndex);\t\t 2        console.log(exp.test(str));\t\tfalse        console.log(exp.lastIndex);\t\t0        console.log(exp.test(str));\t\ttrue        console.log(exp.test(str2));\tfalse\t\texp中规定了行首行尾为数字,中间无内容\n4. .\n匹配除换行符外的任意字符(当点放在[ ]中是，没有特殊意义)\n\n1234var exp = .g;var str = a;console.log(exp.test(str));=&gt;    true\n若想匹配它本身.\n1var exp = .g;\n5. |\n择一匹配(管道符号)  表示或\n\n1234var exp = a|bg;var str = a;console.log(exp.test(str));=&gt;    true\n数量词的匹配:默认都是贪婪匹配\n6. ?\n匹配0个或者1个\n\n7. *\n匹配0个或者多个\n\n1234var exp = a*g;var str = aaaaa;\tconsole.log(exp.test(str));\t\t\ttrue\tconsole.log(exp.test(str));\t\t\ttrue\n8. +\n匹配1个或多个\n\n1234var exp = a+g;var str = aaaaa;\tconsole.log(exp.test(str));\t\t\ttrue\tconsole.log(exp.test(str));\t\t\tfalse\n9. {n}\n匹配n个,只能是n个\n\n10. {n,}\n匹配至少n个\n\n11. {n,m}\n匹配至少n个,最多m个\n\n第五章:基本的正则表达式验证12345678910111213141516171819202122写一个正在表达式,判断手机号是否合法var exp = 1[34578]d&#123;9&#125;$g;var str = 13979318939;\tconsole.log(exp.test(str));=&gt; true写一个正在表达式,判断邮箱是否合法var exp = ^w&#123;3,15&#125;@[w-]+.(com|cn|net|org|edu|com.cn)$gi;var str = 133_d@cn.com.cn;    console.log(exp.exec(str)[0]);=&gt;  133_d@cn.com.cn   写一个正则表达式,判断图片的地址是否合法var exp = ^(http|https):.+.(jpg|jpeg|gif|png)$gi;var str = http:3323498dsfledf.png;\tconsole.log(exp.exec(str)[0]);=&gt;  http:3323498dsfledf.png写一个正则表达式,爬取一堆字符串中的所有图片地址var exp = http:[^:]+.(jpg|jpeg|gif|png)gi;写一个正则表达式,将字符串中的重复去掉var exp = (.)1+gi;var str = aabbccdd;\t\tconsole.log(str.replace(exp,$1));=&gt;  abc\n第六章:方法1.search( )\nstr.search(exp);                            \n检索与正则表达式相匹配的第一个匹配项的索引。\n返回值: 索引 ,没有返回-1;\n\n注:search( )不支持全局,每次调用总是从0开始查找.加不加g都一样\n2.match( )\nstr.match(exp);\n把满足正则表达式的所有字符串一起返回\n返回值: 数组 ,没有返回null;\n\n123var str = &quot;abc134ABC244co9&quot;;\tconsole.log(str.match(d+gi));\t\t\t获取str中的所有数字的数组=&gt;  [&quot;134&quot;,&quot;244&quot;,&quot;9&quot;]\n注:如果想获取所有的满足的,应该使用全局g,使用全局的时候,分组的信息则拿不到    \n3.replace( )\nstr.replace(exp,newStr);\n将正则表达式替换\n返回值: 替换之后的字符串\n\n123var str = &quot;123aaa244&quot;;\tconsole.log(str.replace(dgi,&quot;&quot;));\t\t将str中的数字全部去掉=&gt;  aaa\n12345写一个正则表达式,将字符串中的重复去掉var exp = (.)1+gi;var str = aabbccdd;\t\tconsole.log(str.replace(exp,$1));=&gt;  abc\n4.split( )\nstr.split(exp,length);\nlength:可选参,切出来的数组的最大长度\n使用split 拆分成字符串数组\n返回替换之后的字符串\n\n1234var str = &quot;102dsfe00dfefsf55&quot;;var exp = D+gi;\t\t\t\t\t\t\t\t用所有非数字来切割\tconsole.log(str.split(exp));\t=&gt;\t[&quot;102&quot;,&quot;00&quot;,&quot;55&quot;]","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/basicOfRegExp/","external_link":""},{"title":"霖呆呆的函数式编程之路(二)","date":"2019-06-23T14:18:45.000Z","content":"前言在第一章我们主要介绍了函数的一些基本功能和结构，以及介绍了一些实用的小技巧。这些都是为了后面一步一步入门打下好的基础。因为函数式编程并不是一个看看文档就能很好掌握的东西，它需要你集合实际例子然后理解每一步为什么要这样，如果你只是想粗略的看看，不去思考🤔，相信我，后面的案例你会感觉特别跳，特别绕(开始学习时我就是这样😼)。\n在这一章中，我会针对函数式编程的另一个重点：函数的输入来做讲解和案例分析，个人建议：打开你的vscode，关上文档，把案例敲上一遍，需要的时候把每一步做个对比，确保自己是真的理解它们。\n偏函数先来看一个大家都很熟悉的函数：\n\n一个ajax函数，第一个参数为请求的API地址，第二个为请求的参数，第三个是请求成功之后的回调函数。\n\n123function ajax (url, data, callback) &#123;\t ...&#125;\n\n现在如果你已经很确定一个API地址，此外只是需要等待另外两个参数的时候，比如获取用户信息和获取订单详情的请求：\n\n123456function getUser (data, cb) &#123;\tajax(apiuser, data, cb)&#125;function getOrder (data, cb) &#123;\tajax(apiorder, data, cb)&#125;\n\n现在如果你已经很确定一个API地址，同时已经很确定请求的参数(比如用户的id)，此外只需要等待另一个参数的时候：\n\n123456function getCurrentUser (cb) &#123;\tgetUser(&#123; userId: 1 &#125;, cb)&#125;function getCurrentOrder (cb) &#123;\tgetUser(&#123; orderId: 1 &#125;, cb)&#125;\n不知道大家发现了没，从第一步到第三步，每过一步，函数的参数就少一个，直到最后只需要传递一个cb。\n用一句话来说明发生的事情：getUser(data, cb)是ajax(url, data, cb)的偏函数(partially-applied functions)。\n(注意⚠️：前方高能！)\n关于该模式更正式的说法是：偏函数严格来讲是一个减少函数参数个数（arity）的过程；这里的参数个数指的是希望传入的形参的数量。我们通过 getUser(..) 把原函数 ajax(..) 的参数个数从 3 个减少到了 2 个。\npartial函数在上面的例子中，getCurrentUser(cb)和getCurrentOrder(cb)的模式其实很想，我们可以来定一个partial()实用函数：\n12345function partial (fn, ...prestArgs) &#123;\treturn function partiallyApplied (...laterArgs) &#123;\t\treturn fn(...prestArgs, ...laterArgs)\t&#125;&#125;\npartial函数接受一个fn函数，和若干个参数…prestArgs。\n它返回的是另一个函数partiallyApplied()函数，这个函数也接受若干个参数…laterArgs，并返回partial函数传递进来fn函数。\n返回的fn函数会将partial和partiallyApplied中的参数都接收过去。\n(这个实用函数我至少敲了3遍…)\n好吧，我们还是来看看我参考资料的原版本是怎么描述这个实用函数的吧，感觉它说的也比较清晰：\n\npartial(..) 函数接收 fn 参数，来表示被我们偏应用实参（partially apply）的函数。接着，fn 形参之后，presetArgs 数组收集了后面传入的实参，保存起来稍后使用。\n我们创建并 return 了一个新的内部函数（为了清晰明了，我们把它命名为partiallyApplied(..)），该函数中，laterArgs 数组收集了全部实参。\n你注意到在内部函数中的 fn 和 presetArgs 引用了吗？他们是怎么如何工作的？在函数 partial(..) 结束运行后，内部函数为何还能访问 fn 和 presetArgs 引用？你答对了，就是因为闭包！内部函数 partiallyApplied(..) 封闭（closes over）了 fn 和 presetArgs 变量，所以无论该函数在哪里运行，在 partial(..) 函数运行后我们仍然可以访问这些变量。所以理解闭包是多么的重要！\n当 partiallyApplied(..) 函数稍后在某处执行时，该函数使用被闭包作用（closed over）的 fn 引用来执行原函数，首先传入（被闭包作用的）presetArgs 数组中所有的偏应用（partial application）实参，然后再进一步传入 laterArgs 数组中的实参。\n\n当然你也可以用更便捷的箭头函数语法来重写上面的函数：\n123var partial = (fn, ...presetArgs) =&gt; \t\t\t\t\t\t\t\t\t\t\t\t\t\t(...laterArgs) =&gt; \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfn(...prestArgs, ...laterArgs);\n优点：更加简洁，甚至代码稀少。\n缺点：函数会变成匿名函数，可读性上失去益处，此外，由于作用域边界变得模糊，我们会更加难以辩认闭包。\n不过是否采用箭头函数都是你的个人喜好。\najax案例\n介绍完上面的函数，我们现在可以用partial实用函数来制造这些之前提及的偏函数：\n\n12345678910 example1function partial (fn, ...prestArgs) &#123;\treturn function partiallyApplied (...laterArgs) &#123;\t\treturn fn(...prestArgs, ...laterArgs)\t&#125;&#125;var getUser = partial(ajax, apiuser)var getOrder = partial(ajax, apiorder)\n不知道大家脑中是否有getUser 函数的外形和内在，它其实就相当于这样：\n12345var getUser = partial(ajax, apiuser) 相当于=&gt;var getUser = function partailApplication (...laterArgs) &#123;  return ajax(apiuser, ...laterArgs)&#125;\n\n我相信大家已经知道怎样用partial来写getUser函数了\n\n那么再进一层，getCurrentuser函数可以怎么写呢？\n12 example2var getCurrentUser = partial(ajax, apiuser, &#123; userId: 1 &#125;)\n哈哈😄，看到这里你是否想到了还能用案例1中的getUser和partial配合：\n12 example3var getCurrentUser = partial(getUser, &#123; userId: 1 &#125;)\n过程是这样的：\n12345678910111213function ajax (url, data, callback) &#123;\t ...&#125;function partial (fn, ...prestArgs) &#123;\treturn function partiallyApplied (...laterArgs) &#123;\t\treturn fn(...prestArgs, ...laterArgs)\t&#125;&#125;var getUser = partial(ajax, apiuser)var getCurrentUser = partial(getUser, &#123; userId: 1 &#125;)\n我们可以像案例2一样通过指定url和data两个实参来定义getCurrentUser(...)函数。\n也可以像案例3将getCurrentUser(…)函数定义成getUser(…)的偏应用，该偏应用仅指定一个附加的 data 实参。\n\n案例3的函数包含了一个额外的函数包装层。这看起来有些奇怪而且多余，但对于你真正要适应的函数式编程来说，这仅仅是它的冰山一角。随着本文的继续深入，我们将会把许多函数互相包装起来。记住，这就是函数式编程！\n\nadd案例理解了上面的一个案例之后，我们再来看下面的案例应该就会变得非常简单了：\n这是一个计算返回两数之和的函数：\n123function add (x, y) &#123;\treturn x + y&#125;\n现在我们有一个数组，要给数组中的每一项都固定加上一个数3，也许你想到了可以用JS中的map来写：\n1234var arr = [1, 2, 3, 4]var arr2 = arr.map(function adder (val) =&gt; &#123;\treturn add(3, val)&#125;)\nmap中执行的事情其实也是返回一个函数add的计算结果，那么我们就可以用partial函数来写它：\n12 example4var arr2 = arr.map(partial(add, 3))\n注意： 如果你没见过 map(..) ，别担心，我会在后面的部分详细介绍它。目前你只需要知道它用来循环遍历（loop over）一个数组，在遍历过程中调用函数产出新值并存到新的数组中。\n右偏函数在上面的ajax案例中，我们是先传递url和data，最后再确定c的，如果要偏应用cb而稍后再指定data和url` 参数，我们应该怎么做呢？\nreverseArgs函数我们可以创建一个可以颠倒实参顺序的实用函数，用来包装原函数。\n1234567891011function reverseArgs(fn) &#123;\treturn function argsReversed(...args) &#123;\t\treturn fn(...args.reverse())\t&#125;&#125; ES6 箭头函数形式var reverseArgs =\tfn =&gt;\t\t(...args) =&gt;\t\t\tfn( ...args.reverse() )\n该函数的作用很简单，它可以颠倒实参顺序。\npartialRight函数现在我们来定义一个从右边开始偏应用实参的partialRight函数：\n12345function partialRight( fn, ...presetArgs ) &#123;\treturn reverseArgs(\t\tpartial( reverseArgs( fn ), ...presetArgs.reverse() )\t);&#125;\n这个 partialRight(..) 函数的实现方案不能保证让一个特定的形参接收特定的被偏应用的值；它只能确保将被这些值（一个或几个）当作原函数最右边的实参（一个或几个）传入。\n比如说：\n1234567891011121314function foo(x,y,z) &#123;\tvar rest = [].slice.call( arguments, 3 );\tconsole.log( x, y, z, rest );&#125;var f = partialRight( foo, z:last );f( 1, 2 );\t\t\t 1 2 z:last []f( 1 );\t\t\t\t 1 z:last undefined []f( 1, 2, 3 );\t\t 1 2 3 [z:last]f( 1, 2, 3, 4 );\t 1 2 3 [4,z:last]\n只有在传两个实参（匹配到 x 和 y 形参）调用 f(..) 函数时，&quot;z:last&quot; 这个值才能被赋给函数的形参 z。在其他的例子里，不管左边有多少个实参，&quot;z:last&quot; 都被传给最右的实参。\n柯里化我们来看一个跟偏应用类似的技术，该技术将一个期望接收多个实参的函数拆解成连续的链式函数（chained functions），每个链式函数接收单一实参（实参个数：1）并返回另一个接收下一个实参的函数。\n这就是柯里化（currying）技术。\n还记得前面的ajax函数吗？\n123function ajax (url, data, callback) &#123;\t ...&#125;\n现在想象一下我们已经创建了一个ajax(…)的柯里化版本：\n123curriedAjax(apiuser)\t\t\t\t\t\t(&#123; userId: 1 &#125;)\t\t\t\t\t\t\t( function foundUser(user) &#123; ... &#125; )\n我们将三次调用分别拆解开来，这也许有助于我们理解整个过程：\n123var userFetcher = curriedAjax(apiuser)var getCurrentUser = userFetcher(&#123; userId: 1 &#125;)getCurrentUser( function foundUser(user)&#123; * .. * &#125; )\n可以看到curriedAjax函数在每次调用的时候只接收一个实参，而不是一次性接收所有实参（像 ajax(..) 那样），也不是先传部分实参再传剩余部分实参（借助 partial(..) 函数）。\n柯里化和偏应用进行对比：\n相同点：\n\n每个类似偏应用的连续柯里化调用都把另一个实参应用到原函数，一直到所有实参传递完毕。\n\n不同点：\n\n柯里化会明确地返回一个期望只接收下一个实参 data 的函数，而偏应用是能接收所有的剩余参数。\n\ncurry函数下面我们来看看如何定义一个用来柯里化的实用函数：\n123456789101112function curry(fn, arity = fn.length) &#123;  return (function nextCurried(prevArgs) &#123;    return function curried(nextArg) &#123;      var args = prevArgs.concat([nextArg])      if (args.length &gt;= arity) &#123;        return fn(...args)      &#125; else &#123;        return nextCurried(args)      &#125;    &#125;  &#125;)([])&#125;\nES6箭头函数版本：\n123456789101112var curry = (fn, arity = fn.length, nextCurried) =&gt; \t\t\t\t\t\t\t\t(nextCurried = prevArgs =&gt; &#123;\t\t\t\t\t\t\t\t\tnextArg =&gt; &#123;\t\t\t\t\t\t\t\t\t\tvar args = prevArgs.concat( [nextArg] );                    if (args.length &gt;= arity) &#123;                      return fn( ...args );                    &#125;                    else &#123;                      return nextCurried( args );                    &#125;\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t&#125;)([])\n\n此处的实现方式是把空数组 [] 当作 prevArgs 的初始实参集合，并且将每次接收到的 nextArg 同 prevArgs 连接成 args 数组。当 args.length 小于 arity（原函数 fn(..) 被定义和期望的形参数量）时，返回另一个 curried(..)函数（译者注：这里指代 nextCurried(..) 返回的函数）用来接收下一个 nextArg 实参，与此同时将 args 实参集合作为唯一的 prevArgs 参数传入 nextCurried(..) 函数。一旦我们收集了足够长度的 args 数组，就用这些实参触发原函数 fn(..)。\n默认地，我们的实现方案基于下面的条件：在拿到原函数期望的全部实参之前，我们能够通过检查将要被柯里化的函数的 length 属性来得知柯里化需要迭代多少次。\n假如你将该版本的 curry(..) 函数用在一个 length 属性不明确的函数上 —— 函数的形参声明包含默认形参值、形参解构，或者它是可变参数函数，用 ...args 当形参；参考第 2 章 —— 你将要传入 arity 参数（作为 curry(..) 的第二个形参）来确保 curry(..) 函数的正常运行。\n\najax案例我们用 curry(..) 函数来实现此前的 ajax(..) 例子：\n1234var curriedAjax = curry( ajax )var userFetcher = curriedAjax(apiuser)var getCurrentUser = userFetcher(&#123; userId: 1 &#125;)getCurrentUser( function foundUser(user)&#123; * .. * &#125; )\n可以看到在每次函数调用的时候都会新增一个实参，最终给原函数ajax使用，直到收齐了三个实参并执行ajax函数为止。\nadd案例现在我们还可以来回顾一下在partial中用到的例子：\n12var arr = [1, 2, 3, 4]var arr2 = arr.map( partial(add, 3) )\n由于柯里化是和偏应用相似的，所以我们可以用几乎相同的方式以柯里化来完成那个例子。\n12var arr2 = arr.map( curry( add )( 3 ) ); [4,5,6,7,8]\npartial(add,3) 和 curry(add)(3) 两者有什么不同呢？为什么你会选 curry(..) 而不是偏函数呢？当你先得知 add(..) 是将要被调整的函数，但如果这个时候并不能确定 3 这个值，柯里化可能会起作用：\n12345var adder = curry( add ); later[1,2,3,4,5].map( adder( 3 ) ); [4,5,6,7,8]\nsum案例下面这个案例，是将一个列表的数字相加：\n1234567function sum(...args) &#123;\tvar sum = 0;\tfor (let i = 0; i &lt; args.length; i++) &#123;\t\tsum += args[i];\t&#125;\treturn sum;&#125;\n普通调用：\n12sum(1, 2, 3, 4, 5) 15\n柯里化调用\n123 (5 用来指定需要链式调用的次数)var curriedSum = curry( sum, 5 )curriedSum( 1 )( 2 )( 3 )( 4 )( 5 )  15\n柯里化调用的好处：\n\n每次函数调用传入一个实参，并生成另一个特定性更强的函数，之后我们可以在程序中获取并使用那个新函数。\n偏应用则是预先指定所有将被偏应用的实参，产出一个等待接收剩下所有实参的函数。\n\n柯里化和偏应用有什么用？柯里化和偏应用这两种风格的签名都比普通的函数要奇怪很多，那么为什么要用这么奇怪的方式去构造那些函数呢？主要是有这么几个方面：\n\n使用柯里化和偏应用可以将指定分离实参的时机和地方独立开来，传统函数是需要预先确定所有实参的。\n当函数只有一个形参时，我们能够比较容易地组合它们\n\n柯里化多个参数在上面介绍的函数柯里化中，我们知道，它在每次调用的时候只支持传入一个实参。这样的柯里化我们可以称之为“严格柯里化”。\nlooseCurry函数其实在大多数流行的JavaScript函数式编程都使用了一种不严格的柯里化(loose currying)。\n也就是说，往往 JS 柯里化实用函数会允许你在每次柯里化调用中指定多个实参，如在上面提到的sum函数，我们使用严格柯里化需要调用5次，但在松散柯里化我们可以这样：\n12var curriedSum = looseCurry(sum, 5)curriedSum(1)(2, 3)(4, 5)\n相比于严格的柯里化，语法上我们节省了()的使用，并且把五次函数调用减少成三次，间接提高了性能。\n注意： 松散柯里化允许你传入超过形参数量（arity，原函数确认或指定的形参数量）的实参。如果你将函数的参数设计成可配的或变化的，那么松散柯里化将会有利于你。\n现在我们可以将之前的柯里化函数调整一下，使其适应这种常见的更松散的定义：\n123456789101112function looseCurry (fn, arity = fn.length) &#123;    return (function nextCurried (prevArgs) &#123;        return function curried(...nextArgs) &#123;            var args = prevArgs.concat(nextArgs)            if (args.length &gt;= arity) &#123;                return fn(...args)            &#125; else &#123;                return nextCurried(args)            &#125;        &#125;    &#125;)([])&#125;\nES6版本：\n1234567891011var looseCurry = (fn, arity = fn.length, nextCurried) =&gt;    (nextCurried = prevArgs =&gt;        (...nextArg) =&gt; &#123;            var args = prevArgs.concat(nextArg);            if (args.length &gt;= arity) &#123;                return fn(...args);            &#125;            else &#123;                return nextCurried(args);            &#125;        &#125;)([])\n反柯里化你也会遇到这种情况：拿到一个柯里化后的函数，却想要它柯里化之前的版本 —— 这本质上就是想将类似 f(1)(2)(3) 的函数变回类似 g(1,2,3) 的函数。\nuncurry函数处理这个需求的标准实用函数通常被叫作 uncurry(..)：\n1234567891011function uncurry(fn) &#123;\treturn function uncurried(...args)&#123;\t\tvar ret = fn;\t\tfor (let i = 0; i &lt; args.length; i++) &#123;\t\t\tret = ret( args[i] );\t\t&#125;\t\treturn ret;\t&#125;;&#125;\nES6版本\n12345678var uncurry = fn =&gt; \tuncurried = (...args) =&gt; &#123;\t\tvar ret = fn\t\tfor (let i = 0; i &lt; args.length; i++) &#123;\t\t\tret = ret( args[i] )\t\t&#125;\t\treturn ret\t&#125;\n使用反柯里化后，可以让我们函数的传参形式变为柯里化之前的形式：\n1234567891011121314 example5function sum(...args) &#123;\tvar sum = 0;\tfor (let i = 0; i &lt; args.length; i++) &#123;\t\tsum += args[i];\t&#125;\treturn sum;&#125;var curriedSum = curry( sum, 5 );var uncurriedSum = uncurry( curriedSum );curriedSum( 1 )( 2 )( 3 )( 4 )( 5 );\t\t 15uncurriedSum( 1, 2, 3, 4, 5 );\t\t\t\t 15\n注意⚠️\n但不要以为使用了反柯里化之后的函数会和原函数的行为完全一样(也就是uncurry(curry(fn))和 fn )，虽然在某些库中，反柯里化使函数变成和原函数（译者注：这里的原函数指柯里化之前的函数）类似的函数。\n但是凡事皆有例外，例如我们上面的案例5，采用反柯里化之后，如果你少传了实参，就会得到一个仍然在等待传入更多实参的部分柯里化函数。我们在下面的代码中说明这个怪异行为。\n12uncurriedSum( 1, 2, 3, 4, 5 )  15uncurriedSum( 1, 2, 3 )( 4, 5 )  15\n这两种传参方式都会得到相同的结果。\nuncurry() 函数最为常见的作用对象很可能并不是人为生成的柯里化函数（例如上文所示），而是某些操作所产生的已经被柯里化了的结果函数。我会在后面关于 “无形参风格” 的讨论中阐述这种应用场景。\n后语在这一章节中，我主要介绍了函数式编程中两个比较重要的知识点偏应用和柯里化，彻底的理解它们，才能继续接下去的学习之路。\n","tags":["前端进阶","Functional"],"path":"2019/06/23/webNotes/advanced/Functional/ch_2/","external_link":""},{"title":"霖呆呆的函数式编程之路(三)","date":"2019-06-27T13:20:40.000Z","content":"只要一个实参unary函数先来看一个奇怪的例子：\n123456 example1[1,2,3].map( parseFloat ); [1,2,3][1,2,3].map( parseInt ); [1,NaN,NaN]\n在上面的例子中，我想要将一组字符串全部设置成数字类型，但是在调用parseInt的时候，却出现了这样怪异的事情。这是为什么呢？\n首先我们来说一下parseInt(str,radix)这个函数，它接受两个参数，第一个是要被解析的字符串，第二个为可选参数，表示要解析的数字的基数。该值介于 2 ~ 36 之间,比如：\n123parseInt(10);\t\t\t返回 10parseInt(19,10);\t\t返回 19 (10+9)parseInt(11,2);\t\t返回 3 (2+1)\n\n当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。\n如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n\n而在案例1中，由于我们在调用map的时候，函数时会传入三个实参：value、index 和 list。parseInt()又会接收2个参数，所以每次都相当于是将value和index传入进去了。这样就造成后面2个NaN的情况。\n根据上面，我们可以看到，在实际开发中，我们会面临这样一个问题：在设计一个实用函数传入一个函数，而这个实用函数会把多个实参传入函数，但可能你只希望你的函数接收单一实参。如上面的parseInt()函数，我在调用它的时候希望它每次只接收一个参数。\n根据上面的需要，我们是不是可以来实现这么一个简单的实用函数，它包装一个函数调用，让这个函数在每次调用的时候只接收一个参数：\n12345678910function unary(fn) &#123;\treturn function onlyOneArg(arg) &#123;\t\treturn fn(arg)\t&#125;&#125; ES6var unary = fn =&gt; \t\t\t\t\t\t\targ =&gt; \t\t\t\t\t\t\t\t\t\tfn(arg);\n很简单的一层封装，也很好理解。\n现在我们用它来配合上面的案例1:\n12345678[1,2,3].map( parseFloat ); [1,2,3][1,2,3].map( parseInt ); [1,NaN,NaN][1,2,3].map( unary( parseInt ) ); [1,2,3]\nsum案例了解了上面的unary函数之后，我们来看一个复杂一些的案例。还是用map函数来进行举例，不过要用到我们在第二章讲到的松散型柯里化looseCurry。\n12345678910111213141516171819202122232425function looseCurry(fn, arity = fn.length) &#123;  松散型柯里化    return (function nextCurried(prevArgs) &#123;        return function curried(...nextArgs) &#123;            var args = prevArgs.concat(nextArgs)            if (args.length &gt;= arity) &#123;                return fn(...args)            &#125; else &#123;                return nextCurried(args)            &#125;        &#125;    &#125;)([])&#125;function sum(...args) &#123;    var sum = 0;    for (let i = 0; i &lt; args.length; i++) &#123;        sum += args[i];    &#125;    return sum;&#125;let adder = looseCurry(sum, 2)  第一步 传2表示至少接收2个参数才可以let arr = [1, 2, 3, 4, 5]let arr2 = arr.map(adder(3))  第二步console.log(arr2) 生成的结果很有意思 [41,2,3,4,5, 61,2,3,4,5, 81,2,3,4,5, 101, ...\n大家可以先将这段代码在本地跑一下，并思考为什么会出现这样的情况？🤔\n其实原理很简单：\n在第一步的时候，创建adder函数，只有在接收2个及以上参数才会运行sum()，\n第二步的时候，由于map()会传入3个实参：分别是value,index和list，而松散型的柯里化是可以接收比预期(这里也就是2)多的参数的。\n所以在每次执行sum函数的时候，实际传入的都是3个参数，比如arr执行第一次的时候：\n1234567891011121314第一次传入：firstArg: 3,    调用adder()时传入的3value: 1,  数组第一项的值index: 0,  数组第一项的索引list: [1, 2, 3, 4, 5]  整个数组 前面3项相加为数字4，之后数字4与数组做字符串相加=&gt; 3 + 1 + 0 + [1, 2, 3, 4, 5]=&gt; 41,2,3,4,5第二次传入firstArg: 3,value: 2,index: 1,list: [1, 2, 3, 4, 5]\n此时，使用我们的unary函数就可以解决上面的问题了：\n12let arr2 = arr.map( unary( adder(3) ) ) [4,5,6,7,8]\n传一个返回一个identity函数说到只传一个实参的函数，在函数式编程工具库中有另一种通用的基础函数：该函数接收一个实参，然后什么都不做，原封不动地返回实参值。\n12345678function identity(v) &#123;\treturn v;&#125; ES6 箭头函数形式var identity =\tv =&gt;\t\tv;\n举个例子，想象一下你要用正则表达式拆分（split up）一个字符串，但输出的数组中可能包含一些空值。我们可以使用 filter(..) 数组方法（下文会详细说到这个方法）来筛除空值，而我们将 identity(..) 函数作为 filter(..) 的断言：\n123456var words =    Now is the time for all...  .split( s|b );words; [,Now,is,the,time,for,all,...,]words.filter( identity ); [Now,is,the,time,for,all,...]\n转换函数的妙用另一个使用 identity(..) 的示例就是将其作为替代一个转换函数（译者注：transformation，这里指的是对传入值进行修改或调整，返回新值的函数）的默认函数：\n1234567891011function output(msg,formatFn = identity) &#123;\tmsg = formatFn( msg );\tconsole.log( msg );&#125;function upper(txt) &#123;\treturn txt.toUpperCase();&#125;output( Hello World, upper );\t\t HELLO WORLDoutput( Hello World );\t\t\t Hello World\n上面的例子，相当于是给output函数一个默认的函数，若是没有传的话，则原封不动的返回传进来的msg。\n恒定参数Certain APICertain API 禁止直接给方法传值，而要求我们传入一个函数，就算这个函数只是返回一个值。JS Promise 中的 then(..)方法就是一个 Certain API。\nthen(..)中必须要传入一个函数，而有时候我们可能不需要传入一个有实际用处的函数，而是直接返回then在上一步中获取到的值。\n或许你可以用ES6的箭头函数解决这个问题：\n1p1.then( foo ).then( () =&gt; p2 ).then( bar )\n在第二个then中直接将p2返回。\nconstant函数我们可以来构造一个实用函数来实现上面的功能：\n1234567891011function constant(v) &#123;\treturn function value()&#123;\t\treturn v;\t&#125;;&#125; or the ES6 =&gt; formvar constant =\tv =&gt;\t\t() =&gt;\t\t\tv;\nconstant函数功能也很简单，返回传入的参数。\n对比：\n12345p1.then( foo ).then( () =&gt; p2 ).then( bar ); 对比：p1.then( foo ).then( constant( p2 ) ).then( bar );\n两种方式都可以解决Certain API的问题。但是我更建议用第二种方式，该箭头函数返回了一个来自外作用域的值，这和 函数式编程的理念有些矛盾。在后面“减少副作用”中会提到该行为的不足。\n扩展在参数中的妙用在第一章中，我们提到了形参数组解构：\n123456function foo( [x,y,...args] ) &#123;\tconsole.log(x, y, args)\t 1, 2, [3]&#125;foo( [1,2,3] );\n当函数必须接收一个数组，而你却想把数组内容当成单独形参来处理的时候，这个技巧十分有用。\n然而，有的时候，你无法改变原函数的定义，但想使用形参数组解构。\n比如下面这个例子：\n12345678910function foo(x, y) &#123;\tconsole.log( x + y );&#125;function bar(fn) &#123;\tfn( [ 3, 9 ] );&#125;bar( foo ); 3,9undefined\n由于fn会将实参[3, 9]作为x传入，那么y就是undefined，所以达不到我们期望的效果。\n在这种情况下，我们可能想要改变bar()函数的行为，将foo([3, 9])改为foo(…[3, 9])，这样就能将 3 和 9 分别传入 foo(..) 函数了。\n为了调整一个函数，让它能把接收的单一数组扩展成各自独立的实参，我们可以定义一个辅助函数：\n1234567891011function spreadArgs(fn) &#123;\treturn function spreadFn(argsArr) &#123;\t\treturn fn( ...argsArr );\t&#125;;&#125; ES6 箭头函数的形式：var spreadArgs =\tfn =&gt;\t\targsArr =&gt;\t\t\tfn( ...argsArr );\n注意⚠️：\n在我参考的教材中，将这个辅助函数叫为spreadArgs，但一些库，比如 Ramda，经常把它叫做 apply(..)。\n现在我们可以使用 spreadArgs(..) 来调整 foo(..) 函数，使其作为一个合适的输入参数并正常地工作：\n1bar( spreadArgs( foo ) );\t\t\t 12\n本质上，spreadArgs(..) 函数使我们能够定义一个借助数组 return 多个值的函数，不过，它让这些值仍然能分别作为其他函数的输入参数来处理。\n一个函数的输出作为另外一个函数的输入被称作组合（composition），这个在后面的章节中会详细说明。\n有了spreadArgs函数，同样的我们也可以定义一个与它功能相反的函数：\n1234567891011function gatherArgs(fn) &#123;\treturn function gatheredFn(...argsArr) &#123;\t\treturn fn( argsArr );\t&#125;;&#125; ES6 箭头函数形式var gatherArgs =\tfn =&gt;\t\t(...argsArr) =&gt;\t\t\tfn( argsArr );\n\n在 Ramda 中，该实用函数被称作 unapply(..)，是与 apply(..) 功能相反的函数。我认为术语 “扩展（spread）” 和 “聚集（gather）” 可以把这两个函数发生的事情解释得更好一些。\n\n不需要顺序的柯里化和偏应用在上面介绍的多形参柯里化和偏应用中，参数传递都是有一定顺序的。哪一个参数在哪一步才能传，放在第一个位置都是固定好的，要是想进行修正调整可能需要费一番功夫。\n这时候我们不得不思考有没有一种方法能让我们从修正参数顺序这件事里解脱出来呢？\n或许解构模式可以？\n在第一章节中，我们提到了命名参数解构模式：\n1234567function foo( &#123;x,y&#125; = &#123;&#125; ) &#123;\tconsole.log( x, y );&#125;foo( &#123;\ty: 3&#125; );\t\t\t\t\t undefined 3\n可以看到这种解构模式就相当于是一种映射，将调用时传入的实参于函数的形参进行一个映射。\n命名实参主要的好处就是不用再纠结实参传入的顺序，因此提高了可读性。\npartialProps和curryProps有了这样的想法，我们就可以来重新调整一下原先的柯里化curry和偏应用partial了：\n12345678910111213141516171819function partialProps(fn, presetArgsObj) &#123;    return function partialApplied(laterArgsObj) &#123;        return fn(Object.assign(&#123;&#125;, presetArgsObj, laterArgsObj))    &#125;&#125;function curryProps(fn, arity = 1) &#123;    return (function nextCurried(prevArgsObj) &#123;        return function curried(nextArgObj = &#123;&#125;) &#123;            var [key] = Object.keys(nextArgObj)            var allArgsObj = Object.assign(&#123;&#125;, prevArgsObj, &#123; [key]: nextArgObj[key] &#125;)            if (Object.keys(allArgsObj).length &gt;= arity) &#123;                return fn(allArgsObj);            &#125;            else &#123;                return nextCurried(allArgsObj)            &#125;        &#125;    &#125;)(&#123;&#125;)&#125;\n我们甚至不需要设计一个 partialPropsRight(..) 函数了，因为我们根本不需要考虑属性的映射顺序，通过命名来映射形参完全解决了我们有关于顺序的烦恼！\n现在可以来试试这两个新函数：\n123456789101112function foo(&#123; x, y, z &#125; = &#123;&#125;) &#123;\tconsole.log( `x:$&#123;x&#125; y:$&#123;y&#125; z:$&#123;z&#125;` );&#125;var f1 = curryProps( foo, 3 );var f2 = partialProps( foo, &#123; y: 2 &#125; );f1( &#123;y: 2&#125; )( &#123;x: 1&#125; )( &#123;z: 3&#125; ); x:1 y:2 z:3f2( &#123; z: 3, x: 1 &#125; ); x:1 y:2 z:3\n我们不用再为参数顺序而烦恼了！现在，我们可以指定我们想传入的实参，而不用管它们的顺序如何。也不需要类似 reverseArgs(..) 的函数或其它妥协了。\n属性扩展上面的partialProps 看似解决了我们这种多形参无顺序的问题，但是，只有在我们可以掌控 foo(..) 的函数签名，并且可以定义该函数的行为，使其解构第一个参数的时候，以上技术才能起作用。\n如果一个函数，其形参是各自独立的（没有经过形参解构），而且不能改变它的函数签名，那我们应该如何运用这个技术呢？\n123function bar(x,y,z) &#123;\tconsole.log( `x:$&#123;x&#125; y:$&#123;y&#125; z:$&#123;z&#125;` );&#125;\n比如上面的bar函数，接收的就是三个参数，但是我想要能映射到对应的位置，比如这样传：\n1bar(&#123; y: 2, x: 1, z: 3 &#125;)\nspreadArgProps函数就像之前的 spreadArgs(..) 实用函数一样，我们也可以定义一个 spreadArgProps(..) 辅助函数，它接收对象实参的 key: value 键值对，并将其 “扩展” 成独立实参。\n为了满足上面的需求，我们现在需要取得在调用fn时传递的实际参数。\n在JS的函数对象上有一个toString()方法，它返回函数代码的字符串形式，其中包括函数声明的签名。\n123456789101112function spreadArgProps(\tfn,\tpropOrder =\t\tfn.toString()\t\t.replace( ^(?:(?:function.*(([^]*?)))|(?:([^()]+?)s*=&gt;)|(?:(([^]*?))s*=&gt;))[^]+$, $1$2$3 )\t\t.split( s*,s* )\t\t.map( v =&gt; v.replace( [=s].*$,  ) )) &#123;\treturn function spreadFn(argsObj) &#123;\t\treturn fn( ...propOrder.map( k =&gt; argsObj[k] ) );\t&#125;;&#125;\n让我们看看 spreadArgProps(..) 实用函数是怎么用的：\n123456789101112function bar(x,y,z) &#123;\tconsole.log( `x:$&#123;x&#125; y:$&#123;y&#125; z:$&#123;z&#125;` );&#125;var f3 = curryProps( spreadArgProps( bar ), 3 );var f4 = partialProps( spreadArgProps( bar ), &#123; y: 2 &#125; );f3( &#123;y: 2&#125; )( &#123;x: 1&#125; )( &#123;z: 3&#125; ); x:1 y:2 z:3f4( &#123; z: 3, x: 1 &#125; ); x:1 y:2 z:3\n虽然上面的方法看上去有些不靠谱，但是它确实能解决我们实际的问题，至少解决了80%的情况。\n无形参风格在函数式编程中，还有一种流行的代码风格，其目的是通过移除不必要的形参-实参映射来减少视觉上的干扰。这种风格的正式名称为 “隐性编程（tacit programming）”，一般则称作 “无形参（point-free）” 风格。术语 “point” 在这里指的是函数形参。\n我们从一个简单的例子开始：\n12345678function double(x) &#123;\treturn x * 2;&#125;[1,2,3,4,5].map( function mapper(v)&#123;\treturn double( v );&#125; ); [2,4,6,8,10]\n可以看到 mapper(..) 函数和 double(..) 函数有相同（或相互兼容）的函数签名。形参（也就是所谓的 “point“）v 可以直接映射到 double(..) 函数调用里相应的实参上。这样，mapper(..) 函数包装层是非必需的。我们可以将其简化为无形参风格：\n123456function double(x) &#123;\treturn x * 2;&#125;[1,2,3,4,5].map( double ); [2,4,6,8,10]\n还有之前parseInt()的例子：\n12345678[1,2,3].map( function mapper(v)&#123;\treturn parseInt( v );&#125; ); [1,2,3]=&gt; 无形参风格：[1,2,3].map( unary( parseInt ) ); [1,2,3]\n借助unary()函数使得每次只传一个参数。\nnot函数首先来看一个案例：\n12345678910111213141516171819function output(txt) &#123;\tconsole.log( txt );&#125;function printIf( predicate, msg ) &#123;\tif (predicate( msg )) &#123;\t\toutput( msg );\t&#125;&#125;function isShortEnough(str) &#123;\treturn str.length &lt;= 5;&#125;var msg1 = Hello;var msg2 = msg1 +  World;printIf( isShortEnough, msg1 );\t\t\t HelloprintIf( isShortEnough, msg2 );\n案例很简单，我们要求当信息足够长时，将它打印出来，换而言之，我们需要一个 !isShortEnough(..) 断言。你可能会首先想到：\n123456function isLongEnough(str) &#123;\treturn !isShortEnough( str );&#125;printIf( isLongEnough, msg1 );printIf( isLongEnough, msg2 );\t\t\t Hello World\n上面的方式看似是很简单的，但是还是需要我们传递str，现在我们能否不通过重新实现 str.length 的检查逻辑，而重构代码并使其变成无形参风格呢？\n我们定义一个 not(..) 取反辅助函数（在函数式编程库中又被称作 complement(..)）：\n1234567891011function not(predicate) &#123;\treturn function negated(...args)&#123;\t\treturn !predicate( ...args );\t&#125;;&#125; ES6 箭头函数形式var not =\tpredicate =&gt;\t\t(...args) =&gt;\t\t\t!predicate( ...args );\n传入的predicate为断言，也就是条件。\n现在我们可以用not函数来修改上面的例子：\n123var isLongEnough = not( isShortEnough )printIf( isLongEnough, msg2 )   Hello World\nwhen函数到目前位置，上面的案例已经被我们优化的不错了。但是也许还能再进一步，我们实际上可以将 printIf(..) 函数本身重构成无形参风格。\n我们可以用 when(..) 实用函数来表示 if 条件句：\n1234567891011function when (predicate, fn) &#123;    return function conditional (...args) &#123;        if (predicate(...args)) &#123;            return fn(...args)        &#125;    &#125;&#125; ES6var when = (predicate, fn) =&gt;                 (...args) =&gt;                     predicate(...args) ? fn(...args) : undefined\n我们把本章前面讲到的另一些辅助函数和 when(..) 函数结合起来搞定无形参风格的 printIf(..) 函数：\n1var printIf = uncurry( partialRight( when, output ) );\n\n我们是这么做的：将 output 方法右偏应用为 when(..) 函数的第二个（fn 形参）实参，这样我们得到了一个仍然期望接收第一个实参（predicate 形参）的函数。当该函数被调用时，会产生另一个期望接收（译者注：需要被打印的）信息字符串的函数，看起来就是这样：fn(predicate)(str)。\n多个（两个）链式函数的调用看起来很挫，就像被柯里化的函数。于是我们用 uncurry(..) 函数处理它，得到一个期望接收 str 和 predicate 两个实参的函数，这样该函数的签名就和 printIf(predicate,str) 原函数一样了。\n\nprintIf案例现在我们可以将上面的printIf整理一下：\n1234567891011121314151617181920function output(msg) &#123;\tconsole.log( msg );&#125;function isShortEnough(str) &#123;\treturn str.length &lt;= 5;&#125;var isLongEnough = not( isShortEnough );var printIf = uncurry( partialRight( when, output ) );var msg1 = Hello;var msg2 = msg1 +  World;printIf( isShortEnough, msg1 );\t\t\t HelloprintIf( isShortEnough, msg2 );printIf( isLongEnough, msg1 );printIf( isLongEnough, msg2 );\t\t\t Hello World\nlist案例实现功能：\n若是列表中的数大于3则添加进greater，否则添加进less。\n这种简单的案例虽然可以用十分简单的方式来实现，但是为了习惯函数式编程的写法，所以算是我做一个小练习吧。\n1234567891011121314151617181920var list = [1, 2, 3, 4, 5]var greater = []var less = []var isGreater = (val) =&gt; val &gt; 3;var pushGreater = (val) =&gt; greater.push(val);var pushLess = (val) =&gt; less.push(val);var handleFn = fn =&gt; uncurry( partialRight( when, fn ) )var setGreater = handleFn( pushGreater )var setLess = handleFn( pushLess )function handleList (list) &#123;    list.forEach(val =&gt; &#123;        setGreater(isGreater, val)        setLess(not(isGreater), val)    &#125;)    console.log(greater, greater)    console.log(less, less)&#125;handleList(list) greater [4, 5] less [1, 2, 3]\n总结\n偏应用是用来减少函数的参数数量 —— 一个函数期望接收的实参数量 —— 的技术，它减少参数数量的方式是创建一个预设了部分实参的新函数。\n柯里化是偏应用的一种特殊形式，其参数数量降低为 1，这种形式包含一串连续的链式函数调用，每个调用接收一个实参。当这些链式调用指定了所有实参时，原函数就会拿到收集好的实参并执行。你同样可以将柯里化还原。\n其它类似 unary(..)、identity(..) 以及 constant(..) 的重要函数操作，是函数式编程基础工具库的一部分。\n无形参是一种书写代码的风格，这种风格移除了非必需的形参映射实参逻辑，其目的在于提高代码的可读性和可理解性。\n\n","tags":["前端进阶","Functional"],"path":"2019/06/27/webNotes/advanced/Functional/ch_3/","external_link":""},{"title":"霖呆呆的函数式编程之路(一)","date":"2019-06-16T11:24:00.000Z","content":"霖呆呆的函数式编程之路(一)1. 函数式编程能解决的问题\n可扩展性–我是否需要不断地重构代码来支持额外的功能？\n易模块化–如果我更改了一个文件，另一个文件是否会受到影响？\n可重用性–是否有很多重复的代码？\n可测性–给这些函数添加单元测试是否让我纠结？\n易推理性–我写的代码是否非结构化严重并难以推理？\n\n2. 学习之前你需要了解的一些概念函数输入在数学中，函数总是获取一些输入值，然后给出一个输出值。\n但在程序中，它或许有许多个输入值，或许没有。它或许有一个输出值（ return 值），或许没有。\n从上述的定义出发，所有的函数都需要输入。\n大多数情况下，人们把函数的输入值称为 “arguments” 或者 “parameters” 。所以它到底是什么？\narguments 是你输入的值（实参）， parameters 是函数中的命名变量（形参），用于接收函数的输入值。例子如下：\n123456function fn (x, y) &#123;\tconsole.log(x, y)&#125;fn(3, 4) 3, 4\n3 和 4是函数 fn(..) 调用的 arguments。x 和 y 是 parameters，用于接收参数值（分别为 3 和 4 ）。\n在javascript中定义的形参和实参可以是不等的：\n123456function fn (x, y) &#123;\tconsole.log(x, y)&#125;fn(3) 3, undefined\n你传入少于声明形参个数的实参，所有缺少的参数将会被赋予 undefined 变量，意味着你仍然可以在函数作用域中使用它，但值是 undefined。\n输入计数一个函数所“期望”的实参个数是取决于已声明的形参个数，即你希望传入多少参数。\n如以下函数：\n123function fn (x, y, z) &#123;\tconsole.log(x, y, z)&#125;\nfn期望三个参数，因为它声明了三个形参。这里有一个特殊的术语：Arity。Arity 指的是一个函数声明的形参数量。 fn(..) 的 Arity 是 3。\n函数的length你可能需要在程序运行时获取函数的 Arity，使用函数的 length 属性即可。\n1234function fn (x, y, z) &#123;\tconsole.log(x, y, z)&#125;fn.length   3\n提示： 函数的 length 属性是一个只读属性，并且它是在最初声明函数的时候就被确定了。它应该当做用来描述如何使用该函数的一个基本元数据。\n引入ES6特性的一些函数的length:\n123456789101112131415function foo(x,y = 2) &#123;\t ..&#125;function bar(x,...args) &#123;\t ..&#125;function baz( &#123;a,b&#125; ) &#123;\t ..&#125;foo.length;\t\t\t\t 1bar.length;\t\t\t\t 1baz.length;\t\t\t\t 1\narguments上面我们已经知道了，可以用函数的length属性来获取到这个函数的形参个数，但是在实际使用时，我们更需要知道的是函数传入的实参个数，此时可以使用每个函数都有的arguments对象(类数组)，来获取到传入的实参个数。\n如下面这个例子：\n12345function foo(x,y,z) &#123;\tconsole.log( arguments.length );\t 2&#125;foo( 3, 4 );\n由于 ES5（特别是严格模式下）的 arguments 不被一些人认同，很多人尽可能地避免使用。尽管如此，它永远不会被移除，这是因为在 JS 中我们“永远不会”因为便利性而去牺牲向后的兼容性，但是大多数人还是不建议使用它。\n所以你只需要知道以下几点：\n\n当你需要知道参数个数的时候，arguments.length 还是可以用的。\n不要通过 arguments[1] 访问参数的位置。只要记住 arguments.length。\n\n…ES6获取剩余参数当你需要像数组那样访问参数，很有可能的原因是你想要获取的参数没有在一个规范的位置。我们如何处理？\nES6 救星来了！让我们用 ... 操作符声明我们的函数，也被当做 “spread”、“rest” 或者 “gather” (我比较偏爱)提及。\n123function foo(x,y,z,...args) &#123;\t ..&#125;\n看到参数列表中的 ...args 了吗？那就是 ES6 用来告诉解析引擎获取所有剩余的未命名参数，并把它们放在一个真实的命名为 args 的数组。args 无论是不是空的，它永远是一个数组。但它不包含已经命名的 x，y 和 z 参数，只会包含超出前三个值的传入参数.\n12345678function foo(x,y,z,...args) &#123;\tconsole.log( x, y, z, args );&#125;foo();\t\t\t\t\t undefined undefined undefined []foo( 1, 2, 3 );\t\t\t 1 2 3 []foo( 1, 2, 3, 4 );\t\t 1 2 3 [ 4 ]foo( 1, 2, 3, 4, 5 );\t 1 2 3 [ 4, 5 ]\n你甚至可以直接在参数列中使用 ... 操作符，没有其他正式声明的参数也没关系：\n12345function foo(...args) &#123;\tconsole.log(args)&#125;foo(1, 2);      [1, 2]\n现在 args 是一个由参数组成的完整数组，你可以尽情使用 args.length 来获取传入的参数。你也可以安全地使用 args[1] .\n关于实参的小技巧如果你希望调用函数的时候只传一个数组代替之前的多个参数，该怎么办？\n1234567function foo(...args) &#123;\tconsole.log( args[3] );&#125;var arr = [ 1, 2, 3, 4, 5 ];foo( ...arr );\t\t\t\t\t\t 4\n…操作符在这里也被用到了。\n在形参中使用的时候function foo(…args){}，是将形参整合，形成一个数组：\n123function foo(x, y)&#123;&#125; 经过...之后变为function foo([x, y])&#123;&#125;\n在实参中使用的时候foo(…arr)，是将实参展开：\n123foo([1, 2, 3]) 经过...之后变为foo(1, 2)\n你甚至可以多个值和…一起来使用：\n12345678function foo(...args) &#123;\tconsole.log( args[3] );&#125;var arr = [ 2 ];foo( 1, ...arr, 3, ...[4,5] );\t\t 4 相当于是foo(1, 2, 3, 4, 5); 所以获取到的args[3]为4\n关于形参的小技巧默认参数\n在 ES6 中，形参可以声明默认值。当形参没有传入到实参中，或者传入值是 undefined，会进行默认赋值的操作：\n12345678function foo(x = 3) &#123;\tconsole.log( x );&#125;foo();\t\t\t\t\t 3foo( undefined );\t\t 3foo( null );\t\t\t nullfoo( 0 );\t\t\t\t 0\n解构\n现在有这么一个函数：\n12345function foo(params) &#123;\tconsole.log(params)&#125;foo([1, 2, 3])\n我在拿到args数组之后，想要命名传入数组的第 1、2 个值，也许你可以这么做：\n123456789 example1function foo(params) &#123;\tconsole.log(params)  [1, 2, 3]\tvar x = params[0]  1\tvar y = params[1]  2\tvar args = params.slice( 2 )  [3] (args就是剩余的参数集合)&#125;foo([1, 2, 3])\n现在你可以用更酷的ES解构的方式来写这个函数：\n12345678 examplefunction foo( [x,y,...args] = [] ) &#123;\tconsole.log(x)  1\tconsole.log(y)  2\tconsole.log(args)  [3]&#125;foo( [1,2,3] );\n上面的这种[x, y, …args] = []就是一种数组解构，解构是通过你期望的模式来描述数据（对象，数组等），并分配（赋值）值的一种方式。\n在这里例子中，解构告诉解析器，一个数组应该出现的赋值位置（即参数）。这种模式是：拿出数组中的第一个值，并且赋值给局部参数变量 x，第二个赋值给 y，剩下的则组成 args。\n同样这种解构也可以用在对象中，称为对象解构：\n1234567function foo( &#123;x,y&#125; = &#123;&#125; ) &#123;\tconsole.log( x, y );&#125;foo( &#123;\ty: 3&#125; );\t\t\t\t\t undefined 3\n我们传入一个对象作为一个参数，它解构成两个独立的参数变量 x 和 y，从传入的对象中分配相应属性名的值。我们不在意属性值 x 到底存不存在对象上，如果不存在，它最终会如你所想被赋值为 undefined。\n通过上面的学习，我们需要认识到很重要的一个原则：声明性代码通常比命令式代码更干净。\n声明性代码也就是上面的example2,在定义形参的时候就给参数命好名，而example1就是命令式代码，它在拿到形参之后再进行命名。\n随着输入而变化的函数现在有这么一个函数：\n12345678function foo(x,y) &#123;\tif (typeof x == number &amp;&amp; typeof y == number) &#123;\t\treturn x * y;\t&#125;\telse &#123;\t\treturn x + y;\t&#125;&#125;\n明显地，这个函数会根据你传入的值而有所不同，比如：\n123foo( 3, 4 );\t\t\t 12foo( 3, 4 );\t\t\t 34\n程序员这样定义函数的原因之一是，更容易通过同一个函数来重载不同的功能。乍一看这样设计一个函数好像很方便，使得我们的函数可以有很多不同的行为，其实通过不同的输入值让一个函数重载拥有不同的行为的技巧叫做特定多态（ad hoc polymorphism）。但在函数式编程中，要对方便的诱惑有警惕之心。因为你可以通过这种方式设计一个函数，即使可以立即使用，但这个设计的长期成本可能会让你后悔。\n函数输出在 JavaScript 中，函数只会返回一个值。下面的三个函数都有相同的 return 操作。\n123456789function foo() &#123;&#125;function bar() &#123;\treturn;&#125;function baz() &#123;\treturn undefined;&#125;\n如果你没有 return 值，或者你使用 return;，那么则会隐式地返回 undefined 值。\n如果想要尽可能靠近函数式编程的定义：使用函数而非程序，那么我们的函数必须永远有返回值。这也意味着他们必须明确地 return 一个值，通常这个值也不是 undefined。\n上面已经说了一个函数只能有一个返回值，那么如果我们现在想要一次返回多个值怎么办？切实可行的办法就是把你需要返回的值放到一个复合值当中去，例如数组、对象：\n123456function foo() &#123;\tvar retValue1 = 11;\tvar retValue2 = 31;\treturn [ retValue1, retValue2 ];\t 或者 return &#123; retValue1, retValue2 &#125;&#125;\n解构方法可以使用于解构对象或者数组类型的参数，也可以使用在平时的赋值当中：\n12345678function foo() &#123;\tvar retValue1 = 11;\tvar retValue2 = 31;\treturn [ retValue1, retValue2 ];&#125;var [ x, y ] = foo();console.log( x + y );\t\t\t 42\n将多个值集合成一个数组（或对象）做为返回值，然后再解构回不同的值，这无形中让一个函数能有多个输出结果。\n提前returnreturn 语句不仅仅是从函数中返回一个值，它也是一个流量控制结构，它可以结束函数的执行。因此，具有多个 return语句的函数具有多个可能的退出点，这意味着如果输出的路径很多，可能难以读取并理解函数的输出行为。\n现在有这么一个例子：\n12345678910111213function foo(x) &#123;\tif (x &gt; 10) return x + 1;\tvar y = x  2;\tif (y &gt; 3) &#123;\t\tif (x % 2 == 0) return x;\t&#125;\tif (y &gt; 1) return y;\treturn x;&#125;\n请思考 foo(2) 返回什么？ foo(4) 返回什么？ foo(8)， foo(12) 呢？\n你对自己的回答有多少信心？你付出多少精力来获得答案？\n我认为在许多可读性的问题上，是因为我们不仅使用 return 返回不同的值，更把它作为一个流控制结构——在某些情况下可以提前退出一个函数的执行。我们显然有更好的方法来编写流控制（ if 逻辑等），也有办法使输出路径更加明显。\n上面的答案分别是：2,2,8,13。\n现在我们把上面的代码换个版本：\n12345678910111213141516171819202122232425function foo(x) &#123;\tvar retValue;\tif (retValue == undefined &amp;&amp; x &gt; 10) &#123;\t\tretValue = x + 1;\t&#125;\tvar y = x  2;\tif (y &gt; 3) &#123;\t\tif (retValue == undefined &amp;&amp; x % 2 == 0) &#123;\t\t\tretValue = x;\t\t&#125;\t&#125;\tif (retValue == undefined &amp;&amp; y &gt; 1) &#123;\t\tretValue = y;\t&#125;\tif (retValue == undefined) &#123;\t\tretValue = x;\t&#125;\treturn retValue;&#125;\n这个版本毫无疑问是更冗长的。但是在逻辑上，我认为这比上面的代码更容易理解。因为在每个 retValue 可以被设置的分支， 这里都有个守护者以确保 retValue 没有被设置过才执行。\n相比在函数中提早使用 return，我们更应该用常用的流控制（ if 逻辑 ）来控制 retValue 的赋值。到最后，我们 return retValue。\n未return的输出和纯函数有个技巧你可能在你的大多数代码里面使用过，并且有可能你自己并没有特别意识到，那就是让一个函数通过改变函数体外的变量产出一些值。\n比如我们现在想要设计一个这样功能的函数:f(x) = 2x + 3:\n123456var y;function foo(x) &#123;\ty = 2 * x + 3;&#125;foo( 2 );y; \t\t\t 7\n或许我们完全可以用 return 来返回，而不是赋值给 y：\n1234567function foo(x) &#123;\treturn 2 * x + 3;&#125;var y = foo( 2 );y;\t\t\t\t\t\t 7\n这两个函数完成相同的任务。解释这两者不同的一种方法是，后一个版本中的 return 表示一个显式输出，而前者的 y 赋值是一个隐式输出。在这种情况下，我们开发人员肯定更喜欢显示模式而非隐式。\n但是，改变一个外部作用域的变量，就像我们在 foo(..) 中所做的赋值 y 一样，只是实现隐式输出的一种方式。一个更微妙的例子是通过引用对非局部值进行更改。\n1234567891011121314function sum(list) &#123;\tvar total = 0;\tfor (let i = 0; i &lt; list.length; i++) &#123;\t\tif (!list[i]) list[i] = 0;\t\ttotal = total + list[i];\t&#125;\treturn total;&#125;var nums = [ 1, 3, 9, 27, , 84 ];sum( nums );\t\t\t 124\n上面的例子中，我们知道这个函数输出为124，并且也非常明确的return了，但你是否发现其他的输出？查看代码，并检查 nums 数组。你发现区别了吗？\n为了填补 4 位置的空值 undefined，这里使用了 0 代替。尽管我们在局部操作 list 参数变量，但我们仍然影响了外部的数组。\n因为 list 使用了 nums 的引用，不是对 [1,3,9,..] 的值复制，而是引用复制。因为 JS 对数组、对象和函数都使用引用和引用复制，我们可以很容易地从函数中创建输出，即使是无心的。\n这个隐式函数输出在函数式编程中有一个特殊的名称：副作用。当然，没有副作用的函数也有一个特殊的名称：纯函数。我们将在以后的章节讨论这些，但关键是我们应该喜欢纯函数，并且要尽可能地避免副作用。\n函数功能高阶函数函数是可以接受并且返回任何类型的值。一个函数如果可以接受或返回一个甚至多个函数，它被叫做高阶函数。\n例如：\n12345678910function forEach(list,fn) &#123;\tfor (let i = 0; i &lt; list.length; i++) &#123;\t\tfn( list[i] );\t&#125;&#125;forEach( [1,2,3,4,5], function each(val)&#123;\tconsole.log( val );&#125; ); 1 2 3 4 5\nforEach(..) 就是一个高阶函数，因为它可以接受一个函数作为参数。\n一个高阶函数同样可以把一个函数作为输出，像这样：\n1234567891011function foo() &#123;\tvar fn = function inner(msg)&#123;\t\tconsole.log( msg );\t&#125;;\treturn fn;&#125;var f = foo();f( Hello! );\t\t\t Hello!\nreturn 不是“输出”函数的唯一办法。可以看下面这个例子：\n12345678910111213function foo() &#123;\tvar fn = function inner(msg)&#123;\t\tconsole.log( msg );\t&#125;;\tbar( fn );&#125;function bar(func) &#123;\tfunc( Hello! );&#125;foo();\t\t\t\t\t Hello!\n如果你感觉看起来很吃力，或者不理解什么意思，我建议你最好自己手敲一遍，并要习惯这样的写法，因为将其他函数视为值的函数是高阶函数的定义。函数式编程者们应该学会这样写！\n保持作用域在所有编程，尤其是函数式编程中，最强大的就是：当一个函数内部存在另一个函数的作用域时，对当前函数进行操作。当内部函数从外部函数引用变量，这被称作闭包。\n比如我们来看一些闭包的例子：\n12345678910111213function person(id) &#123;\tvar randNumber = Math.random();\treturn function identify()&#123;\t\tconsole.log( I am  + id + :  + randNumber );\t&#125;;&#125;var fred = person( Fred );var susan = person( Susan );fred();\t\t\t\t\t I am Fred: 0.8331252801601532susan();\t\t\t\t I am Susan: 0.3940753308893741\nidentify() 函数内部有两个闭包变量，参数 id 和 randNumber。\n闭包不仅限于获取变量的原始值：它不仅仅是快照，而是直接链接。你可以更新该值，并在下次访问时获取更新后的值。\n1234567891011121314function runningCounter(start) &#123;\tvar val = start;\treturn function current(increment = 1)&#123;\t\tval = val + increment;\t\treturn val;\t&#125;;&#125;var score = runningCounter( 0 );score();\t\t\t\t 1score();\t\t\t\t 2score( 13 );\t\t\t 15\n上面的写法，就是闭包中一个典型的例子。\n我们将函数runningCounter()函数赋值给变量score，此时将0传递进函数中，也就是start变量，并将其赋值给val变量。在后面调用score()函数的时候，传递的实参也就是传递给runningCounter()函数的返回值current()函数。\n执行第一个score()函数的时候就相当于执行：\n1234current(1) &#123;\tval = 0 + 1;\treturn val&#125;\n此时runningCounter函数中的变量val变为了1并且被记录下来(这也意味着下次在调用的时候val的值还是1)。\n执行第二个时：\n1234current(1) &#123;  val = 1 + 1;  return val&#125;\n第三次：\n1234current(1) &#123;  val = 2 + 13;  return val&#125;\n利用js闭包的这种特性，我们可以做下面的事：\n如果你需要设置两个输入，一个你已经知道，另一个还需要后面才能知道，你可以使用闭包来记录第一个输入值，就像这样：\n123456789101112131415function makeAdder(x) &#123;\treturn function sum(y)&#123;\t\treturn x + y;\t&#125;;&#125;我们已经分别知道作为第一个输入的 10 和 37var addTo10 = makeAdder( 10 );var addTo37 = makeAdder( 37 ); 紧接着，我们指定第二个参数addTo10( 3 );\t\t\t 13addTo10( 90 );\t\t\t 100addTo37( 13 );\t\t\t 50\n通常， sum(..) 函数会一起接收 x 和 y 并相加。但是在这个例子中，我们接收并且首先记录（通过闭包） x 的值，然后等待 y 被指定。\n在连续函数调用中指定输入，这种技巧在函数式编程中非常普遍，并且有两种形式：偏函数应用和柯里化。在后面的章节中我们会进行详细的讲解。\n当然，因为函数如果只是 JS 中的值，我们可以通过闭包来记住函数值，就像这个例子：\n1234567891011121314151617function formatter(formatFn) &#123;\treturn function inner(str)&#123;\t\treturn formatFn( str );\t&#125;;&#125;var lower = formatter( function formatting(v)&#123;\treturn v.toLowerCase();&#125; );var upperFirst = formatter( function formatting(v)&#123;\treturn v[0].toUpperCase() + v.substr( 1 ).toLowerCase();&#125; );lower( WOW );\t\t\t\t wowupperFirst( hello );\t\t Hello\n我知道看到这里你可能就有疑问了，感觉上面的代码是否有太多重复的逻辑，而且为什么要有一个formatter()函数来做一个中间件样的载体。\n函数式编程并不是在我们的代码中分配或重复 toUpperCase() 和 toLowerCase() 逻辑，而是鼓励我们用优雅的封装方式来创建简单的函数。\n具体来说，我们创建两个简单的一元函数 lower（..） 和 upperFirst（..），因为这些函数在我们程序中，更容易与其他函数配合使用。\n后语这一章节主要是介绍了函数式编程的一些入门知识点，为后面更加复杂的知识点打好基础。参考资料：Functional-Light-JS\n","tags":["前端进阶","Functional"],"path":"2019/06/16/webNotes/advanced/Functional/ch_1/","external_link":""},{"title":"Angular自定义组件-UI组件篇-switch组件","date":"2018-10-21T08:57:45.000Z","content":"前言\n前端框架多吗？多！前端UI组件库多吗？更多！我们都知道，前端生态圈里提供了各色各样的组件库供我们选择使用，大多数都能满足开发者的需求，相信大家也都用过很多。但是实际上，据我了解到的，稍微大一些有自己产品的公司都会有一套自定义的UI组件库，满足自身复杂的需求与绚丽的效果。博主目前所在的公司也有一套自己的产品，PC端所用的前端框架是Angular4.Angular4其实也有它专门定制的前端组件库PrimeNg.就像Vue.js有Element一样.那么按理在开发中我们已经有了前端组件库可以使用，为什么还要花那么多的精力和时间来重新设计UI组件呢？话不多说，先上几张官方提供的UI组件图：确实不是我吐槽,官方提供的一些组件样式真的有点奇怪😭…虽然Angular官网组件样式这一文档中已经说明了可以用::ng-deep来进行对组件样式的修改,但修改起来还是比较麻烦。有那时间，自己都已经撸了一个了…（项目中用的primeng是v4.2.2版本的,目前已经迭代到了v6.1.5,所以现在官网上看到的inputSwitch组件会比这个好看点）emmm….为了追求用户体验(呸,熟悉angular4的使用)所以博主决定利用闲暇之余自定义一些UI组件,以满足我们产品”一些无礼的要求”。\n一、确定组件存放的位置一个项目中会有各种文件、文件夹，如何存放管理好这些文件真的很重要。不仅为自己提供了方便，也为后来的开发者提供方便。所以我们在设计公用组件的时候也应该把它们都归结在一起。我习惯在项目中新建一个common文件夹，里面存放一些共用的compoent，service等等。如上图，可以看到common文件夹下导出的是一个名为shared的模块。shared模块的创建过程：（1）打开命令行(使用vscode编辑器的小伙可以直接使用Ctrl+` 快捷键打开终端,然后一路跳转到common文件夹:1cd srcappcommon\n(2) 使用创建模块的指令：1ng g m shared\n其实很好理解:ng为angular一贯的指令,g为generate创建的缩写,m为module模块的缩写,后面接着你的模块名。(后面创建组件也是这个原理)创建的模块实际上导出的是一个带有@NgModule装饰器的类而已，其中提供了我们自定义的公有组件component，公有服务service，以及管道pipe等等。\n二、创建组件由于我们要创建的是一个switch公用组件，所以在component文件夹下在创建一个文件夹general-control，之前都是直接堆积在component文件夹下的，近期发现堆得有点多了，所以又单独创建了一个general-control文件夹来存放一些基础的公用组件。此时你需要打开命令行(使用vscode编辑器的小伙可以直接使用Ctrl+` 快捷键打开终端,然后一路跳转到general-control文件夹：1cd srcappcommoncomponentgeneral-control\n在此目录下执行指令：1ng g c switch\n上面指令的意思是创建一个名为switch的组件，原理和创建模块时一样。可以看到现在的general-control文件夹下多出了一些东西：没错,就是我们使用指令创建的switch组件。指令会自动帮你生成一个文件夹和4个文件。(基于TypeScript的语法，所以生成的js文件也就是ts)很好理解，对应的html文件编写HTML代码，css文件编写CSS代码，ts文件编写js代码，至于spec.ts文件我们可以不用管它。由于我在项目中使用的是sass，所以将switch.component.css这个文件的后缀名修改为scss（使用了less等其它扩展语言的小伙同理）,并在ts中对css的引用进行修改：\n使用上面的指令创建的组件是会被自动引用到shared这个模块中的。shared.module.ts:12345678import &#123; SwitchComponent &#125; from .componentgeneral-controlswitchswitch.component;模块中import引入组件@NgModule(&#123;declarations: [  SwitchComponent  模块中声明组件  ...  ]&#125;)\n上面俩步是你在使用ng g c switch指令时自动帮你完成的，但若是你想在其它的模块中使用这个switch组件，还得将其导出，导出的方式是将这个组件添加至shared.module.ts文件的exports中：123456789101112import &#123; SwitchComponent &#125; from .componentgeneral-controlswitchswitch.component;模块中import引入组件@NgModule(&#123;  declarations: [    SwitchComponent  模块中声明组件    ...    ],  exports: [    SwitchComponent  模块中导出组件    ...  ]&#125;)\n完成上面的步骤你就可以安心的来开发自己的组件了。\n三、编写switch组件一番查找，发现网上也有很多自定义switch组件的文章和源码，可能是大家都觉得原生的样式不好看吧…有使用input然后来进行修改样式的，也有用其它标签来自定义的。博主这里找了一个最简单方案，一个span标签搞定：1234 switch.component.html&lt;span class=weui-switch [ngClass]=currentClass [ngStyle]=style (click)=toggle()&gt;    &lt;span&gt;\n基础css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 switch.comonent.scss.weui-switch &#123;    display: inline-block;    position: relative;    width: 38px;    height: 23px;    border: 1px solid #DFDFDF;    outline: 0;    border-radius: 16px;    box-sizing: border-box;    background-color: #DFDFDF;    transition: background-color 0.1s, border 0.1s;    cursor: pointer;    &amp;.disabled&#123;      opacity: 0.6;      cursor: not-allowed;    &#125;  &#125;  .weui-switch:before &#123;    content:  ;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;    border-radius: 15px;    background-color: #FDFDFD;    transition: transform 0.35s cubic-bezier(0.45, 1, 0.4, 1);  &#125;  .weui-switch:after &#123;    content:  ;    position: absolute;    top: 0;    left: 0;    width: 56%;    height: 97%;    border-radius: 15px;    background-color: #FFFFFF;    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);    transition: transform 0.35s cubic-bezier(0.4, 0.4, 0.25, 1.35);  &#125;  .weui-switch-on &#123;    border-color: #1AAD19;    background-color: #1AAD19;  &#125;  .weui-switch-on:before &#123;    border-color: #1AAD19;    background-color: #1AAD19;  &#125;  .weui-switch-on:after &#123;    transform: translateX(77%);  &#125;\n效果大概就是这个样子:（录频并转换GIF推荐使用GifGam）可以看到，组件的样式设计大多都是使用伪类:after和:before来实现的，而开关的效果是通过点击的时候添加移除class名weui-switch-on来实现的。（讲js的时候会讲到）\n由于我们创建的switch组件是需要在多处使用，并且要向外输出一些值，所以在ts中我们首先要引入一下@Input、@Output装饰器和EventEmitter。1import &#123; Component, OnInit, Input, Output, EventEmitter, OnChanges &#125; from @angularcore;\n并且定义一些基础的变量123456@Input() style;&#123; width: 40px &#125;外部组件输入的样式对象@Input() isChecked: boolean = false;开关是否打开@Input() disabled: boolean = false;开关是否被禁用@Output() change: EventEmitter&lt;any&gt; = new EventEmitter();_isSwitch: boolean = false;currentClass = &#123;&#125;\n此时我们的ts变成了这样：1234567891011121314151617181920212223import &#123; Component, OnInit, Input, Output, EventEmitter, OnChanges &#125; from @angularcore;@Component(&#123;  selector: app-switch,  templateUrl: .switch.component.html,  styleUrls: [.switch.component.scss]&#125;)export class SwitchComponent implements OnInit, OnChanges &#123;  constructor() &#123; &#125;  @Input() style;&#123; width: 40px &#125;外部组件输入的样式对象  @Input() isChecked: boolean = false;外部组件输入进来的：开关是否打开  @Input() disabled: boolean = false;开关是否被禁用  @Output() change: EventEmitter&lt;any&gt; = new EventEmitter();  _isSwitch: boolean = false;switch组件本身的：开关是否打开  currentClass = &#123;&#125; class集合    ngOnInit() &#123;初始化组件的生命周期      &#125;  ngOnChanges() &#123;当被绑定的输入属性的值发生变化时调用      &#125;&#125;\n3.1 setIsSwitch()方法组件中定义了俩个“开关是否打开”的变量isChecked和_isSwitch一个是外部组件传递进来的默认值，一个是 switch组件自身的值。所以在组件进行初始化和发生改变的时候我们应该让其统一：123456789ngOnInit() &#123;初始化组件的生命周期  this.setIsSwitch();&#125;ngOnChanges() &#123;当被绑定的输入属性的值发生变化时调用  this.setIsSwitch();&#125;setIsSwitch() &#123;设置_isSwitch  this._isSwitch = this.isChecked;&#125;\n3.2 setStyle()方法由于是自定义的组件，我们当然是希望大小也可以自定义，所以我想要的效果是：在调用组件的时候，输入一个宽度width属性，组件能够自动调节尺寸。因此我在设计的时候就定义了一个style变量它是一个对象，可以允许开发者输入任意的样式，格式为{ &#39;width&#39;: &#39;40px&#39; }同时为了减少输入样式的复杂度，我们还可以来编写一个方法，让组件能够根据宽度来调节高度：1234567891011121314setStyle() &#123;设置样式    if (this.style) &#123;      if (this.style[width] &amp;&amp; !this.style[height]) &#123;若是输入了宽度没有输入高度则自动计算        let width = this.getWidth(this.style[width]);        this.style[height] = (width * 0.55) + px;      &#125;    &#125;  &#125;getWidth(widthStr) &#123;判断用户输入的width带不带px单位    let reg = px;    let width = reg.test(widthStr) ? widthStr.match((d*)px)[1] : widthStr 正则获取不带单位的值    if (!width) width = 0;    return width;  &#125;\n可以看到，上面我编写的setStyle()方法是判断有没有宽度和高度，并将高度设置为0.55 * width(0.55为我找到的最合适的比例)\n3.3 setClass()方法完成了上面的步骤我们基本就完成了对组件样式的初始化，但是，最重要的一步当然是通过添加移除一些类来进行组件的交互：123456setClass() &#123;转换switch时切换class   this.currentClass = &#123;     disabled: this.disabled,     bg_main bor_main weui-switch-on: this._isSwitch   &#125; &#125;\n对象currentClass存储的是组件变动的类名，对象的键名为类名，值为一个布尔类型的变量(true  false)通过布尔类型的变量来判断添加还是移除这些类名。第一个类disabled表示的是开关是否被禁用，也就是用户只能查看开关，并不能对其进行操作，它受disabled变量控制。第二个类为三个类名的合写bg_main、bor_main、和weui-switch-on，他们受_isSwitch变量控制，也就是开关打开的时候则添加这三个类。前俩个类名是我在项目中使用的“皮肤类名”，因为客户的需要，我们产品有几套不同的主题色，用户可以进行换肤功能来切换主题色，因此就有一些类名需要用来控制主题色。如橘色主题：123456.bg_main &#123;            background-color: #ff7920!important;&#125;.bor_main &#123;            border-color: #ff7920!important;&#125;\n当然，你若是没有主题色的话请忽略这俩个类。\n上面的几个方法我们都需要在组件初始化和变量发生改变的时候调用，所以可以整合到一个函数中：1234567891011ngOnInit() &#123;  this.initComponent();&#125;ngOnChanges() &#123;  this.initComponent();&#125;initComponent() &#123;  this.setIsSwitch();  this.setStyle();  this.setClass();&#125;\n3.4 toggle()方法光有样式可没用，我们还需要将组件和用户的行为给结合在一起，因此给组件一个click事件来进行交互，并编写toggle()方法：123456toggle() &#123;切换switch    if (this.disabled) return;若是禁用时则直接返回    this._isSwitch = !this._isSwitch;    this.isChecked = this._isSwitch;    this.change.emit(this._isSwitch); 向外部传递最新的值  &#125;\n整合后的ts文件为这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; Component, OnInit, Input, Output, EventEmitter, OnChanges &#125; from @angularcore;@Component(&#123;  selector: app-switch,  templateUrl: .switch.component.html,  styleUrls: [.switch.component.scss]&#125;)export class SwitchComponent implements OnInit, OnChanges &#123;  constructor() &#123; &#125;  @Input() onLabel: string = ;暂无  @Input() offLabel: string = ;  @Input() style;&#123; width: 40px &#125;外部组件输入的样式对象  @Input() isChecked: boolean = false;开关是否打开  @Input() disabled: boolean = false;开关是否被禁用  @Output() change: EventEmitter&lt;any&gt; = new EventEmitter();  _isSwitch: boolean = false;  currentClass = &#123;&#125;  ngOnInit() &#123;    this.initComponent();  &#125;  ngOnChanges() &#123;    this.initComponent();  &#125;  initComponent() &#123;初始化并刷新组件    this.setIsSwitch();    this.setStyle();    this.setClass();  &#125;  setIsSwitch() &#123;    this._isSwitch = this.isChecked;  &#125;  setStyle() &#123;设置样式    if (this.style) &#123;      if (this.style[width] &amp;&amp; !this.style[height]) &#123;若是输入了宽度没有输入高度则自动计算        let width = this.getWidth(this.style[width]);        this.style[height] = (width * 0.55) + px;      &#125;    &#125;  &#125;  setClass() &#123;转换switch时切换class    this.currentClass = &#123;      disabled: this.disabled,      bg_main bor_main weui-switch-on: this._isSwitch    &#125;  &#125;  getWidth(widthStr) &#123;判断用户输入的width带不带px单位    let reg = px;    let width = reg.test(widthStr) ? widthStr.match((d*)px)[1] : widthStr 正则获取不带单位的值    if (!width) width = 0;    return width;  &#125;  toggle() &#123;切换switch    if (this.disabled) return;若是禁用时则直接返回    this._isSwitch = !this._isSwitch;    this.isChecked = this._isSwitch;    this.change.emit(this._isSwitch);  &#125;&#125;\n四、引用switch组件完成了上面的部分，到了我们最激动的时候了，看看我们亲手制作的组件有没有用吧，哈哈。首先，在使用其它组件的时候，我们要将其引入进来，由于我们最开始是将switch组件引入到shared这个模块中，并从这个模块中导出的，所以想要在其它模块中使用 switch组件就得先引入shared模块。\n4.1 引入shared模块本项目中有另一个模块名为coursemanage，现在我将其作为父组件来引用一下switch组件首先在模块里引用：123456789coursemanage.module.tsimport &#123; NgModule &#125; from &apos;@angularcore&apos;;import &#123; SharedModule &#125; from &quot;...commonshared.module&quot;;@NgModule(&#123;  imports: [      SharedModule  ]&#125;)export class CourseManageModule &#123; &#125;\n引入了shared模块就相当于是引入那个那个模块中的所有组件和方法。\n4.2 使用switch组件在coursemanage模块中，有其子组件course这个组件，在course中使用switch12&lt;!--course.component.html--&gt;&lt;app-switch [isChecked]=dataStatus (change)=changeSwitch($event)&gt;&lt;app-switch&gt;\n123456course.component.tsdataStatus: boolean = false;changeSwitch($event) &#123;  this.dataStatus = $event;&#125;\n此时就完成了switch组件的编写和使用。你也可以给组件设置另一个属性disabled:12&lt;!--course.component.html--&gt;&lt;app-switch [isChecked]=dataStatus [disable]=true (change)=changeSwitch($event)&gt;&lt;app-switch&gt;\n后语上述设计的switch组件应该是UI组件中比较简单的一种UI组件了，还有更多复杂的组件有待我们的开发，通过自己设计UI组件，emmm….可以让我们更有创造力吧应该说，也促使自己多去看别人的博客与源码，最后再写上一篇总结，我认为这应该是一个正向的激励💪，哈哈，全篇废话很多，不过还是要感谢小伙的阅读🙂。\n","tags":["前端进阶","Angular"],"path":"2018/10/21/webNotes/advanced/Angular/angularOfUISwitch/","external_link":""},{"title":"JS基础知识","date":"2016-02-08T11:24:45.000Z","content":"1. 声明1.1 声明变量\nvar 声明\n\n基本的声明变量的方式是使用var来进行声明：\n1var a;\n上面的语句表示声明了一个名为a的变量,由于它只是声明了,还未进行任何的赋值,所以此时使用console.log()在控制台打印出来的是undefined:\n12var a;console.log(a);\nconsole.log()方法能够在浏览器的控制台打印出你期望看到的元素,显示控制台快捷键为f12,或者直接在页面中右键“检查”。\n\n声明提前\n\n会把声明的语句提前到脚本的最前头,但不会把赋值的语句提前;\n例:\n1234567console.log(a);     已经找到了a,因为var a 会被声明提前,但是却不会提前赋值,也就是不能找到a=10;var a = 10; console.log(a);=&gt;undefined  10 ; 第一个打印出undefined 第二个为10\n1.2 声明并赋值\n代码⌨️\n\nvar 变量名 = 值\n1var a = 10;\n\n连续声明\n\nvar 变量名1,变量名2,变量名3;\n123var a,b,c;var a = 1, b = 2, c = 3;\n1.3 let声明变量js中除了能够使用var操作符声明变量之外,还可以使用ES6中新增的操作符let进行声明：\n1let a = 10;\nlet和var在大多数时候的用法都是一样的,本质上都是为了声明一个变量,但是在一些情况上还是有一些区别，比如let声明的变量没有声明提前:\n123console.log(a); 报错ReferenceErrorlet a = 10;console.log(a)\n在比如let不允许在相同作用域内,重复声明同一个变量。\n12345678910 报错function () &#123;  let a = 10;  var a = 1;&#125; 报错function () &#123;  let a = 10;  let a = 1;&#125;\n具体的区别请移步\n1.4 const声明常量JS中除了有变量之外，也有常量。\n常量顾名思义就是指定义了之后不能进行修改。\n\nconst定义的变量不可以修改,而且必须初始化\n\n123const a = 1;正确const b;错误,必须要进行初始化\n::: tip\n当然虽然你不能直接使用const b来进行声明,但是你可以采用const b = undefined的方式来声明一个值为undefined的常量,当然实际运用中这种做法也没有什么意义。\n:::\n使用const声明了变量之后,若是你妄图重新赋值,则js会告诉你这个是不可以的。\n123const a = 1;a = 2;Uncaught TypeError: Assignment to constant variable.console.log(a);\n\nconst定义引用类型\n\n我们知道在js中的引用类型分为:值引用和地址引用。\n上面介绍的都是值引用的情况,若是用const声明一个数组或者对象然后在进行修改情况会怎么样？\n1234567const arr = [1, 2, 3];arr.push(4)console.log(arr);[1, 2, 3, 4]const obj = &#123; name: LinDaiDai &#125;;obj[sex] = boy;console.log(obj);&#123; name: LinDaiDai, sex: boy &#125;\n可以看到用const声明的数组和对象都是可以进行修改的，那么用const声明的对象和var有什么区别呢？\n来看下面这个例子：\n12345678910如果你试图这样const arr = [1, 2, 3];arr = [2, 3, 4]; Assignment to constant variableconsole.log(arr);或者这样const arr = [1, 2, 3];var arr2 = [2, 3, 4];arr = arr2;Assignment to constant variableconsole.log(arr);\n使用const声明的地址引用常量你可以修改它的值，但不能够修改它的引用地址。\n2. 内置类型JS中分为七种内置类型，而这七种内置类型又会分为两大类型：基本类型和对象(Object)。\n6种基本类型：null，undefined，boolean，number，string，symbol。\n1. Typeof\n作用：返回一个值的数据类型\n\n 用typeof 测试出来的类型都是小写的\n只能测试出6种类型:\n\nnumber\n\nboolean\n\nstring\n\nundefined\n\nobject\n\nfunction\n\n\n1.原始类型\n数值、字符串、布尔值分布返回 number、string、boolean\n123typeof 123  numbertypeof 123  stringtypeof false  boolean\n2.函数\n函数返回function\n123function f() &#123;&#125;typeof f function\n3. undefined\nundefined 和没有用 var 声明的变量，用typeof返回的是undefined`\n12345typeof undefined undefinedvar xtypeof x undefined\n4.object\n除了以上三种情况，其他情况都返回object。\n1234typeof window  objecttypeof &#123;&#125;  objecttypeof []  objecttypeof null  object\n注：\n\n空数组[]的返回值是object，这表示，JavaScript内部，数组本质上是一种特殊的对象。\n\nnull的返回值是object，这是由于历史原因造成的，1995年JavaScript语言的第一版，所有值都设计成32位，其中最低的3位用来表述数据类型，object对应的值是000。当时，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），完全没考虑null，只把它当作object的一种特殊值，32位全部为0。这是typeof null返回object的根本原因。 为了兼容以前的代码，后来就没法修改了。这并不是说null就属于对象，本质上null是一个类似于undefined的特殊值。\n\n\n\n用法\n\n实际编程中,    typeof通常用在判断语句\n1234var a = 10;if (typeof a === number) &#123;     ...&#125;\n2. NumberJS 的数字类型是浮点类型的,没有整型,只能是实数,虚数不支持。\n1. 整数\n\n二进制   用0b 开头\n\n字节:8个二进制位\n\n八进制   用0或者0o(推荐)开头\n\n\n十六进制   用0x开头\n\n转换为二进制:每一个16进制位,用4个二进制位来表示\n123 = 0001 0010 0011\n2. 浮点数\n3. 无穷大  Infinity  (正无穷大和负无穷大)\n10无穷大\n4. NaN   \nNaN的特殊:\n1.NaN 的typeof 的类型是 number;\n2.NaN 转成数字类型是 NaN ;\n3.NaN 转成布尔类型是 false;\n4.NaN 转成字符串是  NaN ;\n5.NaN == NaN =&gt;false ;\n6.NaN ===NaN =&gt;false;\n7.00 = NaN\n3.Boolean只有俩个值: true  和   false\n4.String字符串:用一对单引号&#39;&#39;或者 一对双引号&quot;&quot;括起来的字符序列.\n123LinDaiDaiLinDaiDai\n5.Undefined\n当声明一个变量但是并没有赋值时,或者没有声明的变量,变量的类型是Underfined类型\n\n1234567typeof(undefined);=&gt;undefined;Number(undefined);转成数字为NaN=&gt; NaN\nundefined的特殊之处:\n1.undefined 的typeof 的类型是 undefiend;\n2.undefined 转成数字类型为 NaN;\n3.undefined 转为布尔类型是 false;\n4.undefined 转为字符串类型是 undefined ;\n5.null == undefined =&gt; true;\n6.Null12345typeof(null);=&gt;object;Number(null)=&gt; 0\nnull的特殊之处:\n1.null 的typeof 的类型是 object;\n2.null 转成数字类型为 0;\n3.null 转为布尔类型是 false;\n4.null 转为字符串类型是 null ;\n5.null 和 任何非 null 都不相等;(但和undefined相等)\n6.null == undefined =&gt;true;\n7. Symbol\nSymbol是ES6新增的一种数据类型\n在ES5之前我们都没办法创建私有变量,只能想办法去封装.symbol 来创建私有成员\n\n\n用法⌨️\n\n123456例1:let firstName = Symbol();   创建一个Symbol   let person = &#123;&#125;;   person[firstName] = 王先生;   console.log(person[firstName]);      王先生\n具体的用法请移步\n8.Object除了上述的六种基本数据类型，其他的数据都是Object类型\n12345var obj = &#123; name: LinDaiDai &#125;;var arr = [1, 2, 3];console.log(typeof obj);console.log(typeof arr);\n3. 数据类型转换:3.1 自动类型的转换 字符串,数字,boolean 之间的转换\n\n字符串-&gt;数字:\n\n1.如果字符串例的内容全部是数字,则转换为数字,否则就是NaN;\n其实就是调用的一种叫做转换函数Number();\n2.Number()内要是有一个内容不是数字,就会返回NaN\n12345Number(123);123Number(12a);NaN\n\n数字-&gt;字符串:\n\n把数字的字面形式转换为字符串\n若是数字+字符串，则会进行隐式类型转换，讲数字转换成字符串，然后进行字符串相加\n12123 + 456123456\n内部调用的是转换函数String()\n\n字符串,数字-&gt;布尔值:\n\n0,-0,&quot;&quot;,undefined,null,false,NaN -&gt;这七种是转换为false,其余的全当做true来用(&quot;0&quot;,&quot; &quot;是true);\n如一下几种加上!都会转换为true.\n12345678var num = 0,\ta = null,\tb = NaN,\tc;!num true!a true!b true!c true\n\n布尔值 -&gt; 字符串:\n\n true -&gt; “true” \n false-&gt; “false”\n true -&gt; 1;\n flase -&gt; 0;\n3.2 强制类型转换1.使用转换函数\nBoolean()\n\nString()\n\nNumber()\n\n\n123456789101112131415Number(false);  0Number(true);  1Number(undefined);  NaNNumber(null); 0Number( 5.5 ); 5.5Number( 56 ); 56Number( 5.6.7 );  NaNNumber(new Object()) NaN\n2.转换为数字类型1. 转整形:  parseInt()字符串转数字(显式类型转换)\n例1:\n123var a = 12;parseInt(a);=&gt;  12;\n例2:\n1234567 var a = 12aa12; parseInt(a) =&gt;  12 var b = 12.3;parseInt(b)=&gt;  12\n从左到右,遇到非数字则跳出去;\n例3:\n123var a = abc;parseInt(a);=&gt; NaN\n 任何数 + NaN = NaN \nNaN == NaN =false  NaN和NaN不相等\n2. 转浮点型: parseFloat()和parseInt()用法相似,能够转换小数\n123var a = &apos;3.5aa3&apos;;parseFloat(a);=&gt; 3.5\n3. 转字符串型: toString()\n作用：强制将类型转换为字符串类型\n\n如:\n123var i =10;console.log(typeof(i.toString()));=&gt;  string\n注:\n\n数字+字符串=字符串\n\n数字+数字+字符串=(数字相加)+字符串=字符串\n\n\n如:\n12var i = 1 + 2 + 4;i=34;\n\n对象类型使用toString()\n\n12var obj = &#123; name: LinDaiDai &#125;var obj2 = obj.toString()  [object Object]\n若是想将一个引用类型的变量正在转换成字符串可以采用JSON.stringify()方法：\n12var obj = &#123; name: LinDaiDai &#125;var obj2 = JSON.stringify(obj)  &#123;name:LinDaiDai&#125;\n4. 转义字符HTML中&lt;，&gt;，&amp;等有特殊含义（&lt;，&gt;，用于链接签，&amp;用于转义），不能直接使用。这些符号是不显示在我们最终看到的网页里的，那如果我们希望在网页中显示这些符号，就该用到转义字符。\n转义字符（Escape Sequence）也称字符实体(Character Entity)。在HTML中，定义转义字符串的原因有两个：\n第一个原因是像“&lt;”和“&gt;”这类符号已经用来表示HTML标签，因此就不能直接当作文本中的符号来使用。为了在HTML文档中使用这些符号，就需要定义它的转义字符串。当解释程序遇到这类字符串时就把它解释为真实的字符。在输入转义字符串时，要严格遵守字母大小写的规则。\n第二个原因是，有些字符在ASCII字符集中没有定义，因此需要使用转义字符串来表示。\n4.1 在页面中显示空格我们先来看一段HTML代码：\n1&lt;div&gt;我中间    希望有空格&lt;div&gt;\n虽然在编程时，我们在文字中间加了很多的空格，但是打开页面发现文字还是完整的在一行上，若是想要在页面中显示空格，你可以使用&amp;nbsp;来表示一个空格：\n1&lt;div&gt;我中间&amp;nbsp;希望有空格&lt;div&gt;\n通常情况下，HTML会自动截去多余的空格。不管你加多少空格，都被看做一个空格。\n4.2 常用的字符实体\n\n\n显示\n说明\n实体名称\n实体编号\n\n\n\n\n\n半方大的空白\n&amp;ensp;\n&amp;#8194;\n\n\n\n全方大的空白\n&amp;emsp;\n&amp;#8195;\n\n\n\n不断行的空白格\n&amp;nbsp;\n&amp;#160;\n\n\n&lt;\n小于\n&amp;lt;\n&amp;#60;\n\n\n&gt;\n大于\n&amp;gt;\n&amp;#62;\n\n\n&amp;\n&amp;符号\n&amp;amp;\n&amp;#38;\n\n\n“\n双引号\n&amp;quot;\n&amp;#34;\n\n\n©\n版权\n&amp;copy;\n&amp;#169;\n\n\n®\n已注册商标\n&amp;reg;\n&amp;#174;\n\n\n?\n商标（美国）\n?\n&amp;#8482;\n\n\n×\n乘号\n&amp;times;\n&amp;#215;\n\n\n÷\n除号\n&amp;divide;\n&amp;#247;\n\n\n\n4.3 常用的转义符\n\n\n转义序列\n字符\n\n\n\n\nb\n退格\n\n\nf\n走纸换页\n\n\nn\n换行\n\n\nr\n回车\n\n\nt\n横向跳格 (Ctrl-I)\n\n\n’\n单引号\n\n\n”\n双引号\n\n\n\n反斜杠\n\n\n\n编程的时候要注意特殊字符的问题，很多运行时出现的问题都是因为特殊字符的出现而引起的。\n::: tip\n注意，由于反斜杠本身用作转义符，因此不能直接在脚本中键入一个反斜杠。如果要产生一个反斜杠，必须一起键入两个反斜杠 ()。\n:::\n5. 运算符5.1 算术运算符1. “+” 运算符:\n加号\n\n1.如果俩个都是Number类型,则按照普通的数学加法运算;\n121 + 1 2\n2.如果有一个是字符串,则按照字符串链接\n123451 + 2123 + 434\n3.如果有一个是NaN,则结果为NaN;\n12345NaN + 3NaNNumber(2.3.4) + 3NaN\n4.如果同时是infinity或者-infinity,则结果就是infintity或者-infitity;\n12345Infinity + 1Infinityinfinity + (-infinity)NaN\n5.两个数组相加，则会触发类型转换: 将值转换为原始值，转换为数字，转换为字符串。\n1234[1, 2] + [2, 1] [1, 2].toString() -&gt; 1,2 [2, 1].toString() -&gt; 2,1 1,2 + 2,1 = 1,22,1\n2. “-“ 运算符:\n减法\n\n1.数字相减\n123453 - 213 - 2 1\n3. “*” 运算符:\n乘法\n\n123453 * 262 * 24\n4. ““ 运算符:\n除法(不会取整)\n\n121033.333333333\n5. “%” 运算符:\n取余,取模\n\n12310%3 =&gt; 1 ;(符号和前面的数一致);-10%3 =&gt;-1;\n6. “++”自增运算符:\n自增\n\n123var a = 10;a++;11\n例1:\n12345var a =10;var b = a++;=&gt; a=11; b=10; a++   变量a的值11;表达式的值:永远是自增之前的值10;\n例1中 ++在后面，则先进行赋值，然后再进行自增，所以b还是为10\n例2:\n123var a =10;var b = ++a;=&gt; a=10; b=11\n例2是先进行自增，然后再进行赋值\n7. “–”自减运算符:\n自减\n\n同自增++\n5.2 赋值运算符\n赋值运算符也称复合赋值运算符\n\n如：\n1=   +=    -=   *=   =   %=\n3.比较运算符:\n== 比较俩个数是否相等\n如果比较的俩个数据的类型不同,他们都要想办法转成数字;\n如果一边是对象,一边是基本类型:\n​      1.首先调用这个对象的valueOf(),看这个方法的返回值是否是基本类型\n​          如果是基本类型,则用这个返回值和另一边相比;\n​      2.如果返回的不是基本类型,调用toString(),使用这个方法的返回字符串和另一边比较\n字符串 :  字符串里有数字的转换为数字;只要有一个非数字,就是NaN;\n对象与对象比较,**不管是==还是===,**比较的是俩个对象的地址值是否相等,\n如:var a = [];\n   var b = [];\n   alert(a==b)   =&gt;false;\nundefined=&gt;转成数字=&gt;NaN;\nnull=&gt; 转成数字 =&gt; 0;\n特殊:\n1. null虽然转成数字是0,但他和其他的任何非 null 都不相等\n 2.NaN !=NaN ;\n3.null和undefined是相等的;\n===  全等\n先看类型,如果类型不同,直接false ,\n如果类型相同,再比较内容;\n2.逻辑运算符\n! 逻辑非   true 变false   false 变true ;(结果必是布尔类型)\n&amp;&amp; 逻辑与   有一个是false ,结果就是false;\n​            短路:第一个操作数的结果是false ,所以最终结果就是false,就不会去执行之后的代码;\n例:\nvar a = 2;\nvar b = 3;\nvar c = a &gt; b &amp;&amp; a++ &gt; b++;\nconsole.log(c , a , b);\n=&gt; false     2     3 \n|| 逻辑或   有一个是true ,结果就是true ;\n​            短路:第一个操作数的结果是true,所以最终结果就是true,就不会去执行之后的代码;\n逻辑与和逻辑或的特点:\n参与运算的可以是任何的类型,结果也可以是任何类型;\n如果第一个能决定结果,则结果就是第一个数据,否则就是第二个数据;\nconsole.log(“0” || undefined );\n=&gt; “0” \nconsole.log(“0” &amp;&amp; undefined );\n=&gt; undefined ;\nconsole.log(“” &amp;&amp; undefined );\n=&gt;””\n3.三元(目)运算符:\n表达式1 ? 表达式2 : 表达式3;\n表达式1运算结果为ture或相当与true  执行表达式2;\n表达式1运算结果为false或者相当与false  执行表达式3\n4.逗号运算符:\nvar a =(1,2,3);\nalert(a);\n=&gt;3\n","tags":["前端入门","JavaScript"],"path":"2016/02/08/webNotes/primary/JavaScript/basicJS/","external_link":""},{"title":"JQuery基础","date":"2016-03-08T11:24:45.000Z","content":"第一章:JQuery简介1.简介通过$(‘#imooc’)方法会得到一个$p的jQuery对象，$p是一个类数组对象。\n这个对象里面包含了DOM对象的信息，然后封装了很多操作方法，调用自己的方法html与css，得到的效果与标准的JavaScript处理结果是一致的。\n通过标准的JavaScript操作DOM与jQuyer操作DOM的对比，我们不难发现：\n\n通过jQuery方法包装后的对象，是一个类数组对象。它与DOM对象完全不同，唯一相似的是它们都能操作DOM。\n​\n\n通过jQuery处理DOM的操作，可以让开发者更专注业务逻辑的开发，而不需要我们具体知道哪个DOM节点有那些方法，也不需要关心不同浏览器的兼容性问题，我们通过jQuery提供的API进行开发，代码也会更加精短。\n​\n\n\n普通处理，通过标准JavaScript处理：\n123var p = document.getElementById(&apos;imooc&apos;);p.innerHTML = &apos;您好！我是JS处理的p标签&apos;;p.style.color = &apos;red&apos;;\njQuery的处理：    \n12var $p = $(&apos;#imooc&apos;);$p.html(&apos;您好！我是JQuery处理的p标签&apos;).css(&apos;color&apos;,&apos;red&apos;);\n2. JQuery对象转换为DOM对象1234var $div = $(div) jQuery对象var div = $div[0] 1.转化成DOM对象var div = $div.get(0) 2.通过get()方法,转化成DOM对象div.style.color = red 操作dom对象的属性\n3.DOM对象转化成jQuery对象1234var div = document.getElementsByTagName(div); dom对象var $div = $(div); jQuery对象var $first = $div.first(); 找到第一个div元素\t$first.css(color, red); 给第一个元素设置颜色\n4.JQuery选择器之层级选择器\n第二章:常用方法1.获取元素12345$(.className)\t\t\t\t\t\t\t通过class\t匹配到的是有class名的所有标签,不管标签是否相同$(#id)\t\t\t\t\t\t\t    通过id名$(HTML标签名)\t\t\t\t\t\t 通过标签名$(HTML标签名 .className)\t\t\t 匹配class名的所有元素下的 HTML标签名的这个子元素.同$(.className).find(HTML标签名)$(document.body)\t\t\t\t\t\t获取body\n2.$(document).ready()JQery的入口\n支持多个一起执行,谁在前面谁执行,\n123456789101112131415161718 $(document).ready(function() &#123;     &#125;); 简洁写法:$(function()&#123;  &#125;)支持多个一起执行:$(function()&#123;  console.log(a);&#125;)$(function()&#123;  console.log(b);&#125;)=&gt;a=&gt;b\n3. .addClass( )\n给标签添加类名\n可以在原有的class上再添加class 不会影响原有的class\n\n.addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名\n.addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名\n\n\n1234例1: 给div 再添加类名 father&lt;div class = son&gt;&lt;div&gt;$(div).addClass(father);=&gt;\t&lt;div class = son father&gt;&lt;div&gt;\n12345678例2: 找到类名有 son 的div 给它再添加类名 father&lt;div class = son&gt;&lt;div&gt;&lt;div class = son2&gt;&lt;div&gt;$(div).addClass(function(index,className)&#123;  if(className.indexOf(son)!=-1)&#123;\t找到类名包含son的这个元素    $(this).addClass(father)\t\tthis指匹配集合中当前的这个元素  &#125;&#125;)\n12例3:\t也可以同时添加多个类名$(div).addClass(animated infinite bounce)\n4. .removeClass( )\n移除class\n\n.removeClass( className ) : 为每个匹配元素所要移除的一个或多个样式名\n.removeClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的将要移除的样式名\n\n\n1div.removeClass(&quot;father&quot;);\n5. .css( )\n获取元素的属性\n\n1234567891011121314151.传入俩个字符串参数,设置单个属性:\t$(.father).css(background-color,red);\t$(.father).css(&#123;background-color:red&#125;);2.传入一个对象,设置多个属性:\t$(.father).css(&#123;\t\t    font-size     :15px,\t\t    background-color :blue,\t\t    border        :1px solid red\t\t&#125;)3.只传入一个字符串参数,获取第一个元素的属性样式的值:\tconsole.log($(.son).css(width));\t=&gt;100px4.只传入一个数组,获取第一个元素的多个属性样式的值(返回值是一个对象):\tconsole.log($(.son).css([width,height]));\t=&gt;&#123;width: 100px, height: 100px&#125;\n\n.css( )样式属性优先级高于addClass( )\n\n12345678910111213&lt;style&gt;.son&#123;  width:100px;  height:100px;  background:red;&#125;&lt;style&gt;&lt;div&gt;&lt;div&gt;$(&apos;div&apos;).css(&apos;background&apos;,&apos;blue&apos;);$(&apos;div&apos;).addClass(&apos;son&apos;);=&gt;蓝色div\t因为css的优先级高于addCalss\n注:    \n123当一个数只被作为值（value）的时候， jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px，例如.css(&#123;width,50&#125;) 与 .css(width,50px&#125;)一样\n12background-color \t也可写成\tbackgroundColorfont-size\t\t\t也可写成\tfontSize\n123456合并设置,通过对象传设置多个样式\t\t$(.father).css(&#123;\t\t    font-size     :15px,\t\t    background-color :blue,\t\t    border        :1px solid red\t\t&#125;)\n6. .prop( )\n调整元素的属性\n\n1$(&quot;#target1&quot;).prop(&quot;disabled&quot;,&quot;true&quot;);\n7. .html( )\n添加HTML标签和文字到元素，而元素之前的内容都会被方法的内容所替换掉。\n获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法：\n\n.html() 不传入值，就是获取集合中第一个匹配元素的HTML内容\n.html( htmlString )  设置每一个匹配元素的html内容\n.html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数\n\n\n1$(&quot;#target4&quot;).html(&quot;&lt;em&gt;#target4&lt;em&gt;&quot;);\t\t\t将id为target4的标签内的内容替换为了强调体的#target4文字\n**注:.html( )内部调用的是.innerHTML属性来处理,即针对的是整个HTML的内容(不仅仅是文本内容)\n8. .remove( )\n移除HTML元素\n\n1$(&quot;#target4&quot;).remove();\t\t\t\t\t\t\t\t将id为target4的这个标签彻底移除\n9. .appendTo( )\n将元素从一个标签移到另一个标签中\n\n1$(&quot;#target2&quot;).appendTo(&quot;#right-well&quot;);\t\t\t\t将id为target2的这个元素从它原来的地方移到id为right-well的元素中\n10 .clone( )\n拷贝元素\n有参数true,若无参,只是单纯的克隆节点结构;若传参数true进去,把附带的事件和数据一并克隆了\n\n1$(&quot;#target5&quot;).clone().appendTo(&quot;#left-well&quot;);\t\t将id为target5的这个元素复制一份并添加到id为left-well的元素中\n11. .parent( )\n某个元素的父元素\n参数,可选        target.parent()    匹配target集合中的所有元素的父元素\n​                target.parent(“selected”)       匹配target集合中的所有元素的并满足selected要求的父元素\n\n1$(&quot;#target1&quot;).parent().css(&quot;background-color&quot;,&quot;red&quot;);\t\t\t\t匹配id为target1的父元素\n1$(&quot;.target1&quot;).parent(&quot;:last&quot;).css(&quot;background-color&quot;,&quot;red&quot;);\t\t匹配所有class名为target1的父级元素集合中的最后一个\n注:与其很像的 .parents( ) 方法,匹配的是所有元素的祖辈元素,查找模式从里向外,包括body html document    \n12. .children( )\njQuery是一个合集对象，所以通过children是匹配合集中每一个元素的所有第一级子元素(即仅父子关系)\n\n12例1:$(&quot;#right-well&quot;).children().css(&quot;color&quot;,&quot;orange&quot;);\t\t匹配id为right-well下的所有子元素\n12345678910111213例2:class名为father的3个div &lt;div class = father&gt;\t&lt;p&gt;p标签&lt;p&gt;&lt;div&gt;&lt;div class = father&gt;\t&lt;p&gt;p标签&lt;p&gt;&lt;div&gt;&lt;div class = father&gt;\t&lt;p&gt;p标签&lt;p&gt;\t&lt;span&gt;span标签&lt;span&gt;&lt;div&gt;$(father).children().css(color,red)\t\t\t\t所有的p标签以及span标签都会被匹配改变颜色\n\nchildren(.selected)内还可以传参\n\n123如例2中,若在最后一步的children()中加入参数$(father).children(:last).css(color,red)\t\t则只匹配到了所有集合中的最后一个元素,即只有span标签会变色\n13. :nth-child(n)\n某个元素的指定的子元素(n从1开始)\n\n1$(.target:nth-child(2)).addClass(animated bounce);\t类名为target的所有元素,他们的第二个子元素\n14. :odd\n获取元素中索引为奇数的所有元素\n索引即为下标,下标从0开始\n\n1$(&quot;.target:odd&quot;).addClass(&quot;animated shake&quot;);\n15. :even\n获取元素中索引为偶数的所有元素\n索引即为下标,下标从1开始\n\n1$(&quot;.target:even&quot;).addClass(&quot;animated shake&quot;);\n16. :first\n匹配第一个元素\n\n1$(&quot;.target:first&quot;).addClass(&quot;animated shake&quot;);\n17. :last\n匹配最后一个个元素\n\n1$(&quot;.target:last&quot;).addClass(&quot;animated shake&quot;);\n18. :not( )\n一个用来过滤的选择去,选择全部,除了( ) 里的元素\n\n1$(&quot;.target:not(:fitst)&quot;).addClass(&quot;animated shake&quot;);\t\t选择所有有target类名的元素除了第一个\n19. :eq( )\n语法: :eq( index )         选择索引值为index 的元素,index 从0开始\n\n1$(&quot;.target:eq(2)&quot;).addClass(&quot;animated shake&quot;);\t\t\t\t类名为target的元素中的索引值为2的元素\n20. :gt( )\n语法: :gt( index )         选择索引值大于index 的所有元素\n\n1$(&quot;.target:gt(2)&quot;).addClass(&quot;animated shake&quot;);\n21. :lt( )\n语法: :lt( index )         选择索引值小于index 的所有元素\n\n1$(&quot;.target:lt(2)&quot;).addClass(&quot;animated shake&quot;);\n22. :header\n选择所有标题元素, 如h1  h2  h3 等\n\n1$(&quot;:header&quot;).css(&quot;color&quot;,&quot;red&quot;);\n23. :lang( )\n语法: :lang(language)        选择指定语言的所有元素\n\n123456789&lt;div id=&quot;n1&quot; lang=&quot;en&quot;&gt;China(英语)&lt;div&gt;&lt;div id=&quot;n2&quot; lang=&quot;EN-US&quot;&gt;China(美式英语)&lt;div&gt;&lt;div id=&quot;n3&quot; lang=&quot;zh-cn&quot;&gt;中国(大陆中文)&lt;div&gt;&lt;div id=&quot;n4&quot; lang=&quot;zh-tw&quot;&gt;中國(台湾中文)&lt;div&gt;&lt;div id=&quot;n5&quot; lang=&quot;fr&quot;&gt;Chine(法语)&lt;div&gt;&lt;div id=&quot;n6&quot; lang=&quot;ru&quot;&gt;Китай(俄语)&lt;div&gt; 选择了id分别为n3、n4的两个元素$(&quot;:lang(zh)&quot;);\n24. :root\n选择这个文档的根元素\n\n25. :animated\n选择所有在执行动画效果的元素\n\n1$(&quot;:animated&quot;);\n26. :contains( )\n选择所有包含指定文本的元素\n\n1$(&quot;.div:contains(&apos;我是div&apos;)&quot;).css(&quot;color&quot;, &quot;#CD00CD&quot;);\t\t选择类名为div的所有包含文本内容为&quot;我是div&quot;的元素\n27. :has( )\n选择元素中至少包含指定选择器的元素\n\n1$(&quot;.div:has(span)&quot;)\t\t\t\t\t\t\t\t\t\t\t选择类名为div的所有包含span标签的元素\n28. :parent\n选择所有含有子元素或文本的元素\n\n1$(&quot;a:parent&quot;)\t\t\t\t\t\t\t\t\t\t\t选择所有内容不为空的a标签\n29. :empty\n选择所有没有子元素或文本的元素(与:parent相反);\n\n1$(&quot;a:empty&quot;)\t\t\t\t\t\t\t\t\t\t\t选择所有内容为空的a标签\n30. :visible选择所有显示的元素\n1$(&quot;:visible&quot;)\n31. :hidden\n选择所有隐藏的元素\n\n1:hidden选择器，不仅仅包含样式是display=&quot;none&quot;的元素，还包括隐藏表单、visibility等等\n我们有几种方式可以隐藏一个元素：\n\nCSS display的值是none。\ntype=”hidden”的表单元素。\n宽度和高度都显式设置为0。\n一个祖先元素是隐藏的，该元素是不会在页面上显示\nCSS visibility的值是hidden\nCSS opacity的指是0\n\n123如果元素中占据文档中一定的空间,元素被认为是可见的。可见元素的宽度或高度，是大于零。元素的visibility: hidden 或 opacity: 0被认为是不可见的，因为他们仍然占用空间布局。\n32. this12this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。\n12345$(&apos;p&apos;).click(function()&#123;    把p元素转化成jQuery的对象    var $this= $(this)     $this.css(&apos;color&apos;,&apos;red&apos;)&#125;)\n33. val( ).val()方法只针对表单元素\n\n.val()无参数，获取匹配的元素集合中第一个元素的当前值\n\n.val( value )，设置匹配的元素集合中每个元素的值\n\n.val( function ) ，一个用来返回设置值的函数\n注:\n\n通过.val()处理select元素， 当没有选择项被选中，它返回null\n\n.val()方法多用来设置表单的字段的值\n\n如果select元素有multiple（多选）属性，并且至少一个选择项被选中， .val()方法返回一个数组，这个数组包含每个选中选择项的值\n例1:对于无selected的下拉框,输出第一个\n123456&lt;select id=single&gt;      &lt;option&gt;你好&lt;option&gt;    &lt;option&gt;王先生&lt;option&gt;&lt;select&gt;\t\tconsole.log($(#single).val())\t\t获取匹配的元素的集合中的第一个元素的当前值=&gt;你好\n例2:对于多个selected,输出选择了的内容\n1234567&lt;select id=multiple multiple=multiple&gt;        &lt;option selected=selected&gt;王先生c&lt;option&gt;        &lt;option&gt;你好&lt;option&gt;        &lt;option selected=selected&gt;帅&lt;option&gt;&lt;select&gt;  \t\tconsole.log($(#multiple).val())\t\t=&gt;\t        王先生,帅\n\n\n例3:用val( )修改文本内容\n123&lt;input type = text value = 我是为被修改的input&gt;&lt;script&gt;\t$(input[type=text]).val(我是修改了的input);\t\t选择一个表单,修改value的值\n\n\n34. toggleClass( )\ntoggleClass方法用于addClass( )和removeClass( )直接的切换\n通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass\n\n1234$(&quot;button&quot;).click(function()&#123;    $(&quot;p&quot;).toggleClass(&quot;main&quot;);  &#125;);  第一次点击按钮,给P标签添加class  再次点击移除class\n35. hasClass( )判断匹配的元素是否有指定的className\n12345&lt;div class = first&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;console.log($(div:first).hasClass(first));\t判断第一个div元素是否有first类名=&gt;true\n36. offset( )获取这个元素在当前文档的相对偏移。其中返回的对象包含两个属性，left和top。(这个值类似pageX和pageY)\n第三章:属性筛选选择器\n在这么多属性选择器中[attr=”value”]和[attr*=”value”]是最实用的\n12345[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件\n例:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455查找所有div中，属性name=p1的div元素         $(div[name=p1]).css(border, 3px groove red);                   &lt;div class=div testattr=true name=p1&gt;            &lt;a&gt;[att=val]&lt;a&gt;        &lt;div&gt;         查找所有div中，有p2属性的div元素        $(div[p2]).css(border, 3px groove blue);                 &lt;div class=div testattr=true p2&gt;            &lt;a&gt;[att]&lt;a&gt;        &lt;div&gt;        查找所有div中，有属性name中的值只包含一个连字符“-”的div元素        $(div[name|=-]).css(border, 3px groove #00FF00);                   &lt;div class=div testattr=true name=-&gt;            &lt;a&gt;[att|=val]&lt;a&gt;        &lt;div&gt;         查找所有div中，有属性name中的值包含一个连字符“空”和“a”的div元素        $(div[name~=a]).css(border, 3px groove #668B8B);                 &lt;div class=div testattr=true name=a b&gt;            &lt;a&gt;[att~=val]&lt;a&gt;        &lt;div&gt;         查找所有div中，属性name的值是用imooc开头的         $(div[name^=imooc]).css(border, 3px groove red);                   &lt;div class=div testattr=true  name=imooc-aaorn&gt;            &lt;a&gt;[att^=val]&lt;a&gt;        &lt;div&gt;          查找所有div中，属性name的值是用imooc结尾的         $(div[name$=immoc]).css(border, 3px groove blue);                   &lt;div class=div testattr=true  name=aaorn-imooc&gt;            &lt;a&gt;[att$=val]&lt;a&gt;        &lt;div&gt;          查找所有div中，有属性name中的值包含一个test字符串的div元素        $(div[name*=test]).css(border, 3px groove #00FF00);                 &lt;div class=div testattr=true  name=attr-test-selector&gt;            &lt;a&gt;[att*=val]&lt;a&gt;        &lt;div&gt;         查找所有div中，有属性testattr中的值没有包含true的div        $(div[testattr!=true]).css(border, 3px groove #668B8B);                 &lt;div class=div name=a b&gt;            &lt;a&gt;[att!=val]&lt;a&gt;        &lt;div&gt;\n第四章:子元素筛选选择器1. :first-child\n选择所有父级元素下的第一个子元素\n\n12$(&apos;.target:first-child&apos;)\t\t\t\t选择所有类名为target的元素  它们的第一个子元素$(&apos;.target a:first-child&apos;)\t\t\t\t选择所有类名为target的元素下的第一个a标签元素\n:first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1)\n2. :last-child\n选择所有父级元素下的最后一个子元素\n\n1$(&apos;.target:last-child&apos;)\t\t\t\t选择所有类名为target的元素  它们的最后一个子元素\n3. :only-child\n如果某个元素是其父级元素下的唯一子元素,它就会被选中\n\n4. :nth-child(n)\n某个元素的指定的子元素(n从1开始)        从前往后计算\n\n1$(&quot;.target:nth-child(2)&quot;).addClass(&quot;animated bounce&quot;);\t选择类名为target的所有元素,他们的第二个子元素\n5. :nth-last-child(n)\n某个元素的指定的子元素(n从1开始)           从后往前计算\n\n第五章:表单元素选择器1.常用表单元素选择器\n​    注:除了input 选择器,每个表单选择器都对应一个input的type值    \n​    如: \n1$(&quot;:password&quot;)\t\t还可以表示为\t\t$(&quot;[type=password]&quot;)\n2.表单对象属性筛选1. :enabled\n选取可用的表单元素\n\n12查找所有input所有可用的（未被禁用的元素）input元素。        $(&apos;input:enabled&apos;).css(&quot;border&quot;, &quot;2px groove red&quot;);\n2. :disabled\n选取不可以的表单元素\n\n12查找所有input所有不可用的（被禁用的元素）input元素。        $(&apos;input:disabled&apos;).css(&quot;border&quot;, &quot;2px groove blue&quot;);\n3. :checked\n选取被选中的元素\n\n查找所有input所有勾选的元素(单选框,复选框)\n 移除input的checked属性\n$(&apos;input:checked&apos;).removeAttr(&apos;checked&apos;)\n注:    在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素\n4. :selected\n选取被选中的元素\n\n123查找所有option元素中,有selected属性被选中的选项         移除option的selected属性        $(&apos;input:selected&apos;).removeAttr(&apos;selected&apos;)\n注:    \n\n选择器适用于复选框和单选框，对于下拉框元素, 使用 :selected 选择器\n\n第六章: 获取设置元素属性1. .attr( )\nattr(传入属性名)：获取属性的值\nattr(属性名, 属性值)：设置属性的值\nattr(属性名,函数值)：设置属性的函数值\nattr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … }\n\n123456789&lt;a href = &quot;www.baidu.com&quot;&gt;百度一下&lt;a&gt;1.获取属性值console.log($(&apos;a&apos;).attr(&apos;href&apos;));=&gt;&quot;www.baidu.com&quot;2.设置属性的值$(&apos;a&apos;).attr(&#123;&apos;href&apos;:&apos;www.goole.com&apos;,&apos;class&apos;:&apos;A&apos;,&apos;innerHTML&apos;:&apos;谷歌一下&apos;&#125;)=&gt;&lt;a href = &apos;www.goole.com&apos; class=&apos;A&apos;&gt;\n2. .removeAttr( )\n.removeAttr( 属性名)    为匹配到的元素集合中的每一个元素都移除一个属性\n\n3. .attr()和prop()的区别dom中有个概念的区分：Attribute和Property翻译出来都是“属性”，《js高级程序设计》书中翻译为“特性”和“属性”。简单理解，Attribute就是dom节点自带的属性.\n如:\nhtml中常用的id  class title align 等用attr();\n1&lt;div id=target title=王先生&gt;&lt;div&gt;\n而Property是这个DOM元素作为对象，其附加的内容，例如,tagName, nodeName, nodeType,, defaultChecked, 和 defaultSelected 使用.prop()方法进行取值或赋值等\n4. .html( ) 和 .text( ) .val( )的区别.text( )\n得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法：\n\n.text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代\n\n.text( textString ) 用于设置匹配元素内容的文本\n\n.text( function(index, text) ) 用来返回设置文本内容的一个函数\n注:返回的是一个字符串,包含所有匹配到的元素的文本集合.    \n​\n​\n.html与.text的异同:\n\n\n\n.html与.text的方法操作是一样，只是在具体针对处理对象不同\n.html处理的是元素内容，.text处理的是文本内容\n.html只能使用在HTML文档中，.text 在XML 和 HTML 文档中都能使用\n如果处理的对象只有一个子文本节点，那么html处理的结果与text是一样的\n火狐不支持innerText属性，用了类似的textContent属性，.text()方法综合了2个属性的支持，所以可以兼容所有浏览器\n\n\n\n\n方法名\n读取的内容\n作用元素\n使用在多个元素上时\n能否使用回调函数\n\n\n\n\n.html()\n元素的html内容(包含html标签)\n除了表单元素\n只读取第一个元素\n是\n\n\n.text()\n元素的的纯文本内容\n除了表单元素\n读取所有选中元素的文本内容\n是\n\n\n.val()\n表单的value值\n表单元素\n第一个表单元素的value值\n是\n\n\n\n\n\n\n\n\n\n\n","tags":["前端进阶","JQuery"],"path":"2016/03/08/webNotes/primary/JQuery/basisJQuery/","external_link":""},{"title":"vue基础","date":"2017-03-08T11:24:45.000Z","content":"第一章: 安装vue如果没有装cnpm可以全局安装1npm install cnpm -g\n命令行工具(CLI)\n\n全局安装 vue-cli\n1npm install  vue-cli -g\n\n需要创建一个基于 webpack 模板的新项目\n1vue init webpack my-project\t1 vue指令, 2 初始化 3 webpack 4 项目名\n\n安装依赖，走你\n123cd my-project\t进入到当前目录下npm install\t安装依赖npm run dev\t运行项目\n\n\n第一步:1npm install  vue-cli -g\n\n第二步:\n1vue init webpack my-project\n\nwebpack是vue-cli的webpack模板\nmy-project是项目名称\n\n\n可以看到文件夹中多了一个my-project文件夹\n\n目录文件介绍:    \n\nbuild和config是webpack的配置文件\n\nnode_modules中存放的是npm install安装的文件依赖代码库\n\nsrc文件是存放的是项目源码\n\nstatic存放的是第三方的静态资源，里面只有.gitkeep这个文件的意思是当这个目录为空也是可以提交git代码仓库里，如果没有这个文件git会忽略这个目录\n\n.babelrc这个文件是babel的一些配置,主要就是用于将es6的代码转成es5的,详细介绍：babel\n\n.editorconfig是编辑器的一些配置\n\n.gitignore用于向git声明需要忽略提交的文件\n\n.postcssrc.js这个文件是postCSS的配置文件，postCSS是一款通过JS插件来转换CSS的工具，这些插件能帮你校验你的CSS代码、转换未来的CSS语法、支持变量和混写、以及内联图片等等，其中自动前缀插件是PostCSS最受欢迎预处理器之一。默认就配置使用了autoprefixer也就是自动前缀的这个插件\n\nindex.html就是入口的html文件，在编译打包过程中会将资源文件插入到这个html文件中\n\n1package.json\n项目的配置文件，这个文件中是我们在初始化vue-clic的时候填入的信息：\n\n最重要的就是里面的scripts属性，表示的是我们可以执行的一些命令,比如npm run dev就是执行的node builddev-server.js这个命令，然后npm run build就是执行的node buildbuild.js也就是打包的操作，我们也自己在scripts中去配置一些脚本\ndependencies里面放的项目生产环境的一些依赖，然后在安装一些模块的时候可以通过--save保存到这个属性下，比如要使用vue-router就可以使用npm install vue-router --save\ndevDependencies里面放的编译过程中的一些依赖，在最后打包的时候不存在\n\n\nREADME.md就是项目的描述文件\n\n\n第三步:\n​安装依赖123$ cd my-project\t\t跳到当前的项目文件夹$ npm install\t\t\t安装依赖$ npm run dev\t\t运行项目\n第二章: vue的基本语法2.1 引用vue1.在页面中引入vue.js远程文件或者本地文件\n1&lt;script src=&quot;https:unpkg.comvuedistvue.js&quot;&gt;&lt;script&gt;\n2.本地引入vue.js\n1&lt;script type=&quot;textjavascript&quot; src=&quot;jsvue.js&quot;&gt;&lt;script&gt;\n2.2 数据绑定\nvue允许采用简洁的模板语法来声明式的将数据渲染进 DOM\n\n最简单的小例子\n例1:\n12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;test1&lt;title&gt;    &lt;script src=jsvue.min.js&gt;&lt;script&gt;&lt;head&gt;&lt;body&gt;&lt;div id=app&gt;    &#123;&#123;message&#125;&#125;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:#app,        data:&#123;            message:First Vue        &#125;    &#125;)&lt;script&gt;&lt;body&gt;&lt;html&gt;\nnew 一个vue对象的时候,你可以设置它的属性,其中最重要的包括三个,分别是data, methods, watch\ndata代表vue对象的数据,methods代表vue的方法,watch设置了对象监听的方法\nvue对象里的设置通过html指令进行关联\n重要的指令包括:\n\nv-text    渲染数据      (ng-bind)\nv-if        控制显示\nv-on          绑定事件\nv-for         循环渲染 等\n\n12345678910111213141516new Vue(&#123;  data:&#123;    a:1,    b:[]  &#125;  methods:&#123;    doSomething:function()&#123;      console.log(&apos;a&apos;)    &#125;  &#125;  watch:&#123;\t\t\t\t\t\t    &apos;a&apos;:function(val, oldVal) &#123;      console.log(val, oldVal)    &#125;  &#125;&#125;)\n2.3 常用指令1. v-text预期：string\n更新元素的 textContent。如果要更新部分的 textContent ，需要使用  插值。\n不能解析HTML标签    \n12345678910111213&lt;div id=&quot;app&quot; v-text=&quot;message&quot;&gt;&lt;div&gt;&lt;--等价于--&gt;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;First Vue&quot;,        &#125;,    &#125;)&lt;script&gt;  =&gt;\tFirst Vue\n2. v-html\n预期：string\n\n详细：\n更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。\n就是能够解析HTML标签    \n\n\n1234567891011121314&lt;div id=&quot;app&quot; v-html=&quot;html&quot;&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;First Vue&quot;,            html:&apos;&lt;span&gt;我是span标签&lt;span&gt;&apos;        &#125;,    &#125;)&lt;script&gt;    =&gt;\t我是span标签\n3. 条件渲染1. v-if\n在上面的例子中,我们是利用v-show=&#39;isShow&#39;来实现元素隐藏显示\n\n\n在 Vue.js ,我们使用 v-if 指令实现同样的功能\n\n1.直接使用v-if\n12345678910111213&lt;body&gt;&lt;div  id=&quot;app&quot;&gt;    &lt;div  v-if=&quot;ok&quot;&gt;yes&lt;div&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            ok:true        &#125;,    &#125;)&lt;script&gt;&lt;body&gt;\n2.也可以用 v-else 添加一个 “else” 块:\n1234&lt;div  id=&quot;app&quot;&gt;    &lt;div  v-if=&quot;ok&quot;&gt;yes&lt;div&gt;    &lt;div  v-else&gt;no&lt;div&gt;&lt;div&gt;\n注:v-else 元素必须紧跟在 v-if 或者 v-else-if 元素的后面——否则它将不会被识别\n3.在&lt;template&gt;&lt;template&gt;中配合v-if    条件渲染一整组\n123456789101112131415161718&lt;div  id=app&gt;    &lt;template v-if=ok&gt;\t\t显示        &lt;h1 v-else&gt;Title&lt;h1&gt;\t隐藏        &lt;p v-else&gt;Paragraph 1&lt;p&gt;\t隐藏        &lt;p&gt;Paragraph 2&lt;p&gt;\t\t\t显示    &lt;template&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:#app,        data:&#123;            ok:true        &#125;,    &#125;)&lt;script&gt;=&gt;\t页面只显示\t\tParagraph\n4.配合v-else-if使用\n充当”if”的一个”else-if块”\n可以链式的多次使用\n2. v-show\n根据表达式之真假值，切换元素的 display CSS 属性。\n当条件变化时该指令触发过渡效果。\n\n\n当和 v-if 一起使用时，v-show 的优先级比 v-if 更高。\n\n123456789101112131415&lt;body&gt;&lt;div id=&quot;app&quot; v-text=&quot;message&quot; v-show=&quot;isShow&quot;&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;First Vue&quot;,            isShow:false        &#125;,    &#125;)&lt;script&gt;&lt;body&gt;=&gt;改变isShow的值控制div的隐藏\n4. v-for预期：Array | Object | number | string\n用法和ng-repeat一样    \n\n遍历数组:\n\n1234567891011121314151617181920&lt;body&gt;&lt;div  id=&quot;app&quot;&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(item, index) in arr&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;li&gt;    &lt;ul&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            arr:[                &#123;name:&apos;买牙膏&apos;, down:false&#125;,                &#123;name:&apos;打台球&apos;, down:false&#125;,                &#123;name:&apos;听歌&apos;,  down:false&#125;,                &#123;name:&apos;游戏&apos;,  down:false&#125;            ]        &#125;,    &#125;)&lt;script&gt;&lt;body&gt;\n\n遍历对象\n\n1234567891011121314151617&lt;div  id=app&gt;    &lt;ul&gt;        &lt;li v-for=(val, key) in obj&gt;&#123;&#123;key&#125;&#125;:&#123;&#123;val&#125;&#125;:&#123;&#123;index&#125;&#125;&lt;li&gt;    &lt;ul&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:#app,        data:&#123;            obj: &#123;name:王先生, age:21, sex:男&#125;,        &#125;,    &#125;)&lt;script&gt;=&gt;\tname:王先生 :0\tage:21 :1\tsex:男 :2\n\n遍历数字\n\n123&lt;div&gt;  &lt;span v-for=n in 10&gt;&#123;&#123; n &#125;&#125; &lt;span&gt;&lt;div&gt;\n结果:\n11 2 3 4 5 6 7 8 9 10\n\nv-for 和 v-if\n\n当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：\n123&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;  &#123;&#123; todo &#125;&#125;&lt;li&gt;\n上面的代码只传递了未 complete 的 todos。\n而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 [`)上。如：\n123456&lt;ul v-if=&quot;todos.length&quot;&gt;\t只有当数组todos的长度大于0时才会执行循环  &lt;li v-for=&quot;todo in todos&quot;&gt;    &#123;&#123; todo &#125;&#125;  &lt;li&gt;&lt;ul&gt;&lt;p v-else&gt;No todos left!&lt;p&gt;\n\n组件中的v-for\n\n在组件中使用v-for,任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 props ：\n123456&lt;my-component  v-for=(item, index) in items  v-bind:item=item  v-bind:index=index  v-bind:key=item.id&gt;&lt;my-component&gt;\n不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。\n具体看第三章组件中的Prop.\n5. v-on\n缩写：@\n预期：Function | Inline Statement | Object\n参数：event\n\n语法:\n\n1.方法处理器        v-on:event=&quot;functionName&quot;\n\n例1:\n12345678910111213141516&lt;div  id=app&gt;    &lt;button v-on:click=doThis&gt;点击&lt;button&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:#app,        data:&#123;            obj: &#123;name:王先生, age:21, sex:男&#125;,        &#125;,        methods:&#123;            doThis() &#123;                alert(点击了我)            &#125;        &#125;    &#125;)&lt;script&gt;\n\n2.对象语法    v-on=&quot;{ event1: functionName1, event2:functionName2 }&quot;    \n\n例1也可以这样写:\n1&lt;button v-on=&#123;click: doThis&#125;&gt;点击&lt;button&gt;\n3.缩写语法    @event =&quot;functionName&quot;        \n1&lt;button @click=doThis&gt;点击&lt;button&gt;\n修饰符\n\nvue中对事件也有一些修饰符,这些修饰符能帮我们省去很多事\n\n\n.stop - 调用 event.stopPropagation()。\n.prevent - 调用 event.preventDefault()。\n.capture - 添加事件侦听器时使用 capture 模式。\n.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。\n.native - 监听组件根元素的原生事件。\n.once - 只触发一次回调。\n.left - (2.2.0) 只当点击鼠标左键时触发。\n.right - (2.2.0) 只当点击鼠标右键时触发。\n.middle - (2.2.0) 只当点击鼠标中键时触发。\n.passive - (2.3.0) 以 { passive: true } 模式添加侦听器\n\n用法:\n如:\n1234567891011121314&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=doThis&gt;&lt;button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=doThis&gt;&lt;button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;form&gt;&lt;!--  串联修饰符 --&gt;&lt;button @click.stop.prevent=doThis&gt;&lt;button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=onEnter&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=onEnter&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once=doThis&gt;&lt;button&gt;\n6. v-bind\n缩写：:\n预期：any (with argument) | Object (without argument)\n参数：数组(attr) Or 组件(Prop) 都是可选的(optional)\n修饰符：\n.prop - 被用于绑定 DOM 属性 (property).\n.camel将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)\n.sync 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。\n\n\n用法\n\n动态地绑定一个或多个特性，或一个组件 prop 到表达式。\n1.绑定属性例1:\n123456789101112131415&lt;body&gt;&lt;div  id=app&gt;    &lt;img v-bind:src=imgSrc alt=&gt;    &lt;--   也可以简写为   --&gt;    &lt;img :src=imgSrc alt=&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:#app,        data:&#123;            imgSrc:imgimg1.jpg        &#125;,    &#125;)&lt;script&gt;&lt;body&gt;\n2.绑定class\nv-bind:class=””\n:class=””\n参数可以是一个判断语句,也可以直接传变量\n\n用法和ng-class一样\n1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;test1&lt;title&gt;    &lt;script src=jsvue.min.js&gt;&lt;script&gt;    &lt;style&gt;        #app&#123;            width: 500px;            height: 500px;            background: red;        &#125;        #app div&#123;            width: 200px;            height: 200px;        &#125;        .isRed&#123;            background: red;        &#125;        .isBlue&#123;            background: blue;        &#125;    &lt;style&gt;&lt;head&gt;&lt;body&gt;&lt;div  id=app&gt;   &lt;div :class=&#123;true: isRed, false: isBlue&#125;[isClass]&gt;&lt;div&gt;&lt;div&gt;&lt;script&gt;    new Vue(&#123;        el:#app,        data:&#123;            isClass: false        &#125;,    &#125;)&lt;script&gt;&lt;body&gt;&lt;html&gt;\n3. 绑定style\nv-bind:style\n:style\n\n12345&lt;div :style=&quot;&#123;background: &apos;blue&apos;, fontSize: 14 + &apos;px&apos; &#125;&quot;&gt;&lt;div&gt;&lt;div :style=&quot;styleObject&quot;&gt;&lt;div&gt;styleObject:[&#123;background: &apos;blue&apos;&#125;,&#123;fontSize: 14 + &apos;px&apos;&#125;],styleObject:&#123;background: &apos;blue&apos;, fontSize: 14 + &apos;px&apos;&#125;\nps:当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀.\n若要改变背景图片\n123&lt;div :style=&quot;styleObject&quot;&gt;&lt;div&gt;styleObject: &#123;backgroundImage:&apos;url(&apos;+require(&apos;.imagesimg1.png&apos;)+&apos;)&apos;&#125;\n4. 案例tab切换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;Document&lt;title&gt;    &lt;script type=textjavascript src=jsvue.js&gt;&lt;script&gt;    &lt;style type=textcss&gt;    #app button.active&#123;        background-color: yellow;    &#125;    #app div&#123;        width: 200px;        height: 200px;        background-color: #ccc;        display: none;    &#125;    #app div.active&#123;        display: block;    &#125;    &lt;style&gt;&lt;head&gt;&lt;body&gt;    &lt;div id=app&gt;        &lt;button v-for=(item,index) in tabs :class=&#123;active:activeIndex==index&#125; @click=changeIndex(index)&gt;        &lt;button&gt;        &lt;div v-for=(item,index) in tabs :class=&#123;active:activeIndex==index&#125;&gt;        &lt;div&gt;    &lt;div&gt;&lt;body&gt;&lt;script type=textjavascript&gt;     父组件    var vm = new Vue(&#123;        el:#app,        data:&#123;            tabs: [                &#123;btn:按钮1, content: 买菜, id:1&#125;,                &#123;btn:按钮2, content: 学习ng,id:2&#125;,                &#123;btn:按钮3, content: 打游戏,id:3&#125;            ],            activeIndex: 0        &#125;,        methods: &#123;            changeIndex:function (index)&#123;                this.activeIndex = index            &#125;        &#125;    &#125;)&lt;script&gt;&lt;html&gt;\n5. 案例留言板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;Document&lt;title&gt;    &lt;script type=textjavascript src=jsvue.min.js&gt;&lt;script&gt;    &lt;style type=textcss&gt;    *&#123;        list-style: none    &#125;    #app button.active&#123;        background-color: yellow;    &#125;    #app div&#123;        width: 200px;        height: 200px;        background-color: #ccc;        display: none;    &#125;    #app div.active&#123;        display: block;    &#125;    &lt;style&gt;&lt;head&gt;&lt;body&gt;    &lt;div id=app&gt;        姓名： &lt;input type=text v-model=name&gt;&lt;br&gt;        内容： &lt;textarea v-model=content&gt;&lt;textarea&gt;&lt;br&gt;        &lt;button @click=add()&gt;提交&lt;button&gt;&lt;br&gt;        &lt;h1&gt;显示留言&lt;h1&gt;        &lt;ul&gt;            &lt;li v-for=(item,index) in arr&gt;                &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;span&gt;                &lt;p&gt;&#123;&#123;item.content&#125;&#125;&lt;a href=### @click=del(index)&gt;删除&lt;a&gt;&lt;p&gt;            &lt;li&gt;        &lt;ul&gt;    &lt;div&gt;&lt;body&gt;&lt;script type=textjavascript&gt;     父组件    var vm = new Vue(&#123;        el:#app,        data:&#123;            name:,            content:,            arr: []        &#125;,        methods: &#123;            add() &#123;                let msg = &#123;                    name: this.name,                    content: this.content                &#125;                this.arr.push(msg)                this.name =                 this.content =             &#125;,            del(index) &#123;                this.arr.splice(index, 1)            &#125;        &#125;,    &#125;)&lt;script&gt;&lt;html&gt;\n7. v-model\n你可以用 v-model 指令在表单控件元素上创建双向数据绑定。类似于ng-model\n随表单控件类型不同而不同\n\n使用对象:    \n\n&lt;input&gt;\n\n&lt;select&gt;\n\n&lt;textarea&gt;\n\ncomponents\n​\n修饰符:    \n\n\n\n.lazy - 取代 input 监听 change 事件\n.number - 输入字符串转为数字\n.trim - 输入首尾空格过滤\n\n#####1.文本或多行文本\n12345&lt;input v-model=message placeholder=edit me&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;p&gt;&lt;textarea v-model=message placeholder=add multiple lines&gt;&lt;textarea&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;p&gt;\n注:在文本区域插值 (&lt;textarea&gt;&lt;textarea&gt;) 并不会生效，应用 v-model 来代替\n2.复选框checkox\nfor绑定的是input中的id值\n\n12&lt;input type=checkbox id=checkbox v-model=checked&gt;&lt;label for=checkbox&gt;&#123;&#123; checked &#125;&#125;&lt;label&gt;\n\n多个复选框绑定到同一个数组,    \n复选框内允许选择多项,所以被勾选中的复选框的value都会被传入数组中,并显示出来\n\n12345678910&lt;div  id=app&gt;    &lt;input type=checkbox id=Jack value=Jack v-model=checkedNames&gt;    &lt;label for=Jack&gt;Jack&lt;label&gt;    &lt;input type=checkbox id=John value=John v-model=checkedNames&gt;    &lt;label for=John&gt;John&lt;label&gt;    &lt;input type=checkbox id=Eile value=Eile v-model=checkedNames&gt;    &lt;label for=Eile&gt;Eile&lt;label&gt;    &lt;br&gt;    &lt;span&gt;checkedNames:&#123;&#123;checkedNames&#125;&#125;&lt;span&gt;&lt;div&gt;\n123456new Vue(&#123;  el: #app,  data: &#123;    checkedNames: []  &#125;&#125;)\n3. 单选框radio\n同一块的单选框只允许有一个值\n在span标签中只能显示一个value值,一个单选框被勾中后,另一个就会被取消\n\n123456789&lt;div id=example-4&gt;  &lt;input type=radio id=one value=One v-model=picked&gt;  &lt;label for=one&gt;One&lt;label&gt;  &lt;br&gt;  &lt;input type=radio id=two value=Two v-model=picked&gt;  &lt;label for=two&gt;Two&lt;label&gt;  &lt;br&gt;  &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;span&gt;&lt;div&gt;\n123456new Vue(&#123;  el: #example-4,  data: &#123;    picked: \t\t就算picked是一个数组,也只能显示一个  &#125;&#125;)\n4.选择列表select注:\n12若&lt;option&gt;&lt;option&gt;中有value,则selected的值就是value,若没有value值,则是标签里的值但记住value要用v-bind:value=\n1.单选列表\n\n单选列表中选择哪一项,span中就显示哪一项的内容,不需要value值\n\n123456789&lt;div id=example-5&gt;  &lt;select v-model=selected&gt;    &lt;option disabled value=&gt;请选择&lt;option&gt;\t\t第一个选项为不能选取,为防止IOS引发change事件    &lt;option&gt;A&lt;option&gt;    &lt;option&gt;B&lt;option&gt;    &lt;option&gt;C&lt;option&gt;  &lt;select&gt;  &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;span&gt;&lt;div&gt;\n123456new Vue(&#123;  el: ...,  data: &#123;    selected:   &#125;&#125;)\n2.多选列表\n\n在select中加入multiple属性就可以使select变为多选\n多选列表,按住Ctrl键点击选项,可以选择多项\n\n123456789&lt;div id=example-6&gt;  &lt;select v-model=selected multiple style=width: 50px;&gt;    &lt;option&gt;A&lt;option&gt;    &lt;option&gt;B&lt;option&gt;    &lt;option&gt;C&lt;option&gt;  &lt;select&gt;  &lt;br&gt;  &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;span&gt;&lt;div&gt;\n123456new Vue(&#123;  el: &apos;#example-6&apos;,  data: &#123;    selected: []\t\t数组  &#125;&#125;)\n3.动态选项\n用 v-for 渲染:\n123456&lt;select v-model=selected&gt;  &lt;option v-for=option in options v-bind:value=option.value&gt;\t    &#123;&#123; option.text &#125;&#125;  &lt;option&gt;&lt;select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;span&gt;\n1234567891011new Vue(&#123;  el: ...,  data: &#123;    selected: A,    options: [      &#123; text: One, value: A &#125;,      &#123; text: Two, value: B &#125;,      &#123; text: Three, value: C &#125;    ]  &#125;&#125;)\n效果图:\n\n8. v-pre\n不需要表达式\n\n用法：\n跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。\n\n示例：\n1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;span&gt;\n\n\n9. v-cloak\n不需要表达式\n\n用法：\n这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\n\n123[v-cloak] &#123;  display: none;&#125;\n123&lt;div v-cloak&gt;  &#123;&#123; message &#125;&#125;&lt;div&gt;\n不会显示，直到编译结束。\n10. v-once\n不需要表达式\n\n详细：\n只渲染元素和组件一次。随后的重新渲染，元素组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n\n例1:\np标签内的内容为&#39;我是第一次的数据&#39;,虽然input绑定了&#39;msg&#39;数据,但只要添加了v-once无论&#39;msg&#39;数据怎样改变,p标签内的内容都不变    \n1234567891011121314&lt;div id=app&gt;    &lt;input type=text v-model=msg&gt;    &lt;p v-once&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt;&lt;div&gt;&lt;script&gt;    new Vue(        &#123;            el: #app,            data: &#123;                msg: 我是第一次的数据            &#125;,        &#125;    )&lt;script&gt;\n12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt;  &lt;h1&gt;comment&lt;h1&gt;  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt;&lt;div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment=msg&gt;&lt;my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt;  &lt;li v-for=i in list v-once&gt;&#123;&#123;i&#125;&#125;&lt;li&gt;&lt;ul&gt;","tags":["vue","前端入门"],"path":"2017/03/08/webNotes/primary/Vue/basicVue/","external_link":""},{"title":"canvas简单动画--躁动的小球","date":"2017-09-21T00:53:00.000Z","content":"前言我们都知道canvas实际就是一个H5新增的标签,它呢,可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。制作动画的原理实际上也非常简单:利用定时执行一定语句的方法来重复执行绘图功能,常用的方法有:1. setInterval()2. setTimeout()3. requestAnimationFrame()\n一个简单的demo在讲解躁动的小球之前呢,我们先来看一个简单的动画:\n让一个方块以匀速向右移动1234567891011121314151617181920212223242526272829&lt;canvas id=canvas width=400 height=400 style=border: 1px solid #000&gt;您的浏览器不支持&lt;canvas&gt;&lt;script&gt;        获取canvas        let canvas = document.querySelector(#canvas)        获取2d的上下文对象        let cxt = canvas.getContext(2d)        创建一个方块对象        let rect = &#123;            w:50,   宽            h:50,   高            x:20,   x轴方向的位移            y:0,    y方向的位移            color:red,    填充色        &#125;        给方块对象中添加绘制的方法        rect.draw=function()&#123;            每调用一次这个函数执行一次x+2的操作            this.x += 2            cxt.fillStyle = this.color            cxt.fillRect(this.x, this.y, this.w, this.h)        &#125;        setInterval(function () &#123;            绘图之前先清空画布,如果不清空的话,就会看到一连串的方块            ctx.clearRect(0, 0, canvas.width, canvas.height)            调用绘制方块的函数            rect.draw()        &#125;,30)&lt;script&gt;\n上面的例子我们可以看到,我先创建了一个rect对象,这个对象中储存的是绘制的方块的各种信息,如宽高,位移,颜色等.然后给rect对象添加一个绘制的功能(draw),其中这个功能中将this.x累加,最后在外面利用一个没30毫秒执行一次的定时器来调用rect.draw(),这样就实现了让方块一直向右运动的效果(有一点要注意,在每次调用绘制方法之前,都得清空当前的画布)清空画布的方法:clearRect(startX,startY,endX,endY)第一,二个参数表示的是清空的其实位置,后俩个位置表示清空的结束位置.这里我想清空的是整个画布,也就是其实位置从(0,0)点开始,结束位置就是整个画布的宽度和高度(画布的最右下角).\n躁动的小球好的,说完上面的例子,我就可以来介绍这篇文章的主要内容,”躁动的小球”,我们先来看下效果图:\n\n可以看到,效果就是在画布中,绘制出各种颜色不同,透明度不同的小球,并且这些小球是可以四处乱窜的.\n1. 布局先来看看布局,实际是布局上很简单,就是一个class为out的div内盛放一个\n123&lt;div class=out&gt;    &lt;canvas id=canvas width=1000 height=600&gt;&lt;canvas&gt;&lt;div&gt;\n而在样式上内,我是这样设定的:123456789101112131415&lt;style&gt;        *&#123;            padding: 0;            margin: 0;        &#125;        body&#123;            background-color: #333333;        &#125;        .out&#123;            height: 600px;            width: 1000px;            margin: 50px auto;            box-shadow: 2px 2px 10px #999;        &#125;    &lt;style&gt;\n2. JS部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;script&gt;    **     * 创建一个小球的构造函数     * @param canvasW   画布的宽     * @param canvasH   画布的高     * @param ctx       2d上下文     * @constructor     *    function Ball(canvasW, canvasH, ctx) &#123;        this.canvasW = canvasW        this.canvasH = canvasH        this.ctx = ctx        this.r = this.randomInt(10, 80)        this.x = this.randomInt(this.r, this.canvasW - this.r)        this.y = this.randomInt(this.r, this.canvasH - this.r)        let R = this.randomInt(0, 255)        let G = this.randomInt(0, 255)        let B = this.randomInt(0, 255)        let A = Math.random()        this.color = `rgba($&#123;R&#125;,$&#123;G&#125;,$&#123;B&#125;,$&#123;A&#125;)`        let speedX = this.randomInt(1, 4)        this.speedX = this.randomInt(0, 100) &gt; 50 ? speedX : -speedX        let speedY = this.randomInt(1, 4)        this.speedY = this.randomInt(0, 100) &gt; 50 ? speedY : -speedY    &#125;    绘制一个小球    Ball.prototype.draw = function () &#123;        let deg = Math.PI  180        this.ctx.beginPath()        this.ctx.arc(this.x, this.y, this.r, 0, 360 * deg, true)        this.ctx.closePath()        this.ctx.fillStyle = this.color        this.ctx.fill()    &#125;    小球移动    Ball.prototype.ballMove = function () &#123;        this.x += this.speedX        this.y += this.speedY        if (this.x &gt;= this.canvasW - this.r) &#123;            this.speedX *= -1        &#125; else if (this.x &lt;= this.r) &#123;            this.speedX *= -1        &#125;        if (this.y &gt;= this.canvasH - this.r) &#123;            this.speedY *= -1        &#125; else if (this.y &lt;= this.r) &#123;            this.speedY *= -1        &#125;    &#125;    产生范围随机数的函数    Ball.prototype.randomInt = function (from, to) &#123;        return parseInt(Math.random() * (to - from + 1) + from);    &#125;    let canvas = document.querySelector(#canvas);    let ctx = canvas.getContext(2d)    定义一个数组用来盛放所有的小球对象    let balls = []    for (let i = 0; i &lt; 100; i++) &#123;        let ball = new Ball(canvas.width, canvas.height, ctx);        balls.push(ball)    &#125;    setInterval(function () &#123;        绘图之前先清空画布        ctx.clearRect(0, 0, canvas.width, canvas.height)        for (let i = 0; i &lt; balls.length; i++) &#123;            balls[i].ballMove();            balls[i].draw()        &#125;    &#125;, 30)&lt;script&gt;\n1.也是和上面的demo一样,我想将每一个小球都当成一个”对象”来写,只不过小球的数量不确定,所以我写了一个构造函数Ball,用它来创建每一个小球对象,这样只要利用一个for循环,就可以创建我们想要的数量的小球了.2.这里的绘制小球和移动小球我分别用了俩个函数draw()和ballMove()来写,这样的目的能也是为了达到面向对象的效果,将各个功能拆分开来,一个方法实现一种功能.3.利用for循环来重复调用构造函数Ball,每创建一个小球”对象”,就把它推进数组balls中,这样for循环完之后,balls数组中存放的就是一个个的小球”对象”.4.利用定时器setInterval,每隔30毫秒,调用一次ballMove()和draw()\n","tags":["前端入门","canvas"],"path":"2017/09/21/webNotes/primary/JavaScript/Canvas/canvasOfBall/","external_link":""},{"title":"canvas中图形的组合方式","date":"2017-09-21T11:24:45.000Z","content":"前文我们在用canvas绘图中,经常会碰到当俩个图形重叠时怎么办的问题,这篇文章介绍的就是一些关于俩个图形重叠时的样式的处理问题\n1. 设置组合方式我们可以通过globalCompositeOperation这个属性,我们可以来更改俩个图形重叠时的样式\n如:是想让新图覆盖原始图,还是只保留重叠部分等等.\n语法:1ctx.globalCompositeOperation = source-in\n先来看看几个属性值:  source-over            默认属性,新图像会覆盖在原有图像  source-in           只保留当前图重叠的部分  source-out          绘制不重叠部分  source-atop           新图像仅仅显示与老图像重叠区域,老图像仍然可以显示  destination-over    原图覆盖新图  destination-in      绘制原图和新图重叠部分  destination-out     绘制原图和新图不重叠部分  destination-atop    绘制原图和新图重叠部分以及新图  lighten              绘制新图和原图,重叠部分加色处理  darken            保留重叠部分最黑的像素  lighter             保证重叠部分最量的像素  copy                绘制新图,覆盖原图  xor                  重叠部分会变成透明\n1.2 几种组合方式案例例1:\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;title&gt;\n    &lt;style type=&quot;textcss&quot;&gt;\n        #canvas1{\n            border:1px solid red;\n        }\n    &lt;style&gt;\n&lt;head&gt;\n&lt;body&gt;\n&lt;canvas id=&quot;canvas1&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;canvas&gt;\n&lt;body&gt;\n&lt;script type=&quot;textjavascript&quot;&gt;\n    var canvas = document.getElementById(&quot;canvas1&quot;);\n    var ctx = canvas.getContext(&quot;2d&quot;);\n\n    ctx.fillStyle = &quot;red&quot;;\n    ctx.beginPath();\n    ctx.arc(150, 150, 100, 0, Math.PI*2, true);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = &quot;green&quot;;\n    ctx.beginPath();\n    ctx.arc(250,150, 100, 0, Math.PI*2, true);\n    ctx.closePath();\n    ctx.fill();\n\n&lt;script&gt;\n&lt;html&gt;\n上面的例子中,我没有对图片的重叠部分做任何的处理,效果就是和source-over一样,新图会覆盖原图:\n\n在代码中加入globalCompositeOperation属性的时候,会呈现不同的效果\n1.source-over(default)新图像会覆盖在原有图像。(默认)\n2.source-in只保留当前图重叠的部分其他区域都变成透明的。(包括其他的老图像区域也会透明)    ctx.globalCompositeOperation = &quot;source-in&quot;\n\n3.source-out绘制不重叠部分ctx.globalCompositeOperation = &quot;source-out&quot;\n\n4.source-atop新图像仅仅显示与老图像重叠区域。老图像仍然可以显示。\n\n5.destination-over原图覆盖新图    ctx.globalCompositeOperation = &quot;destination-over&quot;\n\n6.destination-in绘制原图和新图重叠部分ctx.globalCompositeOperation = &quot;destination-in&quot;\n\n7.destination-out绘制原图和新图不重叠部分ctx.globalCompositeOperation = &quot;destination-out&quot;\n\n8.destination-atop绘制原图和新图重叠部分以及新图   ctx.globalCompositeOperation = &quot;destination-atop&quot;\n\n9.lighten绘制新图和原图,重叠部分加色处理    ctx.globalCompositeOperation = &quot;lighter&quot;\n\n10.darken保留重叠部分最黑的像素。(每个颜色位进行比较，得到最小的)blue: #0000ffred: #ff0000所以重叠部分的颜色：#000000 ctx.globalCompositeOperation = &quot;darken&quot;\n\n11.lighter保证重叠部分最量的像素。(每个颜色位进行比较，得到最大的)blue: #0000ffred: #ff0000所以重叠部分的颜色：#ff00ff    ctx.globalCompositeOperation = &quot;lighter&quot;\n12.copy只有新图像会被保留，其余的全部被清除(变透明)ctx.globalCompositeOperation = &quot;copy&quot;\n\n13.xor重叠部分会变成透明ctx.globalCompositeOperation = &quot;xor&quot;\n\n","tags":["前端入门","canvas"],"path":"2017/09/21/webNotes/primary/JavaScript/Canvas/imgOfCombination/","external_link":""},{"title":"H5新API","date":"2017-03-08T11:24:45.000Z","content":"第一章:cookie Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户的身份、进行 session 的跟踪而储存在用户本地终端上的数据（通常经过加密）。\n Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。\n cookie是浏览器提供的一种机制，它将document 对象的cookie属性提供给JavaScript。可以由JavaScript对其进行控制，而并不是JavaScript本身的性质。cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。 而且不同的浏览器之间cookie不能共享。\n==cookie的本质就是用键值对存储在用户本地的一些数据，这些数据不同的网站，不同的浏览器是不能共享的==\n用处:\n保存用户登录状态\n跟踪用户行为\n定制页面\n创建购物车\n缺陷:    \n\ncookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；\ncookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；\ncookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；\ncookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。\n\n1.1创建查看cookiecookie的运行环境必须在服务器的环境下\n直接在标签中写上:\n123&lt;script&gt;    document.cookie = &quot;user=wangxiansheng&quot;&lt;script&gt;\n要保证在服务器环境下\n此时打开页面,点击地址栏左侧的感叹号:\n查看Cookie:在你的localhost里查看Cookie文件夹,找到user\n可以看到里面有 名字, 内容, 域, 路径, 创建,过期时间等等.\n2.也可以直接弹出cookie查看\n12document.cookie = user=wangxianshengalert(document.cookie)\n1.2 设置cookie的过期时间当我们查看Cookie的时候,可以看到它默认的过期时间是:回话窗口关闭后\n那么怎样来修改它的过期时间呢\n可以直接在设置cookie的时候,加上expirse来进行设置\n那么一般我们都会封装一个函数来进行设置\n例1:\n12345678910111213&lt;script&gt;\t\tfunction setCookie(name, value, day) &#123;        expires:过期时间, 接受一个日期对象        var d  = new Date()        d.setTime(d.getTime() + day * 24 * 60 * 60 * 1000)        var expires = d.toUTCString()        一个条目包含保存的键值对和过期时间        document.cookie = name + = + value + ; expires= + expires    &#125;    setCookie(user,wangxiansheng,2)    setCookie(user,li,2)    console.log(document.cookie)&lt;script&gt;\n1=&gt;\tuser=wangxiansheng; li; _ga=GA1.1.576406365.1501552757\n此时查看cookie的过期时间为2天后\n1.3 分隔cookie的内容在上面的例1中\n可以看到在控制台中打印出来的cookie是一串字符串\n我们可以设定一个函数用来分隔这串字符串从而得到我们想要的数据\n1234567891011function getCookie(name)&#123;        var cookie = document.cookie        var arr = cookie.split(&apos;;&apos;)        for(var i = 0; i &lt; arr.length; i++) &#123;            var arr2 = arr[i].split(&apos;=&apos;)            if(arr2[0] === name) &#123;                return arr2[1]            &#125;        &#125;    &#125;\n1.4 删除cookie123function removeCookie(name) &#123;  setCookie(name, &apos;.&apos;, -1)&#125;\n可以将上面的三个方法都封装到一个js文件中,这样这个js文件就提供了三种方法,分别用于获取cookie,设置cookie,删除cookie.要用的时候只要引用这个js文件就行了.\n12345678910111213141516171819202122232425cookie.js文件:function setCookie(name, value, day) &#123;    expires:过期时间, 接受一个日期对象    var d  = new Date()    d.setTime(d.getTime() + day * 24 * 60 * 60 * 1000)    var expires = d.toUTCString()    一个条目包含保存的键值对和过期时间    document.cookie = name + = + value + ; expires= + expires&#125;function getCookie(name)&#123;    var cookie = document.cookie    var arr = cookie.split(;)    for(var i = 0; i &lt; arr.length; i++) &#123;        var arr2 = arr[i].split(=)        if(arr2[0] === name) &#123;            return arr2[1]        &#125;    &#125;    return false&#125;function removeCookie(name) &#123;    setCookie(name, ., -1)&#125;\n第二章: 登录小案例实现效果:\n表单中提供一个输入框用于输入用户名,一个密码框用于输入密码\n俩个单选框,用于用户是否要保存用户名或者密码,要是勾选上了,当点击登录时,浏览器会记住用户名或密码,这样无论怎样刷新页面,输入框中的用户名或者密码还是存在在那里.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;用户登录&lt;title&gt;&lt;head&gt;&lt;body&gt;&lt;form id=form1 action=# method=get&gt;用户名:&lt;input type=text id=user&gt;&lt;br&gt;密码:&lt;input type=password id=pass&gt;&lt;br&gt;是否记住用户名:&lt;input type=checkbox id=saveUser&gt;&lt;br&gt;是否保存密码:&lt;input type=checkbox id=savePass&gt;&lt;br&gt;&lt;input type=submit value=登录 id=sub&gt;&lt;form&gt;&lt;script type=textjavascript src=cookie.js&gt;&lt;script&gt;\t调用上面已经写好的cookie.js&lt;script&gt;    let user = document.querySelector(#user)    let pass = document.querySelector(#pass)    let saveUser = document.querySelector(#saveUser)    let savePass = document.querySelector(#savePass)    let form1 = document.querySelector(#form1)        获取用户名和密码,判断用户是不是选择存储了用户名和密码    if(getCookie(user)) &#123;        user.value = getCookie(user)        saveUser.checked = true    &#125;    if(getCookie(pass)) &#123;        pass.value = getCookie(pass)        savePass.checked = true    &#125;    表单提交时,判断用户是不是勾选了俩个单选框(也就是判断用户是否要存储用户名或者密码)    form1.onsubmit=function () &#123;        console.log(saveUser.checked);        if(saveUser.checked) &#123;            保存用户名            setCookie(user, user.value, 30)        &#125; else &#123;            删除            if (getCookie(user)) &#123;                removeCookie(user)            &#125;        &#125;        if(savePass.checked) &#123;            保存密码            setCookie(pass, pass.value, 30)        &#125; else &#123;            if (getCookie(pass)) &#123;                removeCookie(pass)            &#125;        &#125;    &#125;&lt;script&gt;&lt;body&gt;&lt;html&gt;\n第三章:HTML5本地存储3.1HTML5本地存储的优点\n解决了4k的大小问题\n解决了请求头常带存储信息的问题\n解决了关系型存储的问题\n跨浏览器\n\nWeb Storage 包含如下两种机制：\n\nsessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。\nlocalStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。\n\n3.2 localStoragewindow下的一个属性\n通过window.localStorage    来调用\n提供的属性和方法:    \nstorage代表着localStorage或sessionStorage,方法和属性都通用\n属性:\nstorage.length\n 返回一个整数，表示存储在storage对象中的数据项的数量\n1console.log(window.localStorage.length);\n方法:\n1.存储\nstorage.setItem(keyName, keyValue)\n 接受一个键名和值作为参数，将会把键名添加到存储中，如果键名已存在，则更新其对应的值。\n1window.localStorage.setItem(&apos;user&apos;,&apos;wangpeilin&apos;)\n此时查看:\n\n2.利用key查看存储的键名    \nstorage.key(index)\n 返回存储对象第 index 个数据项的键名。index 从 0开始\n12console.log(window.localStorage.key(0));=&gt;user\n3.获取存储的值\nstorage.getItem(keyName)\n 接受一个键名（key name）作为参数，并返回对应键名的值（key&#39;s value）。\n12console.log(window.localStorage.getItem(&apos;user&apos;));=&gt;wangpeilin\n若没有,返回null    \n4.移除存储    \nstorage.removeItem(keyName)\n 接受一个键名作为参数，会把该键名和对应的键值从存储中移除。(删除键值对)\n123window.localStorage.removeItem(user)   console.log(window.localStorage.getItem(user));   =&gt;null\n5.清除存储\nstorage.clear()\n 清空存储对象里所有的键值\n1window.localStorage.clear(&apos;user&apos;)\n3.3 sessionStorage使用方式和loaclStorage相同\n第四章: 更改背景色小案例利用本地存储localStoragez来存储用户选择的背景颜色已经图片的src,就算用户属性页面,背景色及图片src也不会发生改变\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;test1&lt;title&gt;    &lt;style&gt;        body&#123;            background-color: #CCCCCC;        &#125;    &lt;style&gt;&lt;head&gt;&lt;body&gt;&lt;div id=bg_color&gt;    &lt;p&gt;选择背景色&lt;p&gt;    &lt;input type=color value=#ff0000 id=color&gt;    &lt;span&gt;&lt;span&gt;&lt;div&gt;&lt;div id=image&gt;    &lt;p&gt;选择图片&lt;p&gt;    &lt;select&gt;        &lt;option value=imgimg1.jpg selected&gt;瀑布&lt;option&gt;        &lt;option value=imgimg2.jpg&gt;海龟&lt;option&gt;        &lt;option value=imgimg3.jpg&gt;背景图&lt;option&gt;    &lt;select&gt;    &lt;br&gt;    &lt;img src=imgimg1.jpg alt=&gt;&lt;div&gt;&lt;script src=cookie.js&gt;&lt;script&gt;&lt;script&gt;    let colorInput = document.querySelector(#color)    let imgSelect = document.querySelector(#image select)    let img =document.querySelector(#image img)    let span = document.querySelector(#bg_color span)    if(localStorage.getItem(color)) &#123;\t\t若检测到本地存储中以及存储了color,则不需要再进行存储了,直接调用setStyle就OK        setStyle()    &#125;    if(localStorage.getItem(imgSrc)) &#123;        setStyle()    &#125;    colorInput.onchange=storage;    imgSelect.onchange=storage;     存储用户的选择    function storage()&#123;        window.localStorage.setItem(color,colorInput.value)        window.localStorage.setItem(imgSrc,imgSelect.value)\t\t调用设置样式的函数        setStyle()    &#125;    function setStyle()&#123;        let backColor = localStorage.getItem(color)        let imgSrc = localStorage.getItem(imgSrc)        document.body.style.backgroundColor = backColor        span.innerHTML = backColor        img.src = imgSrc        colorInput.value = backColor        imgSelect.value = imgSrc    &#125;&lt;script&gt;&lt;body&gt;&lt;html&gt;\n效果图:\n\n第五章: 地理位置APIHTML5Geolocation API 用于获得用户的地理位置。\n鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。\n\n浏览器支持：\n\nInternetExplorer 9、Firefox、Chrome、Safari以及 Opera支持地理定位。\n注释：对于拥有 GPS的设备，比如 iPhone，地理定位更加精确。\n5.1 获取Geolocation对象navigator 只读属性返回一个 Geolocation 对象，通过这个对象可以访问到设备的位置信息。这允许网站或应用根据用户的位置提供个性化结果。\n1console.log(navigator.geolocation)\n\n可以看到Geolocation对象提供了三种方法    \n1. getCurrentPositionnavigator.geolocation.getCurrentPosition(success, error, options)\n这个方法用于获取当前设备的地理位置。\n3个参数：\nsuccess\n成功得到位置信息时的回调函数，使用Position对象作为唯一的参数。\nerror 可选\n获取位置信息失败时的回调函数，使用 PositionError对象作为唯一的参数，这是一个可选项。\noptions 可选\n一个可选的PositionOptions 对象。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt;&lt;button&gt;获取地理位置信息&lt;button&gt;&lt;div&gt;    &lt;p&gt;你的地理位置信息是：&lt;p&gt;    &lt;p&gt;&lt;p&gt;&lt;div&gt;&lt;script&gt;document.querySelector(&quot;button&quot;).onclick = function ()&#123;      location有两个属性：coords 封装了位置信息  timestamp  时间戳    navigator.geolocation.getCurrentPosition(function (location)&#123;        var longitude = location.coords.longitude;  经度        var latitude = location.coords.latitude;  纬度        var altitude = location.coords.altitude;  海拔. 如果不提供则返回null        var accuracy = location.coords.accuracy;  精度        var speed = location.coords.speed;  运动速度 如果不提供则返回null        document.querySelector(&quot;div p:nth-child(2)&quot;).innerHTML =            `经度：$&#123;longitude&#125;&lt;br&gt;             维度：$&#123;latitude&#125;&lt;br&gt;             海拔：$&#123;altitude&#125;米&lt;br&gt;             精度：$&#123;accuracy&#125;米&lt;br&gt;             运动速度：$&#123;speed&#125;ms&lt;br&gt;            `;    &#125;, function (postionError)&#123;        var errorMsg;        switch (postionError.code)&#123;            case 1 :                errorMsg = &quot;地理位置信息的获取失败，因为该页面没有获取地理位置信息的权限。&quot;                break            case 2 :                errorMsg = &quot;地理位置获取失败，因为至少有一个内部位置源返回一个内部错误。&quot;                break            case 3 :                errorMsg = &quot;地理位置获取失败，因为至少有一个内部位置源返回一个内部错误。&quot;                break        &#125;        document.querySelector(&quot;div p:nth-child(2)&quot;).innerHTML = errorMsg;    &#125;,&#123;        enableHighAccuracy : true,        timeout : 3000,        maximumAge : 10000    &#125;);&#125;;&lt;script&gt;&lt;body&gt;\n2. watchPosition用于注册监听器，在设备的地理位置发生改变的时候自动被调用。也可以选择特定的错误处理函数。\n参数和方法1是一样的。\n返回值是监听器的 id\n3. clearWatchnavigator.geolocation.clearWatch(id);\n取消由 watchPosition()注册的位置监听器。\n第六章: File Api 在HTML5之前的，从网页上传文件一次只能上传一个文件，而且也无法对要上传的文件做更深一步的操作。\n HTML5提供了一个系列关于文件操在的API，通过使用这些API，对于从Web页面访问本地文件系统的相关处理将会变的非常简单。\n &lt;input&gt;的type属性为 file 的时候，那么它就可以访问本地文件系统了。\n在HTML5之前，一次只能选择一个文件。HTML5中，给&lt;input&gt;添加属性 multiple 则可以一次选择多个文件。\n注意：multiple或multiple=’multiple’ 两种写法都可以。\n123&lt;form action=&quot;#&quot; enctype=&quot;multipartform-data&quot;&gt;    &lt;input type=&quot;file&quot; multiple&gt;&lt;form&gt;\n 用户选择的每一个文件都是一个File对象，而如果选择了多个File，则FileList表示这些多个File对象的列表集合。\n6.1 File对象的属性File对象是用户上传上来的文件\nFile主要提供了4个属性(包括从Blob中的继承的)\n\nfile.lastModified：表示的文件的最后修改时间。以毫秒为单位。\nfile.name：获取的是文件的文件名。由于安全考虑，这个地方的文件名不包含路径。\nfile.size：获取到文件大小。以字节为单位。\nfile.type: 获取文件的 mime 类型\n\n6.2 FileLis列表集合FileList是多个File的列表集合.\n可以通过 input.files来得到FileList\n如:\n123456&lt;input id=file1 type=file&gt;&lt;script&gt;\t获取fileList上传的文件列表\tlet file1 = document.querSelector(#file1)\tlet files = file1.files\n属性:\nlist.length:文件的数量\n1234获取fileList上传的文件列表let file1 = document.querSelector(#file1)      let files = file1.files      console.log(files.length);\n方法:\n1.list.item(index):\n\n获取 file.注意:index从0开始计算.\n\n遍历fileList列表:\n12345678910\t\t获取fileList上传的文件列表\t\tlet file1 = document.querSelector(#file1)        let files = file1.files        for(let i = 0; i &lt; files.lenght; i++) &#123;          let file = files.item(i)\t\t每一个用户选择的文件对象          console.log(file)        &#125;        =&gt;File &#123;name: text1.txt, lastModified: 1506412495353, lastModifiedDate: Tue Sep 26 2017 15:54:55 GMT+0800 (中国标准时间), webkitRelativePath: , size: 9, …&#125;File &#123;name: text2.txt, lastModified: 1506412725170, lastModifiedDate: Tue Sep 26 2017 15:58:45 GMT+0800 (中国标准时间), webkitRelativePath: , size: 11, …&#125;\n6.3 Blob对象\n表示二进制原始文件。前面见到的File对象也继承了Blob对象。\n\n注意包括两个属性：size和type。\nsize：表示Blob对象的字节长度。 File文件的size就是继承这里的size\ntype：表示Blob的MIME类型。如果未知则返回一个长度为 0 的字符串。FIle对象也继承了这个属性\n12345for(var i = 0; i &lt; files.length; i++)&#123; files.length:返回类别中File对象的数量       var file = files.item(i);       var msg = `第$&#123;i + 1&#125;个文件的MIME类型：$&#123;file.type&#125;&lt;br&gt;`;       content.innerHTML += msg&#125;\n6.4 FileReader对象 FileReader对象允许Web 应用程序以==异步的方式读取文件的内容==，使用File对象或Blob对象指定要读取的文件.\n1let reader = new FileReader()\nFileReader对象主要包括3个属性和5个方法、6个事件.\n1. 3个属性\n1.FileReader.error: 读取文件的时候发生的错误信息\n\n\n2.FileReader.readyState:0-2数字,表示FileReader的状态\n\n\n\n\n状态\n数字\n状态信息\n\n\n\n\nEMPTY\n0\n还没有加载到数据\n\n\nLOADING\n1\n正在加载数据\n\n\nDONE\n2\n数据加载完成\n\n\n\n\n3.FileReader.result:读取到的内容\nFileReader.result:这个是最重要的属性。读取到的内容都存储在了这个属性中。只能在readyState DONE之后才能读取这个属性值。读取到的数据类型取决于用什么的方法去读取的文件。\n\n2.  5个方法\nFileReader.abort()：终止读取文件的操作。这个方法一点结束，则readyState就成为了DONE\nFileReader.readAsArrayBuffer()：开始读取文件的内容，一旦完成，则把文件的数据存储在ArrayBuffer中。当然ArrayBuffer自然也会存储在FileReader的result属性中\nFileReader.readAsBinaryString()：以二进制的形式读取文件的内容。这个方法是非标准方法，不要使用。\nFileReader.readAsDataURL()：将文件读取为DateUrl\nFileReader.readAsText()：将文件的内容读取文本。读取纯文本内容的时候使用.\n\n3. 6个事件1.FileReader.onloadstart：数据开始读取时触发。\n2.FileReader.onprogress：数据读取过程中触发。\n3.FileReader.onloadend：数据读取完成后触发。不管数据读取成功还是失败都会触发。\n4.FileReader.onload：数据读取成功后触发。\n5.FileReader.onabort：数据读取被中断时触发。\n6.FileReader.onerror：数据读取发生错误时触发。\n4. FileReader案例实现功能:\n打开页面,有一个选择文件的标签让用户选择要上传的文件,\n若是上传的文件是文本文件,则显示在p标签中,(可以上传多个文本)\n若是上传的文件是图片,则会显示在img标签中.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;file&lt;title&gt;&lt;head&gt;&lt;body&gt;&lt;form action=# enctype=multipartform-data&gt;    &lt;input type=file  id=file1 multiple&gt;&lt;form&gt;&lt;button id=btn1&gt;获取上传文件信息&lt;button&gt;&lt;p id=content&gt;&lt;p&gt;&lt;img id=img1 src=&gt;&lt;script&gt;    let file1 = document.querySelector(#file1)    let btn1 = document.querySelector(#btn1)    let content = document.querySelector(#content)    let img1 = document.querySelector(#img1)    btn1.onclick = function () &#123;        if(!FileReader) &#123;\t\t判断当前的浏览器支不支持FileReader            content.innerHTML = 你的文件不支持FileApi            return        &#125;        获取fileList上传的文件列表        let files = file1.files\t\t变量文件列表        for(let i = 0; i &lt; files.length; i++ ) &#123;            获取用户选择的每一个文件            let file = files.item(i)                      判断文件类型,如果以text开头,就是文本文件            if(file.type.startsWith(text)) &#123;                 文本文件                let reader = new FileReader()                读取文本文件                reader.readAsText(file, utf-8)                reader.onload = function () &#123;                    读取成功                    content.innerHTML += this.result + &lt;hr&gt;                &#125;            &#125; else if (file.type.startsWith(image)) &#123;\t判断文件类型,是image开头,就是图片                let reader = new FileReader()                reader.readAsDataURL(file)                reader.onload = function () &#123;                    img1.src = this.result                &#125;            &#125;        &#125;    &#125;&lt;script&gt;&lt;body&gt;&lt;html&gt;\n5.将元素拖拽在容器内1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;将元素拖拽添加到容器内&lt;title&gt;    &lt;style&gt;        *&#123;            list-style: none;        &#125;        #div1&#123;            width: 200px;            height: 200px;            background-color: #ccc;        &#125;    &lt;style&gt;&lt;head&gt;&lt;body&gt;&lt;ul&gt;    &lt;li&gt;志玲&lt;li&gt;    &lt;li&gt;凤姐&lt;li&gt;    &lt;li&gt;张三&lt;li&gt;    &lt;li&gt;李四&lt;li&gt;    &lt;li&gt;王五&lt;li&gt;    &lt;li&gt;马六&lt;li&gt;&lt;ul&gt;&lt;div id=div1&gt;&lt;div&gt;&lt;script&gt;    var ul = document.querySelector(ul)    var lis = document.querySelectorAll(li)    var div1 = document.querySelector(#div1)        for(var i = 0; i &lt; lis.length; i++) &#123;        lis[i].setAttribute(draggable,true)    &#125;        var dragged;    定义变量用以储存拖拽的对象    document.addEventListener(dragstart,function (e) &#123;        dragged = e.target    &#125;, false)    div1.addEventListener(dragover,function (e) &#123;        为了让drop生效        e.preventDefault()    &#125;, false)    ul.addEventListener(dragover, function (e) &#123;        e.preventDefault()    &#125;)    div1.addEventListener(drop, function (e) &#123;    监听div1的落下事件        div1.appendChild(dragged)    &#125;, false)    ul.addEventListener(drop, function () &#123;   监听ul的落下事件        ul.appendChild(dragged)    &#125;, false)&lt;script&gt;&lt;body&gt;&lt;html&gt;\n6. 拖拽上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;    &lt;meta charset=UTF-8&gt;    &lt;title&gt;拖拽上传&lt;title&gt;    &lt;style&gt;        #dropArea&#123;            width: 100%;            height: 300px;            background: #00ADFE;            font-size: 50px;            line-height: 300px;            text-align: center;        &#125;        #img1&#123;            width: 500px;            height: 300px;        &#125;    &lt;style&gt;&lt;head&gt;&lt;body&gt;&lt;div id=dropArea&gt;请将文件拖拽至此区域&lt;div&gt;&lt;img id=img1 src= alt=&gt;&lt;script&gt;    let dropArea = document.querySelector(#dropArea)    let img1 = document.querySelector(#img1)    dropArea.addEventListener(dragover, function (e) &#123;        e.preventDefault()    &#125;, false)    dropArea.addEventListener(dragenter, function (e) &#123;        this.style.backgroundColor = pink    &#125;)    dropArea.addEventListener(drop, function (e) &#123;        这里的e就是你从文件夹里拖拽过来的元素对象DragEvent        console.log(e);        DragEvent对象内有拖动的这个文件的各种信息, 其中主要用到的是dataTransfer属性        let file = e.dataTransfer.files[0]        创建fileReader对象        let reader = new FileReader()        reader.readAsDataURL(file)        reader.onload = function () &#123;            img1.src = this.result        &#125;        this.style.backgroundColor = #00ADFE        阻止文件在新窗口打开        e.preventDefault()    &#125;)&lt;script&gt;&lt;body&gt;&lt;html&gt;\n","tags":["前端进阶","Html"],"path":"2017/03/08/webNotes/advanced/HTML/htmlNewAPI/","external_link":""},{"title":"ES7+ES8","date":"2017-04-08T07:14:45.000Z","content":"前言本篇文章主要介绍ES7+ES8的一些新功能，并结合ES6的一些API做出了相应的比较。\nES71.Array.prototype.includes()\nincludes()作用,是查找一个值在不在数组里,若是存在则返回true,不存在返回false.\n\n1.基本用法：\n12[a, b, c].includes(a)      true[a, b, c].includes(d)      false\n2.接收俩个参数：要搜索的值和搜索的开始索引\n123[a, b, c, d].includes(b)          true[a, b, c, d].includes(b, 1)       true[a, b, c, d].includes(b, 2)       false\n3.与ES6中的indexOf()比较\n有些时候是等效的\n1234567[a, b, c].includes(a)          true[a, b, c].indexOf(a) &gt; -1      truevar arr = [1, 2, 3]var a = 1;arr.includes(a)   truearr.indexOf(a)    0\n\n在判断 +0 与 -0 时，被认为是相同的。\n\n12[1, +0, 3, 4].includes(-0)    true[1, +0, 3, 4].indexOf(-0)     1\n\n只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些，是无法判断的.\n\n123var arr = [1, [2, 3], 4]arr.includes([2, 3])   falsearr.indexOf([2, 3])    -1\n优缺点比较\n\n简便性\n\nincludes()返回的是布尔值，能直接判断数组中存不存在这个值，而indexOf()返回的是索引，这一点上前者更加方便。\n\n精确性\n两者都是采用===的操作符来作比较的，不同之处在于：对于NaN的处理结果不同。\n我们知道js中    NaN === NaN    的结果是false,indexOf()也是这样处理的，但是includes()不是这样的。\n1234let demo = [1, NaN, 2, 3]demo.indexOf(NaN)        -1demo.includes(NaN)       true\n\n\n总结：\n\n由于它对NaN的处理方式与indexOf不同，假如你只想知道某个值是否在数组中而并不关心它的索引位置，建议使用includes()。如果你想获取一个值在数组中的位置，那么你只能使用indexOf方法。\n\n2.求幂运算符基本用法：\n1233 ** 2  9效果同Math.pow(3, 2) 9\n由于是运算符，所以可以和 +=一样的用法\n123var b = 3;b **= 2;console.log(b); 9\nES81.async await异步函数async function()\n1.1作用避免有更多的请求操作，出现多重嵌套，也就是俗称的“回调地狱”\n12345this.$http.jsonp(login, (res) =&gt; &#123;  this.$http.jsonp(getInfo, (info) =&gt; &#123;     do something  &#125;)&#125;)\n因此提出了ES6的Promise,将回调函数的嵌套，改为了链式调用：\n123456789var promise = new Promise((resolve, reject) =&gt; &#123;  this.login(resolve);&#125;).then(() =&gt; &#123;  this.getInfo()&#125;).catch(() =&gt; &#123;  console.log(Error)&#125;)\n1.2声明方式异步函数存在以下四种使用形式：\n\n函数声明： async function foo() {}\n函数表达式： const foo = async function() {}\n对象的方式： let obj = { async foo() {} }\n箭头函数： const foo = async () =&gt; {}\n\n1.3支持返回Promise和同步的值async用于定义一个异步函数，该函数返回一个Promise。如果async函数返回的是一个同步的值，这个值将被包装成一个理解resolve的Promise，等同于return Promise.resolve(value)。await用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await也可以用于一个同步的值。\n12345678910111213141516171819202122232425async await返回Promiselet timer = async function timer() &#123;    return new Promise((reslove, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            reslove(a);        &#125;, 1000);    &#125;)&#125;timer().then(result =&gt; &#123;    console.log(result);&#125;).catch(err =&gt; &#123;    console.log(err.message);&#125;)返回同步的值let sayHello = async function sayHello() &#123;    let hi = hello world等同于return Promise.resolve(hi);    return hi&#125;sayHello().then(res =&gt; &#123;    console.log(res)&#125;).catch(err =&gt; &#123;    console.log(err.message);&#125;)\n1.4对异常的处理\n首先来看下Promise中对异常的处理\n\n1.使用reject\n1234567891011let promise = new Promise((reslove, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;  \treject(promise使用reject抛出异常)    &#125;, 1000)&#125;)promise().then(res =&gt; &#123;  console.log(res)&#125;).catch(err =&gt; &#123;  console.log(err)     promise使用reject抛出异常&#125;)\n2.使用new Error()\n123456789let promise = new Promise((reslove, reject) =&gt; &#123;  \tthrow new Error(promise使用Error抛出异常) 使用throw异常不支持放在定时器中&#125;)promise().then(res =&gt; &#123;  console.log(res)&#125;).catch(err =&gt; &#123;  console.log(err.message)     promise使用Error抛出异常&#125;)\n3.reject一个new Error()\n12345678910111213let promise = new Promise((resolve, reject) =&gt; &#123;       setTimeout(() =&gt; &#123;           reject(new Error(promise抛出异常));       &#125;, 1000);   &#125;)   promise.then(res =&gt; &#123;       console.log(res);   &#125;)   .catch(err =&gt; &#123;       console.log(err.message);  promise抛出异常   &#125;)\n\nasync对异常的处理也可以直接用.catch()捕捉到\n\n12345678910async抛出异常   let sayHi = async sayHi =&gt; &#123;           throw new Error(async抛出异常);   &#125;   sayHi().then(res =&gt; &#123;       console.log(res);   &#125;)   .catch(err =&gt; &#123;       console.log(err.message);   &#125;)\n\n和Promise链的对比：\n\n我们的async函数中可以包含多个异步操作，其异常和Promise链有相同之处，如果有一个Promise被reject()那么后面的将不会再进行。\n1234567891011121314151617181920212223242526272829303132let count = () =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            reject(promise故意抛出异常)        &#125;, 1000);    &#125;)&#125;let list = () =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve([1, 2, 3])        &#125;, 1000);    &#125;)&#125;let getList = async () =&gt; &#123;    let c = await count()    console.log(async)    此段代码并没有执行    let l = await list()    return &#123; count: c, list: l &#125;&#125;console.time(start);getList().then(res =&gt; &#123;    console.log(res)&#125;).catch(err =&gt; &#123;    console.timeEnd(start)    console.log(err)&#125;)start: 1000.81494140625mspromise故意抛出异常\n可以看到上面的案例，async捕获到了一个错误之后就会立马进入.catch()中，不执行之后的代码\n1.5并行上面的案例中，async采用的是串行处理\ncount()和list()是有先后顺序的\n12let c = await count()let l = await list()\n实际用法中，若是请求的两个异步操作没有关联和先后顺序性可以采用下面的做法\n12345let res = await Promise.all([count(), list()])return resres的结果为[ 100, [ 1, 2, 3 ] ]\n案例详情为：\n12345678910111213141516171819202122232425262728let count = ()=&gt;&#123;    return new Promise((resolve,reject) =&gt; &#123;        setTimeout(()=&gt;&#123;            resolve(100);        &#125;,500);    &#125;);&#125;let list = ()=&gt;&#123;    return new Promise((resolve,reject)=&gt;&#123;        setTimeout(()=&gt;&#123;            resolve([1,2,3]);        &#125;,500);    &#125;);&#125;let getList = async ()=&gt;&#123;    let result = await Promise.all([count(),list()]);    return result;&#125;console.time(begin);getList().then(result =&gt; &#123;    console.timeEnd(begin);  begin: 505.557ms    console.log(result);       [ 100, [ 1, 2, 3 ] ]&#125;).catch(err =&gt; &#123;    console.timeEnd(begin);    console.log(err);&#125;);\n\n我们将count()和list()使用Promise.all()“同时”执行，这里count()和list()可以看作是“并行”执行的，所耗时间将是两个异步操作中耗时最长的耗时。最后得到的结果是两个操作的结果组成的数组。我们只需要按照顺序取出数组中的值即可。\n\n1.6与Generator的关系先来回顾一下ES6中Generator函数的用法：\n123456789function* getList() &#123;       const c = yield count()       const l = yield list()       return end   &#125;   var gl = getList()   console.log(gl.next())  &#123;value: Promise, done: false&#125;   console.log(gl.next())  &#123;value: Promise, done: false&#125;   console.log(gl.next())  &#123;value: end, done: true&#125;\n\n虽然Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。此时，我们便希望能出现一种能自动执行Generator函数的方法。我们的主角来了：asyncawait。\n\nES8引入了async函数，使得异步操作变得更加方便。简单说来，它就是Generator函数的语法糖。\n1234let getList = async () =&gt; &#123;  const c = await count()  const l = await list()&#125;\n2.Object.entries()2.1作用\n作用：将一个对象中可枚举属性的键名和键值按照二维数组的方式返回。\n若对象是数组，则会将数组的下标作为键值返回。\n\n12Object.entries(&#123; one: 1, two: 2 &#125;)    [[one, 1], [two, 2]]Object.entries([1, 2])                [[0, 1], [1, 2]]\n2.2要点1.若是键名是Symbol，编译时会被自动忽略\n1Object.entries(&#123;[Symbol()]:1, two: 2&#125;)  [[two, 2]]\n2.entries()返回的数组顺序和for循环一样，即如果对象的key值是数字，则返回值会对key值进行排序，返回的是排序后的结果\n1Object.entries(&#123; 3: a, 4: b, 1: c &#125;)    [[1, c], [3, a], [4, b]]\n3.利用Object.entries()创建一个真正的Map\n1234567var obj = &#123; foo: bar, baz: 42 &#125;;var map1 = new Map([[foo, bar], [baz, 42]]); 原本的创建方式var map2 = new Map(Object.entries(obj));    等同于map1console.log(map1); Map &#123; foo: bar, baz: 42 &#125;console.log(map2); Map &#123; foo: bar, baz: 42 &#125;\n2.3自定义Object.entries()Object.entries的原理其实就是将对象中的键名和值分别取出来然后推进同一个数组中\n1234567891011121314151617181920自定义entries()var obj = &#123; foo: bar, baz: 42 &#125;;function myEntries(obj) &#123;    var arr = []    for (var key of Object.keys(obj)) &#123;        arr.push([key, obj[key]])    &#125;    return arr&#125;console.log(myEntries(obj))Generator版本function* genEntryies(obj) &#123;    for (let key of Object.keys(obj)) &#123;        yield [key, obj[key]]    &#125;&#125;var entryArr = genEntryies(obj);console.log(entryArr.next().value) [foo, bar]console.log(entryArr.next().value) [baz, 42]\n3.Object.values()3.1作用\n作用：只返回自己的键值对中属性的值。它返回的数组顺序，也跟Object.entries()保持一致\n\n12Object.values(&#123; one: 1, two: 2 &#125;)            [1, 2]Object.values(&#123; 3: a, 4: b, 1: c &#125;)    [c, a, b]\n3.2与Object.keys()比较\nES6中的Object.keys()返回的是键名\n\n1234567891011121314var obj = &#123; foo: bar, baz: 42 &#125;;console.log(Object.keys(obj)) [foo, baz]console.log(Object.values(obj)) [bar, 42]Object.keys()的作用就类似于for...infunction myKeys() &#123;    let keyArr = []    for (let key in obj1) &#123;        keyArr.push(key)        console.log(key)    &#125;    return keyArr&#125;console.log(myKeys(obj1)) [foo, baz]\n3.3entries()、values()总结1234var obj = &#123; foo: bar, baz: 42 &#125;;console.log(Object.keys(obj)) [foo, baz]console.log(Object.values(obj)) [bar, 42]console.log(Object.entries(obj)) [[foo, bar], [baz, 42]]\n4.字符串填充4.1padStart()和padEnd()\n字符串填充padStart()和padEnd()\n\n\n用法\nString.padStart(targetLength, padding)\n参数：字符串目标长度和填充字段\n\n123&apos;Vue&apos;.padStart(10)           &apos;       Vue&apos;&apos;React&apos;.padStart(10)         &apos;     React&apos;&apos;JavaScript&apos;.padStart(10)    &apos;JavaScript&apos;\n4.2要点1.填充函数只有在字符长度小于目标长度时才有效,而且目标长度如果小于字符串本身长度时，字符串也不会做截断处理，只会原样输出\n1234Vue.padEnd(10, _*)           Vue_*_*_*_React.padEnd(10, Hello)      ReactHelloJavaScript.padEnd(10, Hi)    JavaScriptJavaScript.padEnd(8, Hi)     JavaScript\n5.Object.getOwnPropertyDescriptors()5.1作用\n该方法会返回目标对象中所有属性的属性描述符，该属性必须是对象自己定义的，不能是从原型链继承来的。\n\n1234567891011121314151617181920212223242526272829303132333435363738    var obj = &#123;        id:  1,        name: 霖呆呆,        get gender() &#123;            console.log(gender)        &#125;,        set grad(d) &#123;            console.log(d)        &#125;    &#125;    console.log(Object.getOwnPropertyDescriptors(obj)) 输出   &#123;  gender: &#123;    configurable: true,    enumerable: true,    get: f gender(),    set: undefined  &#125;,  grade: &#123;    configurable: true,    enumerable: true,    get: undefined,    set: f grade(g)  &#125;,  id: &#123;    configurable: true,    enumerable: true,    value: 1,    writable: true  &#125;,  name: &#123;    configurable: true,    enumerable: true,    value: 霖呆呆,    writable: true  &#125;&#125;\n\n第二个参数,用于指定属性的属性描述符\n\n1234567891011Object.getOwnPropertyDescriptors(obj, id)输出结果应该为&#123;  id: &#123;    configurable: true,    enumerable: true,    value: 1,    writable: true  &#125;&#125;\n但是我在谷歌火狐浏览器试了好像没有效果,有知道原因的小伙请留言\n5.2与getOwnPropertyDescriptor()比较\nES6中也有一个返回目标对象可枚举属性的方法\n\n123456789101112131415161718192021var obj = &#123;    id: 1,    name: 霖呆呆,    get gender() &#123;        console.log(gender)    &#125;,    set grad(d) &#123;        console.log(d)    &#125;&#125;console.log(Object.getOwnPropertyDescriptor(obj, id))        输出结果 &#123;  id: &#123;    configurable: true,    enumerable: true,    value: 1,    writable: true  &#125;&#125;\n两者的区别：一个是只返回知道属性名的描述对象,一个返回目标对象所有自身属性的描述对象\n5.3自定义该方法1234567891011121314function myDescriptors(obj) &#123;    let descriptors = &#123;&#125;    for (let key in obj) &#123;        descriptors[key] = Object.getOwnPropertyDescriptor(obj, key)    &#125;    return descriptors&#125;console.log(myDescriptors(obj))返回的结果和该方法一样其中上面自定义方法的for...in也可以换成,效果也是一样的for (let key of Object.keys(obj)) &#123;    descriptors[key] = Object.getOwnPropertyDescriptor(obj, key)&#125;\n6.函数参数支持尾部逗号该特性允许我们在定义或者调用函数时添加尾部逗号而不报错\n123456789101112131415let foo = function (    a,    b,    c,) &#123;    console.log(a:, a)    console.log(b:, b)    console.log(c:, c)&#125;foo(1, 3, 4, )输出结果为：a: 1b: 3c: 4\n\n它适用于那种多行参数并且参数名很长的情况，开发过程中，如果忘记删除尾部逗号也没关系，ES8已经支持这种写法。\n\n7.修饰器Decorator\nES8神器Decorator，修饰器，也称修饰器模式\n\n7.1 伪Decorator在介绍Decorator之前，我们先来实现这样一个功能：\n定义一个函数，在调用这个函数时，能够执行一些其他额外操作\n如下代码,定义doSometing(),在调用它时再执行其他代码\n12345678910111213141516171819function doSometing(name) &#123;    console.log(Hello + name)&#125;function myDecorator(fn) &#123;    return function() &#123;        console.log(start)        const res = fn.apply(this, arguments)        console.log(end)        return res    &#125;&#125;const wrapped = myDecorator(doSometing)doSometing(lindaidai)Hellowlindaidaiwrapped(lindaidai)start Hellowlindaidaiend\n可以看到上面的操作：其实就是一个函数包装成另一个函数,这样的方式我们称之为“修饰器”    \n同理，我们是不是能用一个什么东西附着在我们的类或者类的属性上，让它们也有一些附加的属性或者功能呢，比如这样：\n123456@addSkillclass Person &#123; &#125;function addSkill(target) &#123;    target.say = hello world;&#125;\n在Person这个类中，开始定义的时候是什么属性都没有的，在其上面使用@来附着上一个函数，这个函数的功能是给目标对象添加额外的属性say。\n这样Person这个类就有了say这个属性了。\n此时控制台输出：\n1console.log(Person[&apos;say&apos;]) &apos;hello world&apos;\n同样的，如果想使用Person这个类创建出来的对象也能附加上一些属性，可以在目标对象的原型对象中进行添加：\n1234567891011@addSkillclass Person &#123; &#125;function addSkill(target) &#123;    target.say = hello world; 直接添加到类中    target.prototype.eat = apple; 添加到类的原型对象中&#125;var personOne = new Person()console.log(Person[say])  hello worldconsole.log(personOne[eat])  apple\n\n上面案例中的@addSkill其实就是一个最简单的修饰器。\n\n当然，如果你将上面案例中的代码复制到你html文件中，会发现它并不能如愿的执行:\n\n那是因为decorator是es7提供的方法，在浏览器中是无法直接运行的，如果你想要使用它，我们需要提前做一些准备，对它进行编译。\n如果你不想深入其中，只是想单纯的了解并使用它可以参考下面的简易教程。\n7.2 快速使用网上使用Decorator的教材有很多，大多都是要需要使用插件来让浏览器支持Decorator。这里长话短说，贴上一个最精简的使用教程：\n\n1.创建一个名为：Decorator的文件夹\n2.在文件夹目录下执行命令行\n12&gt; npm i babel-plugin-transform-decorators-legacy babel-register --save-dev&gt;\n\n\n此时文件夹下会出现俩个文件： node_modules 依赖文件夹和package.json-lock.json\n\n\n3.创建文件 complie.js\n12345&gt; require(&apos;babel-register&apos;)(&#123;&gt;     plugins: [&apos;transform-decorators-legacy&apos;]&gt; &#125;);&gt; require(&quot;.app.js&quot;)&gt;\n\n\n4.创建文件 app.js\n1234567&gt; @addSkill&gt; class Person &#123; &#125;&gt; function addSkill(target) &#123;&gt;     target.say = &quot;hello world&quot;;&gt; &#125;&gt; console.log(Person.say)   &apos;hello world&apos;&gt;\n\n\n5.在根目录下执行指令：\n12&gt; node complie.js&gt;\n\n\n此时可以看到命令行中打印出了 hello world\n\n简单介绍下上面步骤的原理：\n第二步中使用了俩个基础插件：\n12345transform-decorators-legacy：是第三方插件，用于支持decoratorsbabel-register：用于接入node api\n第三步、第四步创建的俩个文件\n12complie.js  用来编译appapp.js   使用了装饰器的js文件\n第五步：\n12345原理：1，node执行complie.js文件；2，complie文件改写了node的require方法；3，complie在引用app.js，使用了新的require方法；4，app.js在加载过程中被编译，并执行。\n\n当然你也可以将app.js替换为app.ts 不过别忘了把complie.js中的app.js修改为app.ts\n\n12345678 app.ts@addSkillclass Person &#123; &#125;function addSkill(target) &#123;    target.say = hello world;&#125;console.log(Person[say])   这里如果直接使用Person.say会提示say属性不存在,如我使用的vscode编辑器就会报错,是因为ts的原因，只需要用[]的形式获取对象属性即可。\n注：ts中有些语法是和js中不一样的，比如有些对象上提示没有属性的时候，只需要换一种获取对象属性的方式即可。\n7.3 类修饰器直接作用在类上面的修饰器，我们可以称之为类修饰器。\n如上面案例中的@addSkill就是一个类修饰器，它修改了Person这个类的行为，为它加上了静态属性say。\naddSkill函数的参数target是Person这个类本身。\n\n 1.修饰器的执行原理基本就是这样：\n\n1234567@decoratorclass A &#123;&#125; 等同于class A &#123;&#125;A = decorator(A) || A;\n换句话说，类修饰器是一个对类进行处理的函数。\n它的第一个参数target就是函数要处理的目标类。\n\n2.多参数\n\n当然如果你想要有多个参数也是可以的，我们可以在修饰器外面再封装一层函数：\n12345678@addSkill(hello world)class Person &#123; &#125;function addSkill(text) &#123;    return function(target) &#123;        target.say = text;    &#125;&#125;console.log(Person.say)  hello world\n上面代码中，修饰器addSkill可以接受参数，这就等于可以修改修饰器的行为。\n\n3.修饰器在什么时候执行。\n\n先来看一个案例：\n1234567891011@looksclass Person &#123; &#125;function looks(target) &#123;    console.log(I am handsome)    target.looks = handsome&#125;console.log(Person[looks])I am handsomehandsome\n在修饰器@looks中添加一个console.log()语句，却发现它是最早执行的，其次才打印出handsome。\n这是因为装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。    \n\n装饰器是在编译时就执行的函数\n\n7.4 方法修饰器上面的案例中，修饰器作用的对象是类本身。\n当然修饰器不仅仅这么简单，它也可以作用在类里的某个方法或者属性上，这样的修饰器我们称它为方法修饰器。\n如下面的案例：\n1234567891011121314151617181920212223242526272829class Person &#123;    constructor() &#123;&#125;    @myname  方法修饰器    name() &#123;        console.log(霖呆呆)     &#125;&#125;function myname(target, key, descriptor) &#123;    console.log(target);    console.log(key);    console.log(descriptor);    descriptor.value = function() &#123;        console.log(霖呆呆)    &#125;&#125;var personOne = new Person() 实例化personOne.name() 调用name()方法打印结果：Person &#123;&#125;name&#123; value: [Function: name],  writable: true,  enumerable: false,  configurable: true  &#125;霖呆呆\n上面案例中的修饰器@myname是放在name()方法上的，myname函数有三个参数：\n123target: 类的原型对象，上例是Person.prototypekey: 所要修饰的属性名  namedescriptor: 该属性的描述对象\n我们改变了descriptor中的value，使之打印出霖呆呆。\n7.5 多个修饰器的执行顺序若是同一个方法上有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\n1234567891011121314151617181920212223class Person &#123;    constructor() &#123;&#125;    @dec(1)    @dec(2)    name() &#123;        console.log(霖呆呆)    &#125;&#125;function dec(id) &#123;    console.log(out, id);    return function(target, key, descriptor) &#123;        console.log(id);    &#125;&#125;var person = new Person()person.name()结果out 1out 221霖呆呆\n如上所属，外层修饰器dec(1)先进入，但是内层修饰器dec(2)先执行。\n7.6 不能作用于函数修饰器不能作用于函数之上，这是因为函数和变量一样都会提升\n123456789var counter = 0;var add = function () &#123;  counter++;&#125;;@addfunction foo() &#123;&#125;\n如上面的例子所示，给函数foo()定义了修饰器@add，作用是想将counter++\n预计的结果counter为1，但实际上却还是为0\n原因：\n定义的函数foo()会被提升至最上层，定义的变量counter和add也会被提升，效果如下：\n123456789101112@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123;  counter++;&#125;;\n总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。\n另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。\n如在7.1中的例子所示：\n12345678910111213141516171819function doSometing(name) &#123;    console.log(Hello + name)&#125;function myDecorator(fn) &#123;    return function() &#123;        console.log(start)        const res = fn.apply(this, arguments)        console.log(end)        return res    &#125;&#125;const wrapped = myDecorator(doSometing)doSometing(lindaidai)Hellowlindaidaiwrapped(lindaidai)start Hellowlindaidaiend\n后语知识无价，尊重原创。参考文集：10分钟学会ES7+ES8JavaScript中的装饰器–Decoratores7-decorator修饰器运行环境搭建及实践阮一峰Decorator详解\n","tags":["前端进阶","ES7"],"path":"2017/04/08/webNotes/advanced/JavaScript/es7/","external_link":""},{"title":"canvas基础","date":"2016-03-08T11:24:45.000Z","content":"第一章: canvas简介&lt;canvas&gt; 是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。\n主要用途:\n•基础图形的绘制\n•文字的绘制\n•图形的变形和图片的合成\n•图片和视频的处理\n•动画的实现\n•小游戏的制作\n第二章: 基本使用2.1 canvas标签1&lt;canvas id=canvas width=300 height=300&gt;&lt;canvas&gt;\ncanvas有俩个可选的属性:\n​    1.宽度width:    默认为300px    ;\n​    2.高度height:        默认为150px;\n也可以使用css来控制宽高:\n但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用css属性来设置&lt;canvas&gt;的宽高。    \n2.2 兼容性问题\n由于某些较老的浏览器（尤其是IE9之前的IE浏览器）或者浏览器不支持HTML元素&lt;canvas&gt;，在这些浏览器上你应该总是能展示替代内容。\n 支持&lt;canvas&gt;的浏览器会只渲染&lt;canvas&gt;标签，而忽略其中的替代内容。不支持 &lt;canvas&gt; 的浏览器则 会直接渲染替代内容。\n\n\n1.用文本替换:\n\n123&lt;canvas&gt;\t您的浏览器不支持canvas,建议您升级流浪器&lt;canvas&gt;\n\n用 &lt;img&gt; 替换：\n\n123&lt;canvas&gt;    &lt;img src=&quot;.王先生.jpg&quot; alt=&quot;&quot;&gt; &lt;canvas&gt;\n3.3 基本图形设置\n\n\nbeginPath()\n开始绘制\n\n\n\n\nmoveTo(x,y)\n设置绘制起点\n\n\nlineTo(x,y)\n设置下一个点\n\n\nclosePath()\n结束绘制,会从当前点回到结束点,形成一个封闭的图形\n\n\nstrokeStyle\n设置绘制的样式\n\n\nstroke()\n绘制点之间的路线\n\n\nfillStyle\n设置填充样式\n\n\nfill()\n填充当前绘图\n\n\nlineWidth\n线宽\n\n\n\n第二章: 基本图形绘制2.1  绘制矩形1. 利用线条画矩形123456789101112131415161718192021222324252627282930313233&lt;body&gt;\t&lt;canvas id=canvas style=border: 1px solid #000&gt;您的浏览器不支持&lt;canvas&gt;\t&lt;script&gt;      \t获取canvas        let canvas = document.querySelector(#canvas)\t\t\t\t设置画布的宽高        canvas.width = 800        canvas.height = 800        \t\t获得 2d 上下文对象\t\tlet context = canvas.getContext(2d)        context.lineWidth = 5     指定一条直线的宽度\t\t\t\t指定开始绘制\t\tcontext.beginPath()\t\t\t\t状态设置        context.moveTo(100,100)\t设置起点        context.lineTo(500,100)\t设置下一个点        context.lineTo(500,400)        context.lineTo(100,400)        context.lineTo(100,100)        闭合路径        context.closePath()        context.strokeStyle = #058   指定一条直线的样式                绘制点之间的路线        context.stroke()                填充        context.fillStyle = red        context.fill()\n效果图:\n\n2. 绘制多个矩形12345678910111213141516171819202122232425262728293031&lt;script&gt;    window.onload = function () &#123;        获取canvas        let canvas = document.querySelector(#canvas)        canvas.width = 800        canvas.height = 800        let context = canvas.getContext(2d)        let arr = [red, blue, green, yellow]        context.lineWidth = 5     指定一条直线的宽度        for (let i = 0; i &lt; arr.length; i++) &#123;            let num = i*50            context.beginPath()            状态设置            context.moveTo(100+num, 100+num)            context.lineTo(500+num, 100+num)            context.lineTo(500+num, 400+num)            context.lineTo(100+num, 400+num)            context.lineTo(100+num, 100+num)            context.strokeStyle = #058   指定一条直线的样式            绘制            context.stroke()            context.fillStyle = arr[i]            context.fill()        &#125;    &#125;&lt;script&gt;\n效果图如下:\n\n3. strockeRect和fillRect可以直接使用strockeRect和fillRect来绘制矩形:\n​    1.strockeRect绘制空心矩形:\n123strockeRect(x,y,w,h)context.strokeRect(50,50,400,300)\n​    2.fillRect绘制填充矩形:\n123fillRect(x,y,w,h)context.fillRect(50,50,400,300)\n例:绘制有边框的实心矩形\n1234567891011121314151617181920212223&lt;script&gt;            获取canvas        let canvas = document.querySelector(#canvas)        canvas.width = 600        canvas.height = 600        let context = canvas.getContext(2d)        context.lineWidth = 5     指定一条直线的宽度                设置线段的样式        context.strokeStyle = #058\t\t设置填充的颜色        context.fillStyle = red\t\t\t\t绘制空心矩形        context.strokeRect(50,50,400,300)                绘制实心矩形        context.fillRect(50,50,400,300)    &lt;script&gt;\n效果图如下:\n\n2.2  绘制圆形1. arc( )语法:\n1context.arc(x, y, radius, startAngle, endAngle, anticlockwise)\n参数:\n​    (x,y)圆心坐标;\n​    radius圆形的半径;\n​    startAngle开始的角度;\n​    endAngle结束的角度;\n​    anticlockwise绘制方向,顺时针还是逆时针,true表示逆时针，false表示顺时针.(默认是顺时针)\n例1:\n123456789101112131415161718192021&lt;script&gt;        获取canvas        let canvas = document.querySelector(&apos;#canvas&apos;)        canvas.width = 600        canvas.height = 600        let context = canvas.getContext(&apos;2d&apos;)        context.lineWidth = 5        let deg = Math.PI  180                context.strokeStyle = &quot;#058&quot;        context.arc(200,200,100,0,360*deg,true)        context.stroke()\t\t绘制空心圆        context.beginPath()        context.fillStyle = &apos;red&apos;        context.arc(400,200,100,0,360*deg,true)        context.fill()\t\t\t绘制填充圆\t\t&lt;script&gt;\n效果图:\n\n2.3. 绘制文字俩种方式绘制文本:\n​    空心文本    和 填充文本\n1. strokeText( )strokeText(text, x, y [, maxWidth])\n在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.\n2. fillText( )fillText(text, x, y [, maxWidth])\n在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.\n例1:\n1234567891011121314151617181920&lt;script&gt;        获取canvas        let canvas = document.querySelector(&apos;#canvas&apos;)        canvas.width = 600        canvas.height = 600        let context = canvas.getContext(&apos;2d&apos;)        context.lineWidth = 5     指定一条直线的宽度        context.strokeStyle = &quot;#058&quot;        context.fillStyle = &apos;red&apos;                context.font = &quot;50px 黑体&quot;        context.fillText(&apos;李先生&apos;,50,100)        context.strokeText(&apos;王先生&apos;,50,150)\t      &lt;script&gt;\n效果图:\n\n2.4 阴影设置\n\n\nshadowColor\n阴影颜色\n\n\n\n\nshadowOffsetX\nX方向偏移量\n\n\nshadowOffsetY\nY方向偏移量\n\n\nclosePath()\n结束绘制,会从当前点回到结束点,形成一个封闭的图形\n\n\nshadowBlur\n设置阴影的模糊级别\n\n\n\n1234567context.shadowOffsetX = 10;context.shadowOffsetY = 10;context.shadowColor = red;context.shadowBlur = 40;context.fillRect(50,50,200,100);\n2.5 图形变换所有的变换都是针对整个画布的\n1. 平移\ntranslate(x,y)\n\n12345let context = canvas.getContext(&apos;2d&apos;)      context.translate(50,50)\t\t整个画布向右向下平移了50px      context.font = &quot;50px 黑体&quot;      context.strokeText(&apos;王先生&apos;,50,150)      context.fillText(&apos;李先生&apos;,50,100)\n例1:\n1234567cxt.fillStyle = &apos;red&apos;cxt.translate(100,100)cxt.fillRact(0, 0, 200, 200)cxt.fillStyle = &apos;green&apos;cxt.translate(200,200)cxt.fillRact(0, 0, 200, 200)\n\n当红色的方块平移了100x100之后,绘制绿色的方块的时候,也使用translate属性,此时是在100x100的基础上平移的200x200\n也就是说绿色实际平移的是300x300\n2.旋转\nrotate(deg)\n\n1234567891011121314151617&lt;script&gt;        获取canvas        let canvas = document.querySelector(#canvas)        canvas.width = 600        canvas.height = 600        let context = canvas.getContext(2d)        let deg = Math.PI  180        context.rotate(45*deg)                context.fillStyle = red        context.fillRect(150,0,100,100)                context.fillStyle = blue        context.fillRect(250,0,100,100)&lt;script&gt;\n3. 缩放\nscale(x, y)\n\n 我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。\n scale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩 小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。\n2.6 线条的属性1. lineCap线条的开头和结尾的样式\nbutt    (default)    默认无变化\nround    会突出一段圆头\nsquare    会突出一段方头\n2. lineJoin线条与线条相交时指定出来的形状\nmiter (default) 默认呈现尖角的形状\nbevel    斜接的形式\nround    圆角的形式\n12cxt.lineWidth = 10   cxt.lineJoin = round\n3. miterLimit只有在cxt.lineJoin = &#39;miter&#39;时才可以使用\n指的是线条相交出内角和外角直接距离的最大值\n当最大值超出了10px的时候,就会自动使用bevel,而不会有尖角的效果\n所以当俩个线条都很粗时并且相交角度很小不能呈现尖角时,可以增大miterLimit的值\n如: cxt.miterLimit = 20\n默认值为 10 (也就是10px)\n\n4. lineWidth设置线条的宽度\ncxt.lineWidth = 10\n第三章: 状态的保存和读取 save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。\n Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。\n123456789101112131415161718192021&lt;script&gt;        获取canvas        let canvas = document.querySelector(&apos;#canvas&apos;)        canvas.width = 600        canvas.height = 600        let context = canvas.getContext(&apos;2d&apos;)        context.lineWidth = 5        let deg = Math.PI  180\t\t保存当前画布的状态        context.save()\t\tsave()以上的状态                context.rotate(45*deg)        context.fillStyle = &apos;red&apos;        context.fillRect(100,0,50,50)        恢复(回到)之前的状态        context.restore()        context.fillStyle = &apos;yellow&apos;        context.fillRect(100,0,50,50)&lt;script&gt;\n效果图如下:\n\n可以看到黄色的矩形并没有和红色一样被旋转45度,而是使用在context.save()之前的状态.\n第四章: 贝塞尔曲线4.1 二次贝塞尔曲线quadraticCurveTo(cp1x, cp1y, x, y):\n说明：\n 参数1和2：控制点坐标\n 参数3和4：结束点坐标\n12345678let canvas = document.querySelector(#canvas)   let context = canvas.getContext(2d)   context.lineWidth = 10   context.beginPath()   context.moveTo(0,400)   2次贝塞尔曲线   context.quadraticCurveTo(300,300,400,0)\n4.2 三次贝塞尔曲线bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y):\n说明：\n 参数1和2：控制点1的坐标\n 参数3和4：控制点2的坐标\n 参数5和6：结束点的坐标\n123456789let canvas = document.querySelector(#canvas)   let context = canvas.getContext(2d)   context.lineWidth = 10   context.beginPath()   context.moveTo(0,400)   3次贝塞尔曲线   context.bezierCurveTo(300,-200,400,400,400,0)   context.stroke()\n第五章: 动画5.1 清空canvas\n再绘制每一帧动画之前，需要清空所有。清空所有最简单的做法就是clearRect()方法\n\n1234567let canvas = document.querySelector(#canvas)    let context = canvas.getContext(2d)    context.fillRect(50,50,100,100)    清除画布    context.clearRect(0,0,canvas.width,canvas.height)\n5.2 控制动画实际就是通过不停的情况画布,再绘制图形来达到动画的效果\n一般用到下面三个方法：\n\nsetInterval()\nsetTimeout()\nrequestAnimationFrame()\n\n例:制作一个向右下角来回运动的方块\n1234567891011121314151617181920212223&lt;script&gt;    let canvas = document.querySelector(#canvas)    let context = canvas.getContext(2d)    let x = 0    let y = 0    let speedX = 2    setInterval(function () &#123;    \t清空画布        context.clearRect(0,0,canvas.width,canvas.height)        x += speedX        y += speedX        if(x &gt; 350)&#123;            speedX *= -1        &#125;else if(x &lt;= 0)&#123;            speedX *= -1        &#125;\t\t绘制方块        context.fillRect(x,y,50,50)    &#125;,30)&lt;script&gt;\n","tags":["前端入门","canvas"],"path":"2016/03/08/webNotes/primary/JavaScript/Canvas/basicCanvas/","external_link":""},{"title":"canvas的重头戏--图片的处理","date":"2017-09-26T17:19:45.000Z","content":"##前文\n相信接触过一些canvas的小伙们都应该会有这样的一句感叹: canvas 强 真的强!不仅可以静态的创建一些我们用普通标签无法实现的图形,而且还能让这些图形动起来.\n其实在实际的开发中,要是你只会用canvas画一些矩形啊,三角形啊,五角星等等的东西肯定是不够的.因为真正在开发中,canvas大部分都是用来对图片以及视频做处理,所以博主今天在这里想要介绍的是一些关于canvas对图片的处理\n##1. 引用图片\n我们知道想在网页中显示一张图片,我们只需要用&lt;img src=&quot;&quot;&gt;就可以实现了,那么在canvas中我们是怎样插入一张图片的呢.\n1.首先在body中创建好一个canvas标签123&lt;body&gt;  &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;canvas&gt;&lt;body&gt;\n2.在js代码中获取canvas并创建一个元素123456&lt;script&gt;        let canvas = document.querySelector(&apos;#canvas&apos;)  获取canvas对象        let ctx = canvas.getContext(&apos;2d&apos;)             获取2d上下文        let img = new Image()                            创建img        img.src = &apos;imggreen.jpg&apos;                        给img添加资源&lt;script&gt;\n3.​ 绘制img,考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再 drawImage12345678910&lt;script&gt;        let canvas = document.querySelector(&apos;#canvas&apos;)        let ctx = canvas.getContext(&apos;2d&apos;)        let img = new Image()        img.src = &apos;imggreen.jpg&apos;        图片是否已经加载完成        img.onload = function () &#123;            ctx.drawImage(this, 100, 100, this.width  2, this.height  2)        &#125;    &lt;script&gt;\n通过上面的三个步骤,这时候打开你们的浏览器就可以在页面中看到对应的图片了.这里主要用到的是drawImage这个方法,下面是对其的一些详细讲解.\n2.解析drawImage( )对于drawImage()这个方法,有三种使用的方式:\n第一种:只传入3个参数\ndrawImage(image,x,y)\n参数1: image:  指的就是你的图片对象,  也就是你let img = new Image()中的img参数2 :  x  图片相对于画布原点(0,0)也就是画布的最左上角 的x轴方向的坐标参数3:  y  图片相对于画布原点(0,0)也就是画布的最左上角 的y轴方向的坐标\n第二种:传入5个参数\ndrawImage(image,x,y,width,height)\n前面三个参数和第一种的使用方式一样.\n参数4,5:   width  和  height可以规定图片的宽度和高度.如:在画布(100,100)的位置插入一张300*300的图片123img.onload = function () &#123;    ctx.drawImage(this, 100, 100, 300, 300)&#125;\n 那么利用width和height我们可以发现,想要将图片缩减为其原始大小的一半,就可以这样写:123img.onload = function () &#123;    ctx.drawImage(this,100,100,this.width  2, this.height  2)&#125;\n第三种:传入9个参数当在drawImage()中传入9个参数后,这个方法的用法将和前面俩种不一样了.\n它的用法是从图片中截取一定尺寸的图片,并drawImage(image,sourceX,sourceY,sourceWidth,sourceHeight,x,y,width,height)\n第三种的使用方式传递的是9个参数,\n参数1 : image还是图片的对象\n参数2,3 : 从一张大图上指定要截取小图的位置(x,y)坐标参数4,5:  从一张大图上指定要截取小图的大小参数6,7: 从一张大图上截取下来的小图要放在canvas(画布)中的位置(x,y)参数8,9:  截取下来小图规定的宽高\n如下图中,有5架小飞机,我只想截取最后一架并显示在画布中.\n![herofly.png\n整张图的宽度是330px,一架飞机就是66px,所以最后一张图就是从66 * 3 = 198px的位置开始截取,截取完后放在画布(0, 0)的位置123var img1 = new Image()img1.src = &apos;imgherofly.png&apos;drawImage(img1, 198, 0, 66,  82, 0, 0, 66, 82)\n3.canvas中的动画3.1 requestAnimationFrame的简介我们利用普通的定时器来实现动画的写法为:1234567891011121314var x = 0;function animate()&#123;  清除画布内容  ctx.clearRect(0, 0, canvas.width, canvas.height);  x += 2;  ctx.fillStyle = &quot;red&quot;;  ctx.fillRect(x, 0, 50, 50);  if (x &gt; 200)&#123;    return;  &#125;  setTimeout(animate,30);&#125;animate();\n可以看到上面的动画是靠setTimeout这个定时器每隔30毫秒调用一次animate() 来实现的.\n这种利用定时器来实现动画效果在移动端实际来说是很不可取的,在移动端上看到的动画会很卡顿,造成用户体验很不流程.所以ES6新增了一个类似于定时器的API:requestAnimationFrame()它只有一个参数,就是要执行的函数.\n使用requestAnimationFrame实现动画1234567891011121314var x = 0;function animate()&#123;  清除画布内容  ctx.clearRect(0, 0, canvas.width, canvas.height);  x += 2;  ctx.fillStyle = &quot;red&quot;;  ctx.fillRect(x, 0, 50, 50);  if (x &gt; 200)&#123;    return;  &#125;  requestAnimationFrame(animate);\t\t\t唯一不同&#125;animate();\n可以看到俩段代码的区别,仅仅是一个用的是setTimout,一个是requestAnimationFrame    \nsetTimout表示的是: 每隔30毫秒,执行一次animate()函数.而requestAnimationFrame    在一秒中执行多少次是由它的应用场景决定的,一般都能达到58~60次.也就是100060(相当于定时器16毫秒执行一次)\n那么这里得到的100060就是一帧.不同的场景帧数可能会不一样.\n3.2 canvas中切换图片的动画还是利用上面的那种飞机图.我现在想实现一个从第一架完整飞机变化到最后一架爆炸飞机的效果.\n那么有心的小伙就会发现了,在js中我们想实现图片的切换,只要改变背景图的background-position就可以了,那么在canvas中利用的就是requestAnimationFrame配合drawImage了.\n只要不停的改变截取图片的位置就可以了.我们来看下面的demo1:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;    &lt;title&gt;爆炸飞机切换&lt;title&gt;&lt;head&gt;&lt;body&gt;&lt;canvas id=&quot;canvas&quot;&gt;&lt;canvas&gt;&lt;script&gt;    let windowW = document.body.clientWidth    let windowH = document.body.clientHeight    let canvas = document.querySelector(&apos;#canvas&apos;)    canvas.width = windowW    canvas.height = windowH    let ctx = canvas.getContext(&apos;2d&apos;)    let frame = 0       帧数    let img1 = new Image()    img1.src = &apos;imgherofly.png&apos;    定义变量:图片截取的位置(x,y) 图片截取的宽高(w,h) 整张大图的宽度, 截取的飞机在canvas中的位置(iX, iY)    let x = 0, y = 0, w = 66, h = 82, img1W = 330, iX = 0, iY = 0;    animate()    function animate() &#123;        定义一个帧数的变量,函数每一帧执行一次,则frame就加一次,以此记录帧数        frame++        ctx.clearRect(0, 0, canvas.width, canvas.height)        每过20帧执行一次 x += w 以此达到切换图片的效果        if(frame % 20 === 0 ) &#123;            x += w            if (x &gt;= img1W - w) &#123;   判定当走到最后一张爆炸图的时候,让x又等于0, 达到无限动画的效果                x = 0            &#125;        &#125;        每隔一帧就执行绘画飞机的操作        ctx.drawImage(img1, x, y, w, h, iX, iY, w, h)        为避免frame加到太大,在这里做一个当frame加到10000时,又让它为0的操作        if(frame &gt; 10000 ) &#123;            frame = 0        &#125;        利用requestAnimationFrame达到动画效果        requestAnimationFrame(animate)    &#125;&lt;script&gt;&lt;body&gt;&lt;html&gt;\n3.3 canvas中图片运动的动画上面我们介绍的是在一张大图中,持续改变它截取图片的位置(也就是x, y ),来达到切换图片的效果.这种转化有些类似于”静态的转化”.\n那么怎样让图片在canvas中移动呢,改变的就是我们drawImage()中的第6,7个参数(也就是截取下来的图片在canvas中的位置)\n还是利用demo1中的那张飞机图,只不过这次我不让它”爆炸”了(不进行图片切换),而是让它从canvas的最下边飞到最上边\n来看demo2:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;    &lt;title&gt;爆炸飞机切换&lt;title&gt;&lt;head&gt;&lt;body&gt;&lt;canvas id=&quot;canvas&quot;&gt;&lt;canvas&gt;&lt;script&gt;    let windowW = document.body.clientWidth    let windowH = document.body.clientHeight    let canvas = document.querySelector(&apos;#canvas&apos;)    canvas.width = windowW    canvas.height = windowH    let ctx = canvas.getContext(&apos;2d&apos;)    let frame = 0       帧数    let img1 = new Image()    img1.src = &apos;imgherofly.png&apos;    定义变量:图片截取的位置(x,y) 图片截取的宽高(w,h) 整张大图的宽度, 截取的飞机在canvas中的位置(iX, iY)    let x = 0, y = 0, w = 66, h = 82, img1W = 330, iX = 0, iY = canvas.height - h;    animate()    function animate() &#123;        定义一个帧数的变量,函数每一帧执行一次,则frame就加一次,以此记录帧数        frame++        ctx.clearRect(0, 0, canvas.width, canvas.height)        每过20帧执行一次 iY -= 4 以此达到图片运动的效果        if(frame % 20 === 0 ) &#123;            iY -= 4            if (iY &lt;= 0) &#123;   判定当飞机运动到最上边的时候,让iY又等于画布的高 - 飞机的高, 达到无限动画的效果                iY = canvas.height - h            &#125;        &#125;        每隔一帧就执行绘画飞机的操作        ctx.drawImage(img1, x, y, w, h, iX, iY, w, h)        为避免frame加到太大,在这里做一个当frame加到10000时,又让它为0的操作        if(frame &gt; 10000 ) &#123;            frame = 0        &#125;        利用requestAnimationFrame达到动画效果        requestAnimationFrame(animate)    &#125;&lt;script&gt;&lt;body&gt;&lt;html&gt;\n可以看到上面的demo2 和 demo1 大致相同,只不过此时改变的是iY而已.\n3.4 canvas中的视频在页面中,插入一段视频,只需要使用标签\n而在canvas中我们只需要将视频当图片一样插入,在利用canvas中的动画让它达到播放的效果.\n例1:123456789101112131415161718&lt;body&gt;&lt;div class=&quot;out&quot;&gt;    &lt;video id=&quot;video1&quot; src=&quot;imgxiaoyin.mp4&quot; style=&quot;width:300px;&quot; autoplay&gt;&lt;video&gt;    &lt;canvas id=&quot;myCanvas&quot; width=&quot;1000&quot; height=&quot;300&quot;&gt;&lt;canvas&gt;&lt;div&gt;&lt;script&gt;    let canvas = document.querySelector(&quot;#myCanvas&quot;)    let ctx = canvas.getContext(&quot;2d&quot;)    let imgObj = document.querySelector(&apos;#video1&apos;)    function play()&#123;        ctx.drawImage(imgObj, 0, 0,canvas.width,canvas.height)        window.requestAnimationFrame(play);    &#125;    play()&lt;script&gt;&lt;body&gt;\n此时页面中出现的应该是俩个视频,并且用canvas绘制出来的视频并不会卡顿,效果和直接用video的一样,要是你想只显示canvas的视频的话,可以将video1给display:none掉.效果图:\n\n3.5 灰色视频在介绍讲解灰色视频之前,我想先介绍一个很牛x的方法getImageData(),这个方法能获取整张图片,或者一片图片区域的所有信息.用法为:12ctx.drawImage(imgObj, 0, 0,canvas.width,canvas.height)var imageData = ctx.getImageData(0,0, canvas.width, canvas.height);\n来看下面这个小例子,点击按钮生成,将左侧彩色的图片变为灰色:\n\n点击生成:\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt;&lt;div class=&quot;out&quot;&gt;    &lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;400&quot;&gt;&lt;canvas&gt;    &lt;img id=&quot;PutImg&quot; src=&quot;&quot; alt=&quot;&quot;&gt;    &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;生成&quot;&gt;&lt;div&gt;&lt;script&gt;    let out = document.querySelector(&apos;.out&apos;)    let btn = document.querySelector(&apos;#btn&apos;)    let PutImg = document.querySelector(&apos;#PutImg&apos;)    let canvas = document.querySelector(&apos;#canvas&apos;)    let ctx = canvas.getContext(&apos;2d&apos;)    let img = new Image()    img.src = &apos;img01.jpg&apos;    img.onload=function () &#123;        ctx.drawImage(img,0,0,canvas.width,canvas.height)        btn.onclick = function () &#123;            var imageData = ctx.getImageData(0,0, canvas.width, canvas.height);            console.log(imageData);            var pixels = imageData.data;            遍历像素点            for (var i=0; i&lt;pixels.length; i+=4)&#123;                var r = pixels[i];                var g = pixels[i+1];                var b = pixels[i+2];                获取灰色                var gray = parseInt((r+g+b)3);                pixels[i] = gray;                pixels[i+1] = gray;                pixels[i+2] = gray;            &#125;            ctx.putImageData(imageData, 0,0);            let url = canvas.toDataURL()            PutImg.src = url            ctx.clearRect(0,0,canvas.width,canvas.height)        &#125;    &#125;&lt;script&gt;&lt;body&gt;\n我们可以将上面获取到的imageData对象打印出来看下:\n\n这个imageData对象中有3个属性,分别是data,高度,宽度那么这个data可以看出是一个数组,而且是一个长度为480000的数组那么这个数组是怎么来的呢.其实这个数组存储的是所有像素点的颜色信息你可以理解为,我的这张图片是300x400像素的,也就是有120000个像素点,而一个像素点的颜色(也就是rgba) 是由个值组成的,分别是r,g,b,a的值也就是说数组中每4个值代表的就是一个像素点的信息.如前4个值[134,134,134,225] 表示的就是第一个像素点(最左上角的)的信息.所以在做灰色处理时,我们只需要将每个像素点的前三个值全部一样的就可以了,然后在利用putImageData()方法来输出一下处理好的图片.\n而视频的处理也是一样的在例1的基础上加以改进:\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;&lt;div class=&quot;out&quot;&gt;    &lt;video id=&quot;video1&quot; src=&quot;imgxiaoyin.mp4&quot; style=&quot;width:300px;&quot; autoplay&gt;&lt;video&gt;    &lt;canvas id=&quot;myCanvas&quot; width=&quot;1000&quot; height=&quot;300&quot;&gt;&lt;canvas&gt;&lt;div&gt;&lt;script&gt;    let canvas = document.querySelector(&quot;#myCanvas&quot;)    let ctx = canvas.getContext(&quot;2d&quot;)    let imgObj = document.querySelector(&apos;#video1&apos;)    function play()&#123;        ctx.drawImage(imgObj, 0, 0,canvas.width,canvas.height)        var imageData = ctx.getImageData(0,0, canvas.width, canvas.height);               var pixels = imageData.data;        遍历像素点        for (var i=0; i&lt;pixels.length; i+=4)&#123;            var r = pixels[i];            var g = pixels[i+1];            var b = pixels[i+2];            获取灰色            var gray = parseInt((r+g+b)3);            pixels[i] = gray;            pixels[i+1] = gray;            pixels[i+2] = gray;        &#125;        ctx.putImageData(imageData, 0,0);        window.requestAnimationFrame(play);    &#125;    play()&lt;script&gt;&lt;body&gt;\n此时我们的视频就变成灰色的了效果图:\n\n","tags":["前端入门","canvas"],"path":"2017/09/27/webNotes/primary/JavaScript/Canvas/canvasOfImg/","external_link":""},{"title":"Angular基础","date":"2017-12-21T08:57:45.000Z","content":"第一章：安装配置设置开发环境node.js和npm\n全局安装Angular CLI1npm install -g @angularcli\n创建项目1ng new my-app\n启动项目12cd my-appng serve --open\nng serve命令会启动开发服务器，监听文件变化，并在修改这些文件时重新构建此应用。\n使用--open（或-o）参数可以自动打开浏览器并访问http:localhost:4200。\n注：可以设置为cnpm\n1ng set --global packageManager=cnpm\n第二章：常用指令2.1 属性绑定1234567891011121314151617&lt;img [src]=&quot;heroImageUrl&quot;&gt;&lt;img bind-src=&quot;heroImageUrl&quot;&gt;&lt;img src=&quot;&#123;&#123;heroImageUrl&#125;&#125;&quot;&gt;heroImageUrl = &apos;..assetsimageimg1.png&apos;;&lt;button [disabled]=&quot;isUnchanged&quot;&gt;Cancel is disabled&lt;button&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot;  [disabled]=&quot;true&quot;&gt;isUnchanged = true;&lt;p&gt;&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;span&gt;&lt;p&gt;&lt;p&gt;&quot;&lt;span [innerHTML]=&quot;title&quot;&gt;&lt;span&gt;&lt;p&gt;title = &apos;标题&apos;\n2.2 类名绑定添加或删除单个类\n1234 设置单个class名,通过isSpecial判断是否添加special这个类名&lt;div [class.special]=isSpecial&gt;The class binding is special&lt;div&gt;&lt;!--isSpecial = true--&gt;\n当想要同时添加或移除多个 CSS 类时，NgClass指令可能是更好的选择。\n试试把ngClass绑定到一个 key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是true，这个类就会被加上，否则就会被移除。\n组件方法setCurrentClasses可以把组件的属性currentClasses设置为一个对象，它将会根据三个其它组件的状态为true或false而添加或移除三个类。\n123456789101112&lt;div [ngClass]=&quot;currentClasses&quot;&gt;This div is initially saveable, unchanged, and special&lt;div&gt;currentClasses: &#123;&#125;;setCurrentClasses() &#123;   CSS classes: addedremoved per current state of component properties  this.currentClasses =  &#123;    &apos;saveable&apos;: this.canSave,    &apos;modified&apos;: !this.isUnchanged,    &apos;special&apos;:  this.isSpecial  &#125;;&#125;\n2.3 style绑定设置单一样式：\n123456&lt;button [style.color]=&quot;isSpecial ? &apos;red&apos;: &apos;green&apos;&quot;&gt;Red&lt;button&gt;&lt;button [style.background-color]=&quot;canSave ? &apos;cyan&apos;: &apos;grey&apos;&quot; &gt;Save&lt;button&gt;&lt;button [style.margin-left.px]=&quot;isSpecial ? 10 : 20&quot; &gt;Big&lt;button&gt;&lt;button [style.font-size.em]=&quot;isSpecial ? 3 : 1&quot; &gt;Big&lt;button&gt;&lt;button [style.font-size.%]=&quot;!isSpecial ? 150 : 50&quot; &gt;Small&lt;button&gt;\n设置多个内联样式：\n1234567891011121314&lt;div [ngStyle]=&quot;currentStyles&quot;&gt;  This div is initially italic, normal weight, and extra large (24px).&lt;div&gt;currentStyles: &#123;&#125;;setCurrentStyles() &#123;   CSS styles: set per current state of component properties  this.currentStyles = &#123;    &apos;font-style&apos;:  this.canSave      ? &apos;italic&apos; : &apos;normal&apos;,    &apos;font-weight&apos;: !this.isUnchanged ? &apos;bold&apos;   : &apos;normal&apos;,    &apos;font-size&apos;:   this.isSpecial    ? &apos;24px&apos;   : &apos;12px&apos;  &#125;;&#125;\n2.4 事件绑定目标事件123&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;button&gt;&lt;button on-click=&quot;onSave()&quot;&gt;On Save&lt;button&gt;\n$event 和事件处理语句通过$event获取事件对象\n1234567&lt;input type=text [value]=inputVal        (input) = inputVal=$event.target.value&gt;`        &lt;!-- 和双项绑定一样 --&gt;        &lt;input type=text [(ngModel)]=inputVal&gt;  &lt;p&gt;&#123;&#123;inputVal&#125;&#125;&lt;p&gt;\n1. 双项绑定[(ngModel)]=&quot;&quot;\n虽然NgModel是一个有效的Angular指令，但它默认情况下却是不可用的。 它属于一个可选模块FormsModule。 我们必须选择使用那个模块。\n导入 FormsModule\n打开app.module.ts文件，并且从@angularforms库中导入符号FormsModule。 然后把FormsModule添加到@NgModule元数据的imports数组中，它是当前应用正在使用的外部模块列表。\n修改后的AppModule是这样的：\n1234567891011121314151617import &#123; NgModule &#125;      from @angularcore;import &#123; BrowserModule &#125; from @angularplatform-browser;import &#123; FormsModule &#125;   from @angularforms;   NgModel lives here import &#123; AppComponent &#125;  from .app.component; @NgModule(&#123;  imports: [    BrowserModule,    FormsModule   import the FormsModule before binding with [(ngModel)]  ],  declarations: [    AppComponent  ],  bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125;\n使用：\n1&lt;input type=&quot;text&quot; [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt;\n2.遍历1&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;\n第三章：父子组件父组件app.component.ts\n子组件hero-detail.components.ts\n在创建子组件之前，先在src下创建一个hero.ts，其中存放着一个hero类,这个类会被多个组件引用\n1234export class Hero &#123;    id: number;    name: string;  &#125;\n之后，在其他的组件中要引用这个公共的类，只需要使用\n1import &#123; Hero &#125; from &apos;.hero&apos;;\t 引入Hero\n引入即可。\n3.1 创建子组件每一个组件，都必须引入Component来表明它是一个组件    \n在src下创建文件夹hero-detail\n并在其中依次创建hero-detailcomponent.tscomponent.htmlcomponent.css三个文件\nhero-detail.component.ts\n12345678910import &#123; Component, Input &#125; from @angularcore;\t 引入Componens 和 Inputimport &#123; Hero &#125; from ..hero;\t 引入Hero@Component(&#123;    selector: hero-detail,\t 确定子组件引用时的标签名    templateUrl: .hero-detail.component.html,\t 子组件的HTML代码    styleUrls: [.hero-detail.component.css]\t\t 子组件的样式&#125;)export class HeroDetailComponent &#123;\t\t 导出子组件    @Input() hero: Hero;\t\t\t 1.通过在hero属性前面加上@Input装饰器，来表明它是一个输入属性 &#125;\nhero-detail.component.html\n123456789&lt;div *ngIf=hero&gt;\t 2.引用父组件传递进来的属性    &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;h2&gt;    &lt;div&gt;        &lt;label&gt;id: &lt;label&gt;&#123;&#123;hero.id&#125;&#125;&lt;div&gt;    &lt;div&gt;        &lt;label&gt;name: &lt;label&gt;        &lt;input [(ngModel)]=hero.name placeholder=name &gt;    &lt;div&gt;&lt;div&gt;\n3.2 在父组件中引用子组件1.在AppModule中声明HeroDetailComponent\n每个组件都必须在一个（且只有一个）Angular模块中声明。\n打开app.module.ts并且导入HeroDetailComponent，以便我们可以引用它。\n123456789import &#123; HeroDetailComponent &#125; from .hero-detailhero-detail.component;  引入@NgModule(&#123;  declarations: [    AppComponent,    HeroDetailComponent\t 引入  ],&#125;)export class AppModule &#123; &#125;\n2.在父组件html中引用\n12345678&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;h1&gt;&lt;h2&gt;My Heroes&lt;h2&gt;&lt;ul class=heroes&gt;  &lt;li *ngFor=let hero of heroes [class.selected]=hero === selectedHero (click)=onSelect(hero)&gt;    &lt;span class=badge&gt;&#123;&#123;hero.id&#125;&#125;&lt;span&gt; &#123;&#123;hero.name&#125;&#125;  &lt;li&gt;&lt;ul&gt;&lt;hero-detail [hero]=selectedHero&gt;&lt;hero-detail&gt;  通过[]向子组件传递值,子组件那边用@Input接收\n3.3 @ViewChild\n有些时候，在父组件中你可能需要用到子组件中的属性或者方法，此时你可以使用@ViewChild\n\nchild.component.ts\n123456789101112@Component(&#123;  selector: app-child,  template: &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;p&gt;&lt;div&gt;&lt;input value=xixi&gt;&lt;div&gt;,  styleUrls: [.child.component.css]&#125;)export class ChildComponent implements OnInit &#123;  public name: string = childName;  greeting(name: string) &#123;    console.log(hello  + name);  &#125;&#125;\nfather.component.ts\n12345678910111213import &#123; ChildComponent &#125; form .childChildComponent;@Component(&#123;  selector: app-root,  template: &lt;app-child #child&gt;&lt;app-child&gt;&#125;)export class AppComponent implements OnInit &#123;  @ViewChild(child)child: ChildComponent;  clickMe() &#123;  \tthis.child.greeting(father);  &#125;&#125;\n第四章：服务1.创建服务服务其实也是一个ts文件，只不过创建这个文件命名时要加上service来表明它是一个服务\n1.如创建一个名为hero的服务\n1hero.service.ts\n12345import &#123; Injectable &#125; from @angularcore;\t 引入Injectable, 就像组件引用Component一样@Injectable()export class HeroService &#123;&#125;\n此时创建了一个hero的服务，但是里面什么东西也没有\n2.给服务中添加东西可以给服务中添加一个方法，这个方法用来获取一个heros数组\n首先创建一个mock-heroes.ts来存放数组\n123456789101112131415import &#123; Hero &#125; from .hero;export const HEROES: Hero[] = [\t\t 表明数组中的每一个对象都是Hero这个类，并输出这个数组    &#123; id: 11, name: Mr. Nice &#125;,    &#123; id: 12, name: Narco &#125;,    &#123; id: 13, name: Bombasto &#125;,    &#123; id: 14, name: Celeritas &#125;,    &#123; id: 15, name: Magneta &#125;,    &#123; id: 16, name: RubberMan &#125;,    &#123; id: 17, name: Dynama &#125;,    &#123; id: 18, name: Dr IQ &#125;,    &#123; id: 19, name: Magma &#125;,    &#123; id: 20, name: Tornado &#125;  ];export let NUM: number = 1\t 也可以输出多个变量(或常量),如再输出一个NUM的变量\n然后在服务中引用它，并设定一个方法\n123456789101112131415import &#123; Injectable &#125; from @angularcore;import &#123; Hero &#125; from .hero;import &#123; HEROES &#125; from .mock-heroes;\t 接收mock-heroes中的数组import &#123; NUM &#125; from .mock-heroes;\t 接收mock-heroes中的变量NUM@Injectable()export class HeroService &#123;  getHeroes(): Hero[] &#123;    return HEROES;  &#125;  getNum(): number &#123;    return NUM;  &#125;&#125;\n3.使用服务如在app.component这个组件中要引用这个服务：\napp.component.ts：\n1234567891011121314151617181920212223...import &#123; HeroService &#125; from .hero.service;\t 1. 引入服务...@Component(&#123;  ...  providers: [HeroService];\t 2. 在@Component组件的元数据底部添加providers数组属性&#125;)export class AppComponent&#123;  title = Tour of Heroes;  heroes: Hero[];   selectedHero: Hero;  num: number;  constructor(private heroService: HeroService) &#123;&#125;;  3. 添加构造函数  getHeroes ():void &#123;\t    this.heroes =this.heroService.getHeroes();  4. 使用服务中的方法,将获取过来的数组赋值给app中的  &#125;;  getNum ():void &#123;\t\t    this.num =this.heroService.getNum();  4. 使用服务中的方法,将获取过来的NUM赋值给app中的num  &#125;  ...&#125;\n经过上面几部，我们实现了引用服务，并且可以使用服务中的方法。\n但是我们想要页面一打开就执行getHeroes()这个方法，可以参考生命周期\n4. 异步服务与承诺上面我们的服务使用的是同步的方法来获取数据，可以结合Promise来异步获取数据\n服务中的getHeroes方法\n同步的写法：\n123getHeroes(): Hero[] &#123;  return HEROES;&#125;\n异步的写法：\n123getHeroes(): Promise&lt;Hero[]&gt; &#123;  return Promise.resolve(HEROES);  异步返回的是一个promise对象&#125;\n此时也要修改引用服务的地方，如上面的app.component.ts\n1234567891011121314151617181920212223...import &#123; HeroService &#125; from .hero.service;\t 1. 引入服务...@Component(&#123;  ...  providers: [HeroService];\t 2. 在@Component组件的元数据底部添加providers数组属性&#125;)export class AppComponent&#123;  title = Tour of Heroes;  heroes: Hero[];   selectedHero: Hero;  num: number;  constructor(private heroService: HeroService) &#123;&#125;;  3. 添加构造函数  getHeroes ():void &#123;    this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);  采用promise的写法  &#125;;  getNum ():void &#123;    this.num =this.heroService.getNum();  采用同步的写法  &#125;  ...&#125;\n第五章： 生命周期在上面，我们虽然引用了自定义的服务，但是它并没有被调用，可以添加生命周期，让它在适当的时候调用。\n生命周期的顺序\n当Angular使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法：\n\n\n\n钩子\n目的和时机\n\n\n\n\nngOnChanges()\n当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。\n\n\nngOnInit()\n在Angular第一次显示数据绑定和设置指令组件的输入属性之后，初始化指令组件。在第一轮ngOnChanges()完成之后调用，只调用一次。\n\n\nngDoCheck()\n检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。\n\n\nngAfterContentInit()\n当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次。只适用于组件。\n\n\nngAfterContentChecked()\n每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit()和每次ngDoCheck()之后调用只适合组件。\n\n\nngAfterViewInit()\n初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。\n\n\nngAfterViewChecked()\n每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。\n\n\nngOnDestroy\n当Angular每次销毁指令组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令组件之前调用。\n\n\n\n在上面的例子中，我们就可以在ngOnInit()中使用服务的方法\n使用生命周期钩子123456789import &#123; Component, OnInit &#125; from @angularcore;  1. 引入生命周期钩子export class AppComponent implements OnInit&#123;\t 2. 往export语句中添加OnInit接口的实现：\tngOnInit(): void &#123;\t\t 3. 初始化逻辑的ngOnInt()方法      this.getHeroes();    &#125;&#125;\n此时我们的案例变成了：\napp.component.ts\n12345678910111213141516171819202122232425262728293031323334import &#123; Component, OnInit &#125; from @angularcore;import &#123; Hero &#125; from .hero;import &#123; HeroService &#125; from .hero.service;@Component(&#123;  selector: app-root,  templateUrl: .app.component.html,  styleUrls: [.app.component.css],  providers: [HeroService]&#125;)export class AppComponent implements OnInit&#123;  title = Tour of Heroes;  heroes: Hero[];  selectedHero: Hero;  num: number;  constructor(private heroService: HeroService) &#123;&#125;;  getHeroes ():void &#123;    this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);  &#125;;  getNum ():void &#123;    this.num =this.heroService.getNum()  &#125;  ngOnInit(): void &#123;    this.getHeroes();    this.getNum();  &#125;  onSelect(hero: Hero):void &#123;    this.selectedHero = hero;  &#125;&#125;\n第六章： 路由1. 配置路由1.在app.module.ts中引用\n12345678910111213141516171819202122232425262728293031...import &#123; RouterModule &#125;   from @angularrouter;\t 1. 引入router...import &#123; AppComponent &#125; from .app.component;import &#123; HeroesComponent &#125;     from .heroes.component;\t 2. 引入要路由的组件import &#123; DashboardComponent &#125; from .dashboard.component;  2. 引入要路由的组件@NgModule(&#123;  declarations: [\t\t\t 3. 引入要路由的组件    AppComponent,    HeroesComponent,    DashboardComponent  ],  imports: [    BrowserModule,    FormsModule,    RouterModule.forRoot([\t 4. 添加到AppModule的imports数组中      &#123;        path: heroes,        component: HeroesComponent      &#125;,      &#123;        path: dashboard,        component: DashboardComponent      &#125;,    ])  ],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\n2. 使用路由2.在app.component.html中使用\n123456&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;h1&gt;&lt;nav&gt;  &lt;a routerLink=&quot;dashboard&quot;&gt;Dashboard&lt;a&gt;  &lt;a routerLink=&quot;heroes&quot;&gt;Heroes&lt;a&gt;&lt;nav&gt;&lt;router-outlet&gt;&lt;router-outlet&gt;\n3. 路由重定向在配置路由路径的时候\n当路径是空的时候自动重定向到dashboard\n12345&#123;  path: &apos;&apos;,  redirectTo: &apos;dashboard&apos;,  pathMatch: &apos;full&apos;&#125;\n4. 参数化路由添加一个组件，用来显示英雄的详细信息，通过给路由中传递参数来跳转到对应的英雄\n1.配置参数路由\n12345678910111213141516171819202122232425262728293031323334353637383940import &#123; BrowserModule &#125; from @angularplatform-browser;import &#123; NgModule &#125; from @angularcore;import &#123; FormsModule &#125; from @angularforms; import &#123; RouterModule &#125;   from @angularrouter;\t 1. import &#123; AppComponent &#125; from .app.component;import &#123; HeroDetailComponent &#125; from .hero-detailhero-detail.component;  2.import &#123; HeroesComponent &#125;     from .heroes.component;import &#123; HeroService &#125;         from .hero.service;import &#123; DashboardComponent &#125; from .dashboard.component;@NgModule(&#123;  declarations: [    AppComponent,    HeroDetailComponent,\t 3.    HeroesComponent,    DashboardComponent  ],  imports: [    BrowserModule,    FormsModule,    RouterModule.forRoot([      &#123;        path: heroes,        component: HeroesComponent      &#125;,      &#123;        path: dashboard,        component: DashboardComponent      &#125;,      &#123;        path: detail:id,\t\t\t4.        component: HeroDetailComponent      &#125;    ])  ],  providers: [HeroService],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\n2.使用参数路由\ndashboard是app下的一个路由\n路径为localhost:4200dashboard\n该组件只显示前4个英雄，当点击英雄，跳转到英雄详情页\ndashboard.component.html:\n1234&lt;h3&gt;Top Heroes&lt;h3&gt;&lt;div class=&quot;grid grid-pad&quot;&gt;  &lt;a *ngFor=&quot;let hero of heroes&quot; [routerLink] = &quot;[&apos;detail&apos;, hero.id]&quot; class=&quot;col-1-4&quot;&gt;&#123;&#123;hero.name&#125;&#125;&lt;a&gt;&lt;div&gt;\ndashboard.component.ts:\n1234567891011121314151617181920import &#123; Component, OnInit &#125; from @angularcore;import &#123; Hero &#125; from .hero;import &#123; HeroService &#125; from .hero.service;@Component(&#123;  selector: my-dashboard,  templateUrl: .dashboard.component.html,  styleUrls: [.dashboard.component.css]&#125;)export class DashboardComponent implements OnInit&#123;  heroes: Hero[] = [];  constructor(private heroService: HeroService) &#123;&#125;  ngOnInit(): void &#123;    this.heroService.getHeroes()      .then(heroes =&gt; this.heroes = heroes.slice(1, 5));  &#125; &#125;\n这一步是引入heroesService这个自定义的服务，来获取英雄列表，详情请看《第四章： 服务》\n3.英雄详情页\nhero-detail.component.html\n12345678910&lt;div *ngIf=&quot;hero&quot;&gt;    &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;h2&gt;    &lt;div&gt;        &lt;label&gt;id: &lt;label&gt;&#123;&#123;hero.id&#125;&#125;&lt;div&gt;    &lt;div&gt;        &lt;label&gt;name: &lt;label&gt;        &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; &gt;    &lt;div&gt;    &lt;button (click)=&quot;goBack()&quot;&gt;Back&lt;button&gt;&lt;div&gt;\nhero-detail.component.ts\n12345678910111213141516171819202122232425262728293031import &#123; Component, Input, OnInit &#125; from @angularcore;import &#123; ActivatedRoute, ParamMap &#125; from @angularrouter;\t\t 1.import &#123; Location &#125; from @angularcommon;\t\t\t\t 2.import rxjsaddoperatorswitchMap;\t\t\t 3.import &#123; Hero &#125; from ..hero;import &#123; HeroService &#125; from ..hero.service;@Component(&#123;    selector: hero-detail,    templateUrl: .hero-detail.component.html,    styleUrls: [.hero-detail.component.css]&#125;)export class HeroDetailComponent implements OnInit&#123;    hero: Hero;    constructor(        private heroService: HeroService,        private route: ActivatedRoute,\t\t\t 4.        private location: Location\t\t\t\t 5.    ) &#123;&#125;    ngOnInit(): void &#123;        this.route.paramMap\t\t\t\t\t\t 6.            .switchMap((params: ParamMap) =&gt; this.heroService.getHero(+params.get(id)))            .subscribe(hero =&gt; this.hero = hero);    &#125;    goBack(): void &#123;        this.location.back();\t\t\t\t 7. 返回上一层      &#125;    providers: [HeroService]&#125;\n4.配置自定义服务heroService中的getHero()方法：\n12345678910111213141516171819202122232425262728import &#123; Injectable &#125; from @angularcore;import &#123; Hero &#125; from .hero;import &#123; HEROES &#125; from .mock-heroes;import &#123; NUM &#125; from .mock-heroes;@Injectable()export class HeroService &#123;   获取全部英雄  getHeroes(): Promise&lt;Hero[]&gt; &#123;    return Promise.resolve(HEROES);  &#125;   获取数字  getNum(): number &#123;    return NUM  &#125;   延迟获取全部英雄  getHeroesSlowly(): Promise&lt;Hero[]&gt; &#123;    return new Promise(resolve =&gt; &#123;       Simulate server latency with 2 second delay      setTimeout(() =&gt; resolve(this.getHeroes()), 2000);    &#125;);  &#125;   获取指定的英雄  getHero(id: number): Promise&lt;Hero&gt; &#123;    return this.getHeroes()               .then(heroes =&gt; heroes.find(hero =&gt; hero.id === id));  &#125;&#125;\n此时点击英雄列表的一个英雄，跳转到详情页\n1http:localhost:4200detail12\n5. js进行路由跳转上面我们实现的路由跳转是通过[routerLink] = &quot;[&#39;detail&#39;, hero.id]&quot;来进行路由跳转的，但如果想要给一个按钮添加点击事件进行跳转，怎么办呢？可以调用路由器的navigate()方法：\n如在heroes.component.html中添加一个按钮：\n123456&lt;div *ngIf=&quot;selectedHero&quot;&gt;  &lt;h2&gt;    &#123;&#123;selectedHero.name | uppercase&#125;&#125; is my hero  &lt;h2&gt;  &lt;button (click)=&quot;gotoDatail()&quot;&gt;View Details&lt;button&gt;  添加点击事件&lt;div&gt;\n在heroes.component.ts中：\n123456789101112131415161718192021import &#123; Component, OnInit &#125; from @angularcore;import &#123; Router &#125; from @angularrouter;\t 1. 引入路由import &#123; Hero &#125; from .hero;import &#123; HeroService &#125; from .hero.service;@Component(&#123;  selector: my-heroes,  templateUrl: .heroes.component.html,  styleUrls: [.heroes.component.css],&#125;)export class HeroesComponent implements OnInit&#123;...  constructor(    private heroService: HeroService,    private router: Router\t\t\t\t 2.   ) &#123;&#125;;...\t  gotoDatail():void &#123;\t\t\t\t\t 3. 调用router中的navigate()    this.router.navigate([detail, this.selectedHero.id]);  &#125;&#125;\n若是跳转无参数的路由，也是可以的：\n123gotoDatail():void &#123;  this.router.navigate([dashboard]);&#125;\n6. 重构路由为一个路由模板可以将路由重新定义为一个模块，在app.module.ts中引用\napp-routing.module.ts\n12345678910111213141516171819import &#123; NgModule &#125;             from @angularcore;import &#123; RouterModule, Routes &#125; from @angularrouter; import &#123; DashboardComponent &#125;   from .dashboard.component;import &#123; HeroesComponent &#125;      from .heroes.component;import &#123; HeroDetailComponent &#125;  from .hero-detailhero-detail.component; const routes: Routes = [  &#123; path: , redirectTo: dashboard, pathMatch: full &#125;,  &#123; path: dashboard,  component: DashboardComponent &#125;,  &#123; path: detail:id, component: HeroDetailComponent &#125;,  &#123; path: heroes,     component: HeroesComponent &#125;]; @NgModule(&#123;  imports: [ RouterModule.forRoot(routes) ],  exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125;\n而此时app.module.ts中要进行修改：\n12345678910111213141516171819202122232425262728import &#123; BrowserModule &#125; from @angularplatform-browser;import &#123; NgModule &#125; from @angularcore;import &#123; FormsModule &#125; from @angularforms;import &#123; AppComponent &#125; from .app.component;import &#123; HeroDetailComponent &#125; from .hero-detailhero-detail.component;import &#123; HeroesComponent &#125;     from .heroes.component;import &#123; HeroService &#125;         from .hero.service;import &#123; DashboardComponent &#125; from .dashboard.component;import &#123; AppRoutingModule &#125;     from .app-routing.modle; \t 1.@NgModule(&#123;  declarations: [    AppComponent,    HeroDetailComponent,    HeroesComponent,    DashboardComponent  ],  imports: [    BrowserModule,    FormsModule,    AppRoutingModule\t\t 2.  ],  providers: [HeroService],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\n第七章： 管道7.1 使用管道如：\n123456789101112import &#123; Component &#125; from @angularcore;@Component(&#123;  selector: app-hero-birthday,  template: &lt;p&gt;&#123;&#123; birthday &#125;&#125;&lt;p&gt;&#125;)export class HeroBirthdayComponent &#123;  birthday = new Date(1988, 3, 15); &#125; 不使用管道时，显示： Fri Apr 15 1988 00:00:00 GMT+0800 (中国标准时间)\n使用管道后：\n12&lt;p&gt;&#123;&#123; birthday | date &#125;&#125;&lt;p&gt; Apr 15, 1988\n7.2 参数化管道上面的案例中，使用的是data管道，来进行时间转换，有其默认的转换格式，我们也可以自定义转换格式，只需要像data管道中传递参数就可以了。\n比如我们想要上面的信息转换为19980315的格式\n1&lt;p&gt;&#123;&#123; birthday | date:&quot;yyyyMMdd&quot; &#125;&#125;&lt;p&gt;\n7.3 自定义管道angular4还支持自定义管道，你可以自己定义想要的管道。\n近期接到这样一个需求：\n要求在多个页面中显示用户的头像图片，但有的用户没有上传头像的话，就需要系统根据用户性别显示默认的男女头像。\n当然这样一个简单的需求无论你是在HTML进行判断还是在js中判断都可以实现。\n当若是有多个页面都需要用到的话，似乎也是一项比较繁重的任务。\n所以你可以选择封装一个共用的方法在每个页面进行调用或者可以尝试自定义一个管道。    \n博主工作中使用的是前端框架Angularjs4，项目整体是使用angular-cli进行搭建的，下面介绍的是如何在angularjs中自定义一个管道。\n\n1.确定需求\n\n1234多个页面显示用户头像若是头像图片地址不存在则判断用户性别根据用户性别显示默认的男女头像若是性别和头像图片地址都不存在则显示默认的人形头像\n\n2.设计管道\n\n1.前期准备\n在项目目录srcappcommon文件夹下创建一个新文件夹pipe，并在pipe中创建一个comm.pipe.ts文件。\n(common文件夹是我存放一些公共组件方法管道的文件夹,它是一个功能的模块，其中的所有组件方法管道我都会在common文件夹下的shared.module.ts中进行导出)\n2.编写comm.pipe.ts\n自定义管道需要先引入@angularcore中的Pipe和PipeTransform\n12345678910111213141516171819comm.pipe.tsimport &#123; Pipe, PipeTransform &#125; from @angularcore;const sexList = [, 男, 女];const uHeadImg = [.assetsimagesdefault_male.png, .assetsimagesboy.png, .assetsimagesgirl.png];@Pipe(&#123; name: portrait &#125;)export class Portrait implements PipeTransform &#123;    transform(value): string &#123;        let url = ;        if (value === 男 || value === 女) &#123;            let idx = sexList.indexOf(value);            url = uHeadImg[idx];        &#125; else &#123;            url = value ? value : uHeadImg[0];        &#125;        return url;    &#125;&#125;\n\n定义俩个数组一个为性别，一个为三种图片的存放路径\n需要使用@Pipe来装饰类\n实现PipeTransform的transform方法，该方法接受一个输入值和一些可选参数\n在@Pipe装饰器中指定管道的名字，这个名字就可以在模板中使用。\ntransform为PipeTransform中继承而来的方法，它接收0个或多个参数\n\n\n3.导出自定义管道\n\n在shared.module.ts中导出：\n12345678910111213141516171819202122shared.module.tsimport &#123; NgModule &#125; from @angularcore;import &#123; Portrait &#125; from .pipecomm.pipe;...@NgModule(&#123;  imports: [    ...  ],  declarations: [  \t...    Portrait  ],  exports: [    ...    Portrait  ]&#125;)export class SharedModule &#123;&#125;\n\n4.使用管道\n\n由于管道是在shared.module.ts中导出的，因此要使用它就必须在要使用的模块中导入\n如在student这个模块中使用\n1.首先在student.module.ts中引用\n12345678910111213141516171819student.module.tsimport &#123; NgModule &#125; from @angularcore;import &#123; SharedModule &#125; from ...commonshared.module;import &#123; Students &#125; from .students; students为该模块下的一个页面@NgModule(&#123;  imports: [    SharedModule,      ],  declarations: [    Students  ],  providers: [  ]&#125;)export class StudentModule &#123; &#125;\n2.在页面中使用：\n123456students.component.html&lt;div class=uHead&gt;\t&lt;span&gt;学员头像：&lt;span&gt;\t&lt;img src=&#123;&#123;studentInfo[uHeadUrl]||studentInfo.sex | portrait&#125;&#125; title=头像 alt=头像&gt;&lt;div&gt;\n\nstudentInfo.uHeadUrl||studentInfo.sex就是传递给管道的参数，表示为如果有头像路径则传递头像路径，没有则传递性别。\n| potrait`表示使用名为potrait的管道，就是你在comm.pipe.ts中定义的name\n\n\n5.总结\n\n在angularjs4中使用管道总结为这么几步：\n1.定义一个自定义管道的ts并引入@angularcore中的Pipe来编写管道\n2.将自定义管道的ts在模块中导出\n3.要使用管道的模块中引入管道模块\n4.html中使用的话采用以下方式：\n1&#123;&#123; info | PipeName &#125;&#125;   PipeName为你自定义的管道名称\n第八章： HTTP8.1 配置HttpModule模块我们的应用将会依赖于 Angular 的http服务，它本身又依赖于其它支持类服务。 来自@angularhttp库中的HttpModule保存着这些 HTTP 相关服务提供商的全集。\n我们要能从本应用的任何地方访问这些服务，就要把HttpModule添加到AppModule的imports列表中。 这里同时也是我们引导应用及其根组件AppComponent的地方。\n1.在app.moudule.ts中引入\n123456789101112131415161718192021...import &#123; HttpModule &#125;    from @angularhttp;\t 1....@NgModule(&#123;  imports: [    BrowserModule,    FormsModule,    HttpModule,\t\t\t\t\t 2.    AppRoutingModule  ],  declarations: [    AppComponent,    DashboardComponent,    HeroDetailComponent,    HeroesComponent,  ],  providers: [ HeroService ],  bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125;\n8.2 模拟web API在拥有一个能处理Web请求的服务器之前，我们可以先用HTTP客户端通过一个模拟（Mock）服务（内存Web API）来获取和保存数据。\n在app.module.ts中修改\n1234567891011121314151617181920import &#123; InMemoryWebApiModule &#125; from angular-in-memory-web-api;\t 1. import &#123; InMemoryDataService &#125;  from .in-memory-data.service; import &#123; AppComponent &#125;         from .app.component;import &#123; DashboardComponent &#125;   from .dashboard.component;import &#123; HeroesComponent &#125;      from .heroes.component;import &#123; HeroDetailComponent &#125;  from .hero-detail.component;import &#123; HeroService &#125;          from .hero.service; @NgModule(&#123;  imports: [    BrowserModule,    FormsModule,    HttpModule,    InMemoryWebApiModule.forRoot(InMemoryDataService),\t 2.    AppRoutingModule  ],&#125;)export class AppModule &#123; &#125;\n在app下创建一个in-memory-data.service.ts文件：\n12345678910111213141516171819import &#123; InMemoryDbService &#125; from angular-in-memory-web-api;export class InMemoryDataService implements InMemoryDbService &#123;  createDb() &#123;    const heroes = [      &#123; id: 0,  name: Zero &#125;,      &#123; id: 11, name: Mr. Nice &#125;,      &#123; id: 12, name: Narco &#125;,      &#123; id: 13, name: Bombasto &#125;,      &#123; id: 14, name: Celeritas &#125;,      &#123; id: 15, name: Magneta &#125;,      &#123; id: 16, name: RubberMan &#125;,      &#123; id: 17, name: Dynama &#125;,      &#123; id: 18, name: Dr IQ &#125;,      &#123; id: 19, name: Magma &#125;,      &#123; id: 20, name: Tornado &#125;    ];    return &#123;heroes&#125;;  &#125;&#125;\n这个文件已经替换了mock-heroes.ts，可以删除mock-heroes.ts了\n但有上面那些步骤还是不够的，此时你会发现angular-in-memory-web-api并不能用。\n解决步骤：\n1.查看工程根目录下的package.json，没有添加angular-in-memory-web-api，于是在”dependencies”下添加&quot;angular-in-memory-web-api&quot;: &quot;^0.3.2&quot;\n12345678910111213141516171819202122232425&#123;...  dependencies: &#123;    @angularanimations: ^5.0.0,    @angularcommon: ^5.0.0,    @angularcompiler: ^5.0.0,    @angularcore: ^5.0.0,    @angularforms: ^5.0.0,    @angularhttp: ^5.0.0,    @angularplatform-browser: ^5.0.0,    @angularplatform-browser-dynamic: ^5.0.0,    @angularrouter: ^5.0.0,    angular-in-memory-web-api: ^0.3.2,    cnpm: ^5.1.1,    core-js: ^2.4.1,    echarts: ^3.8.5,    ng2-echarts: ^0.0.3,    ngx-echarts: ^2.0.1,    rxjs: ^5.5.2,    zone.js: ^0.8.14  &#125;,  devDependencies: &#123;\t...  &#125;&#125;\n2.然后在项目根目录下执行cnpm install安装angular-in-memory-web-api依赖。\n3.重新打开项目。或者执行npm start.\n8.3 使用http.get()这里我用的还是第四章设定的heroes.service.ts服务\n将原本的从mock-heroes.ts获取heroes改为从我们的模拟web API中获取。\nheroes.service.ts\n12345678910111213141516171819202122232425import &#123; Injectable &#125; from @angularcore;import &#123; Headers, Http &#125; from @angularhttp;\t 1. import rxjsaddoperatortoPromise;\t\t\t 2. import &#123; Hero &#125; from .hero;@Injectable()export class HeroService &#123;  private heroesUrl = apiheroes;   3.   constructor(private http: Http) &#123; &#125;\t 4. 获取全部英雄 getHeroes(): Promise&lt;Hero[]&gt; &#123;   return this.http.get(this.heroesUrl)              .toPromise()              .then(response =&gt; response.json().data as Hero[])              .catch(this.handleError); &#125;   private handleError(error: any): Promise&lt;any&gt; &#123;   console.error(An error occurred, error);  for demo purposes only   return Promise.reject(error.message || error); &#125;&#125;\n刷新浏览器后，英雄数据就会从模拟服务器被成功读取。\n使用时，比如在dashboard中获取全部英雄\n1234567891011import &#123; Component, OnInit &#125; from @angularcore;import &#123; HeroService &#125; from .hero.service;\t 1.export class DashboardComponent implements OnInit &#123;  constructor(private heroService: HeroService) &#123; &#125;\t 2.    ngOnInit(): void &#123;    this.heroService.getHeroes()\t\t\t 3.      .then(heroes =&gt; this.heroes = heroes);  &#125;\n8.4 url拼接没用http请求之前，获取英雄详情，我们使用的是：\n1234getHero(id: number): Promise&lt;Hero&gt; &#123;  return this.getHeroes()             .then(heroes =&gt; heroes.find(hero =&gt; hero.id === id));&#125;\n从模拟服务器获取指定英雄数据：\n123456789101112131415private heroesUrl = apiheroes;   1. URL to web api 获取指定的英雄getHero(id: number): Promise&lt;Hero&gt;&#123;\t 2.  const url = this.heroesUrl +  + hero.id;  return this.http.get(url)              .toPromise()              .then(response =&gt; response.json().data as Hero)              .catch(this.handleError);&#125; private handleError(error: any): Promise&lt;any&gt; &#123;\t 3.请求错误   console.error(An error occurred, error);    return Promise.reject(error.message || error);&#125;\n8.5 http.put()改点击英雄列表中的英雄，进入英雄详情页，然后点击保存对英雄信息进行更改:\n1.\nhero-detail.component.html\n1&lt;button (click)=&quot;save()&quot;&gt;Save&lt;button&gt;\nhero-detail.component.ts\n12345678910111213141516import &#123; HeroService &#125; from ..hero.service;export class HeroDetailComponent implements OnInit&#123;    constructor(        private heroService: HeroService,    ) &#123;&#125;        save(): void &#123;        this.heroService.upData(this.hero)          .then(() =&gt; this.goBack());      &#125;    goBack(): void &#123;        this.location.back();      &#125;    providers: [HeroService]&#125;\n2.在英雄服务中设置：\n123456789 跟新英雄信息upData(hero: Hero): Promise&lt;Hero&gt;&#123;  const url = this.heroesUrl +  + hero.id;  return this.http              .put(url, JSON.stringify(hero), &#123;headers: this.headers&#125;)              .toPromise()              .then(() =&gt; hero)              .catch(this.handleError);&#125;\n8.6 http.post()增heroes.component.html\n123456&lt;div&gt;  &lt;label&gt;Hero name:&lt;label&gt; &lt;input #heroName &gt;  &lt;button (click)=add(heroName.value); heroName.value=&gt;    Add  &lt;button&gt;&lt;div&gt;\nheroes.component.ts (add)\n123456789add(name: string): void &#123;  name = name.trim();  if (!name) &#123; return; &#125;  this.heroService.create(name)    .then(hero =&gt; &#123;      this.heroes.push(hero);      this.selectedHero = null;    &#125;);&#125;\nhero.service.ts (create)\n1234567create(name: string): Promise&lt;Hero&gt; &#123;  return this.http    .post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), &#123;headers: this.headers&#125;)    .toPromise()    .then(res =&gt; res.json().data as Hero)    .catch(this.handleError);&#125;\n8.7 http.delete()删heroes.component.html (li-element)\n1234567&lt;li *ngFor=let hero of heroes (click)=onSelect(hero)    [class.selected]=hero === selectedHero&gt;  &lt;span class=badge&gt;&#123;&#123;hero.id&#125;&#125;&lt;span&gt;  &lt;span&gt;&#123;&#123;hero.name&#125;&#125;&lt;span&gt;  &lt;button class=delete    (click)=delete(hero); $event.stopPropagation()&gt;x&lt;button&gt;&lt;li&gt;\nheroes.component.ts (delete)\n12345678delete(hero: Hero): void &#123;  this.heroService      .delete(hero.id)      .then(() =&gt; &#123;        this.heroes = this.heroes.filter(h =&gt; h !== hero);        if (this.selectedHero === hero) &#123; this.selectedHero = null; &#125;      &#125;);&#125;\nhero.service.ts (delete)\n1234567delete(id: number): Promise&lt;void&gt; &#123;  const url = this.heroesUrl +  + id;  return this.http.delete(url, &#123;headers: this.headers&#125;)    .toPromise()    .then(() =&gt; null)    .catch(this.handleError);&#125;\n","tags":["前端进阶","Angular"],"path":"2017/12/21/webNotes/advanced/Angular/basicAngular/","external_link":""},{"title":"ES6","date":"2017-03-09T11:24:45.000Z","content":"第一章:ES6简介​    ECMAScript 简称ES6\n​    由于ES6是在2015年发布的，所以也叫ES2015。\n第二章:块级作用域在ES5之前，是不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。\n1.块级作用域中没有了变量的声明提前\n2.1 let声明let声明语法和var 一样,不过let声明的变量只能在当前的代码块中,这是它也var 的最大区别.\n1234567let a = 10;       if(a&gt;0)&#123;           console.log(b);\t\t报错           let b = 5;\t\t           console.log(b);\t\t5       &#125;       console.log(b);\t\t\t报错\n2.2  const声明在ES6使用const来声明的变量称之为常量,表示它们不能再次被赋值.\n由于这个原因，所有的 const 声明的变量都必须在声明处进行初始化.\nconst声明的变量其实和let变量一样也具有块级作用域的特性.\n12345678let a = 10;      if(a&gt;0)&#123;          console.log(b);\t报错          const b=10;          console.log(b);\t10          b = 20;\t\t\t报错,不能重新赋值          const c;\t\t报错,声明常量时要同时赋值      &#125;\n第三章:函数3.1 带默认参数的函数12345678function foo(m=10,n=20)&#123;  console.log(m,n)&#125;foo(3,4)=&gt;3 4若调用foo时不传递参数,则会赋值默认的参数foo()=&gt;10,20\n3.2 默认参数对arguments对象的影响\n在非严格模式下,arguments的值总是和形参的值保持一致(也就是总能反映形参的变化).\n\n12345678910function foo(a, b) &#123;      非严格模式      console.log(arguments[0] === a); true      console.log(arguments[1] === b); true      a = 10;      b = 20;      console.log(arguments[0] === a); true      console.log(arguments[1] === b); true  &#125;  foo(1, 2);\n\n在ES5的严格模式下,arguments只反映参数的初始值而不再反映形参的变化.\n\n12345678910function foo(a, b) &#123;        非严格模式        console.log(arguments[0] === a); true        console.log(arguments[1] === b); true        a = 10;        b = 20;        console.log(arguments[0] === a); false        console.log(arguments[1] === b); false    &#125;    foo(1, 2);\n\n当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。\n若调用函数时不传入实参,则argunments并不会被赋值默认值:\n\n123456789function foo(a, b = 30) &#123;            console.log(arguments[0]); 1            console.log(arguments[1]); undefined            a = 10;            b = undefined;            console.log(arguments[0]  === a); false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。            console.log(arguments[1] === b); true。  b使用了默认值，所以表现的和严格模式一样。        &#125;        foo(1);\n3.3 剩余参数剩余参数使用三个点( … )和变量名来表示。\n不管函数传递多少的实参,剩余参数都会把它归集为自身\n123456function foo(a,b,...c)&#123;          console.log(a,b,c);        \tconsole.log(b instanceof Array);  true  .多余的参数都被放入了c中。c其实就是一个数组      &#125;      foo(1,2,3,4);      =&gt;1 2 [3,4]\n第四章:箭头函数4.1 语法123(形参列表)=&gt;&#123;\t函数体&#125;\n12345678例1:var sum = (num1,num2) =&gt;&#123;  return num1 + num2&#125;等同于:var sum = function(num1,num2)&#123;  return num1 + num2&#125;\n若函数体内中只有一行代码,则包裹函数体的大括号({})可以省略.\n如果有return，return关键字也可以省略。\n如果函数体内有多条语句,则{}就不能省略.\n并且若函数只有一个参数,则函数的( )也可以省略.\n123456789101112例1:\t\tvar sum = (a)=&gt;&#123;            return   ++a;        &#125;        console.log(sum(3));        =&gt;41.简写为:\t\tvar sum = (a)=&gt;++a;        console.log(sum(3));2.还可以简写为:\t\tvar sum = a=&gt;++a;\t\tconsole.log(sum(3));\n如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 ()\n1234567891011&lt;script type=textjavascript&gt;    var foo = ()=&gt;(&#123;name:lisi, age:30&#125;);    console.log(foo());\t等同于下面的；\tvar foo1 = ()=&gt;&#123;      \treturn &#123;          \tname:lisi,          \tage : 30      \t&#125;;\t&#125;&lt;script&gt;\n4.3 箭头函数中无this绑定\n箭头函数没有自己的this,箭头函数内部的this其实就是它的外部函数的this.\n\n12345678910111213141516171819例1:\t普通函数:\t\tvar p = &#123;            name:wang,            eat:function ()&#123;                console.log(this);            &#125;,        &#125;;        p.eat();        =&gt;&#123;name: wang, eat: ƒ&#125;     箭头函数:     \tvar p = &#123;            name:wang,            eat:()=&gt;&#123;                console.log(this);            &#125;,        &#125;;        p.eat();        =&gt;Window &#123;stop: ƒ, open: ƒ, alert: ƒ, confirm: ƒ, prompt: ƒ, …&#125;\n\n箭头函数的this,和调用者没有关系,只和声明的地方有关系,所以适合用于回调函数\n\n1234567891011例1:\t\tvar p = &#123;            name:wang,            eat:function()&#123;               return () =&gt;&#123;                console.log(this);                &#125;            &#125;        &#125;;        p.eat()();        =&gt;&#123;name: wang, eat: ƒ&#125;\n12345678例2:\t\tvar arr = [10,20,30,40];        var sum = arr.reduce((sum, a) =&gt; sum+a, 0);        console.log(sum);        =&gt;100        var arr1 = arr.map(a=&gt;a*a);        console.log(arr1);        =&gt;[100, 400, 900, 1600]\n4.4箭头函数无arguments12345678&lt;script type=textjavascript&gt;    function foo() &#123;        这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。        return ()=&gt;arguments[0]; 箭头函数的返回值是foo函数的第一个参数    &#125;    var arrow = foo(4, 5);    console.log(arrow());  4&lt;script&gt;\n第五章:对象功能拓展5.1 简写属性的初始化12345678910111213function createPerson(name,age)&#123;  return &#123;    name:name;    age:age  &#125;&#125;简化为:function createPerson(name,age)&#123;  return &#123;    name;\t\t省略了 属性名:    age   &#125;&#125;\n5.2 简写方法的声明12345678910111213141516var person = &#123;  name:王先生,  eat:function(food)&#123;    console.log(this.name+爱吃+food)  &#125;&#125;person.eat(拨娜娜)=&gt;王先生爱吃拨娜娜简化为:\tvar person = &#123;  name:王先生,  eat(food)&#123;\t\t\t省略了:和function    console.log(this.name+爱吃+food)  &#125;&#125;person.eat(拨娜娜)\n5.3在字面量中动态计算属性名\n在ES5之前,想要访问对象的动态属性名,只能使用 对象[属性名]的方式来访问,如下:\n\n1234567例1:\t\tvar arrName = name;        var person = &#123;            name:王先生,        &#125;;        console.log(person[arrName]);        =&gt;王先生\n\n下面的这种方式是无法访问的:\n\n1234567例2:\t\tvar arrName = name;        var person = &#123;            arrName:王先生,        &#125;;        console.log(person[arrName]);        =&gt; undefined\n\n在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。\n\n123456例3:\t\tvar arrName = name;        var person = &#123;            [arrName]:王先生,        &#125;;        console.log(person[arrName]);\n5.4 新增方法1.Object.is( )\n该函数接受了两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：\n\n1234567891011121314console.log(+0 == -0);               trueconsole.log(+0 === -0);              trueconsole.log(Object.is(+0, -0));      falseconsole.log(NaN == NaN);             falseconsole.log(NaN === NaN);            falseconsole.log(Object.is(NaN, NaN));    trueconsole.log(5 == 5);                 trueconsole.log(5 == 5);               trueconsole.log(5 === 5);                trueconsole.log(5 === 5);              falseconsole.log(Object.is(5, 5));        trueconsole.log(Object.is(5, 5));      false\n很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 **认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的**。不过弃用后者是完全没有必要的。何时要选择 Object.is() 与 == 或 === 取决于代码的实际情况。\n2.Object.assign( )\nassing可以把一个对象的属性和方法完整的转copy到另外一个对象中。\n这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）\n\n1234567var  p1 = &#123;  name:王先生&#125;;var p2 = &#123;&#125;;Object.assign(p2,p1);console.log(p2);=&gt;&#123;name: 王先生&#125;\n\nassign方法可以接受任意多的提供者。意味着后面提供者的同名属性和覆盖前面提供者的属性值。\n\n123456789101112var  p1 = &#123;  name:王先生  age:18&#125;;var p2 = &#123;  name:王  sex:女&#125;var p3 = &#123;&#125;;Object.assign(p3,p1,p2);console.log(p3);=&gt;&#123;name: 王, age: 18, sex: 女&#125;\n\n深拷贝\n\n深拷贝可以使用JSON.parse(JSON.stringify(p)),这样拷贝的对象就不会被改变\n123456789var p = &#123;        name: &quot;王&quot;    &#125;;var p1 = JSON.parse(JSON.stringify(p))p1.name = &quot;张&quot;;console.log(p);console.log(p1);=&gt; &#123;name:&quot;王&quot;&#125;=&gt; &#123;name:&quot;张&quot;&#125;\n注:不过上面的深拷贝方式还是会有不足之处：\n\n会忽略undefined\n不能序列化函数\n不能解决循环引用的对象\n\n3.Object.keys()\n返回一个数组，数组中的每一项为目标对象可枚举属性名的集合\n\n12var obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;console.log(Object.keys(obj)) [&quot;foo&quot;, &quot;baz&quot;]\n\n与ES8中的Object.values()比较,Object.values()返回的是属性值的数组\n\n123var obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;console.log(Object.keys(obj)) [&quot;foo&quot;, &quot;baz&quot;]console.log(Object.values(obj)) [&quot;bar&quot;, 42]\n\n自定义Object.keys()\n\n12345678910Object.keys()的作用就类似于for...infunction myKeys() &#123;    let keyArr = []    for (let key in obj1) &#123;        keyArr.push(key)        console.log(key)    &#125;    return keyArr&#125;console.log(myKeys(obj1)) [&quot;foo&quot;, &quot;baz&quot;]\n\n与ES8中的Object.entries()比较,Object.entries()返回的是目标对象所有可枚举属性的属性名和属性值的二维数组,并且返回数组的顺序是按键名升序\n\n1Object.entries(&#123; 3: &apos;a&apos;, 4: &apos;b&apos;, 1: &apos;c&apos; &#125;)    [[&apos;1&apos;, &apos;c&apos;], [&apos;3&apos;, &apos;a&apos;], [&apos;4&apos;, &apos;b&apos;]]\n第六章:字符串功能的增加6.1 字符串查找\nincludes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。\nstartsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。\nendsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。\n\n6.2    repeat方法\nECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：\n\n123console.log(x.repeat(3));          xxxconsole.log(hello.repeat(2));      hellohelloconsole.log(abc.repeat(4));        abcabcabcabc\n6.3 字符串模板字面量\n使用一对反引号 (tab正上方的按键)来表示模板字面量。\n内部变量可以用${ } 括起来\n\n6.4 多行字符串在字符串尾部添加 反斜杠 就可以实现多行字符串\n1234\t\tvar str = abcaaa;        console.log(str);        =&gt;abcaaa\n6.5 模板标签一个标签仅代表一个函数，他接受需要处理的模板字面量。\n标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。\n函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。\n标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：\n1234567891011let name = 张三,             age = 20,             message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`;         function show(stringArr, value1, value2) &#123;             console.log(stringArr);              console.log(value1);   张三             console.log(value2);   20             return abc;         &#125;         console.log(message);\n第七章: 解构7.1 对象解构\n对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。\n\n在ES5之前,我们要读取对象中的属性需要使用对象名.属性值来读取,而ES6中\n1234567var p = &#123;             name:王,             age:18         &#125;;         var &#123;name,age&#125; = p;\t这里就相当于声明了两个变量： name=p.name   age=p.age         console.log(name,age);         =&gt;王  18\n\n在上面的结构中必须要初始化。否则会出现语法错误。\n\n123456789在上面的结构中必须要初始化。否则会出现语法错误。 语法错误！var &#123; type, name &#125;; 语法错误！let &#123; type, name &#125;; 语法错误！const &#123; type, name &#125;;\n\n不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）\n\n1234567var p = &#123;             name:&quot;王&quot;,             age:18         &#125;;         var &#123;name=&quot;张&quot;,age=20,sex=&apos;男&apos;&#125; = p;\t这里就相当于声明了两个变量： name=p.name   age=p.age         console.log(name,age,sex);         =&gt;王  18  男\n7.2数组的解构\n数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：\n\n12345let arr = [1,2,3,4];let [first,second] = arr;console.log(first);\t\t1console.log(second);\t2\n\n如果只想取数组中的某一项，则可以不用命名。\n\n1234let arr = [1,2,3,4];let [, ,third] = arr;console.log(third);\t\t3\n几种交换方式;\n1234567891011121314151617181920第一种var temp = a;a = b;b = temp;第二种a = a + b;b = a - b;a = a - b;第三种 异或(只能用在整数上)a = a ^ b;b = a ^ b;a = a ^ b;第四种 数组解构[a,b] = [b,a]\t\t解构语法 = 数组第五种 数组解构(&#123;a,b&#125; = [a:b,b:a]);\n第八章:Symbol类型\n在ES5之前,5种基本数据类型是: Number    String    Boolean        Null        Undefined\nES6新增的一种数据类型:    Symbol\n在ES5之前我们都没办法创建私有变量,只能想办法去封装.symbol 来创建私有成员.\n\n8.1创建Symbol\n使用symbol全局函数来创建Symbol\n\n123456例1:let firstName = Symbol();   创建一个Symbol   let person = &#123;&#125;;   person[firstName] = 王先生;   console.log(person[firstName]);      王先生\n在例1中,firstName被作为Symbol类型赋值给person成为其属性,每次访问这个属性时必须使用该 symbol .\n\n创建Symbol时候,( )内也可以传入字符串,不过一般没有什么实际的用处,仅仅是在调试输出的时候方便.\n\n123var s1 = Symbol(abc);   var s2 = Symbol(abc);   console.log(s1 == s2); false\n注:任意俩个Symbol都不会相等    \n8.2 识别Symbol可以使用typeof来识别Symbol类型\n12let symbol = Symbol();console.log(typeof symbol);          &quot;symbol&quot;\n8.3    Symbol作为属性名123456789101112131415例1:var mySymbol = Symbol(); 第一种写法var a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;; 第二种写法var a = &#123;\t[mySymbol]: &apos;Hello!&apos;&#125;\n\nsymbol作为对象的属性的时候，只能使用 [ ] 去访问，不能使用点去访问。\n\nES6之前,属性名只能使用字符串,如果是其他类型的,在js会自动将它转换为字符串:\n12345678910111213141516171819202122232425262728例2:var mr = [1,2];var obj = &#123;  [m]:&quot;abc&quot;\t\t&#125;console.log(obj);\t=&gt;&#123;1,2: &quot;abc&quot;&#125;例3:var m = &#123;&quot;age&quot;:20&#125;;var obj = &#123;  [m]:&quot;abc&quot;\t\t&#125;console.log(obj);\t=&gt;&#123;[object Object]: &quot;abc&quot;&#125;例3:var m = &#123;           &apos;age&apos;:20,           toString:function () &#123;               return &quot;name&quot;             &#125;         &#125;;var obj = &#123;  [m]:&quot;abc&quot;\t\t&#125;console.log(obj);\t=&gt;&#123;name: &quot;abc&quot;&#125;\n8.4    Symbol属性名的遍历\nSymbol有一个私有的方法: Object.getOwnPropertySymbols方法,可以获取指定对象的所有 Symbol 属性名。\nsymbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。\n\n\n1.遍历对象中Symol属性名的API:    Object.getOwnPropertySymbols( );\n\n123456789例1:\t\t\t\t\t\tvar p =&#123;&#125;;            var a = Symbol(a);            var b = Symbol(b);            p[a] = 王先生;            p[b] = 18;            var objectSymbols = Object.getOwnPropertySymbols(p);            console.log(objectSymbols);            =&gt;[Symbol(a), Symbol(b)]\n123456例2:利用for in 来遍历例1的p:\tfor(var i in p)&#123;      console.log(i);\t&#125;\t=&gt;遍历到的是空的,证明Symbol作为属性名并不能被for in 和 for of 遍历到.\n\n2.遍历对象中常规属性名的API:    Object.getOwnPropertyNames( );\n\n12345678910111213例3:\t\t\tvar a = Symbol(a);            var b = Symbol(b);                        var p =&#123;              sex:男,              [a]:王先生,              [b]:18            &#125;                        var objectNames=Object.getOwnPropertyNames(p); [sex]  只能拿到非Symbol类型的属性\t\t\tvar objectSymbols=Object.getOwnPropertySymbols(p) [Symbol(a),Symbol(b)]\n\n3.遍历所有类型的属性，包括常规和Symbol型的API:    Reflect.ownKeys( );\n\n12345例4:利用Reflect.ownKeys()变量例3中的p\t\t\tvar allNames = Reflect.ownKeys(p)            console.log(allNames);            =&gt;[&quot;sex&quot;, Symbol(a), Symbol(b)]\t取到了所以的属性名\n8.5 Symbol.for(字符串)\n在上面介绍了,获取一个Symbol 可以直接用var a  = Symbol(),这里获取的Symol一定是最新的.\n而Symbol.for方法也可以获取Symbol,但是它有一个查找的功能:即在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个Symbol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。\n\n12345例1:\t\t\tvar a = Symbol.for(a);\t第一个var a 表示先在全局中查找Symbol(a),没找到,所以此时新建了一个Symol(a);            var a2 = Symbol.for(a);\t第二个var a2 表示在全局中查找Symbol(a),找到了,所以返回Symbol(a);            console.log(a == a2);\t因为两次搜到的是同一个Symbol，所以此处是true\n8.6 Symbol.keyFor(symbol)\nSymbol.keyFor(symbol):返回一个已经全局注册的symbol的”key”。\n\n123456&lt;script type=textjavascript&gt;    var a = Symbol(foo);    var b = Symbol.for(foo);    console.log(Symbol.keyFor(a));  undefined.   因为a没有向全局环境中注册，所以是undefinded    console.log(Symbol.keyFor(b));  foo&lt;script&gt;\n第九章: set数据结构\nSet是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set中的元素不能重复，而数组中的元素可以重复。\n一句话总结：Set类型是一个包含无重复元素的有序列表\n\n9.1 创建set并添加1.利用new Set( ) 来创建;\n2.利用add( )来添加元素;\n3.利用size属性查看set中的元素个数;\n4.set中不能添加重复元素\n1234567891011例1:\t\t\t\t\t\tvar set1 = new Set();            set1.add(1);\t\t\tset1.add(1);\t添加重复元素\t\t\tset1.add(1);\t添加字符串            set1.add(2);            set1.add(3);            console.log(set1);\t\t\tconsole.log(set1.size);\t            =&gt;&#123;1,1,2, 3&#125;\t\t\t=&gt;4\n9.2 遍历set1.利用for…of…来遍历\n12345678例2:\t\t\tfor(var s of set1)&#123;                console.log(s);            &#125;            1            1            2            3\n2.利用forEach来遍历\nforEach(function(value,key,ownerSet){\n})\n参数1：遍历到的元素的值\n参数2：对set集合来说，参数2的值和参数1的值是完全一样的。\n参数3：这个 ==set== 自己\n12345678例3:\t\t\tset1.forEach(function (value, key, ownerSet) &#123;                console.log(value,key,ownerSet);            &#125;)            1 1 Set(4) &#123;1, 1, 2, 3&#125;            1 1 Set(4) &#123;1, 1, 2, 3&#125;            2 2 Set(4) &#123;1, 1, 2, 3&#125;            3 3 Set(4) &#123;1, 1, 2, 3&#125;\n9.3 set去重1234567891011例1:\t\t\t\t\t\tvar arr = [1,1,2,3,4,5,5];            var arr2 = [...new Set(arr)];\t新创建一个arr2数组来盛放            console.log(arr2);例2:若要将数据塞到原来的arr中,可以先清空arr,再添加进去\t\t\tvar arr = [1,1,2,3,4,5,5];            var arr2 = [...new Set(arr)];            arr.splice(0,arr.length);或者使用 arr.length=0;            arr.push(arr2)            console.log(arr);\n9.4 set.clear( )\n清空set中的所有内容\n\n123456789例1:\t\t\tvar s = new Set();             s.add(1);             s.add(2);             console.log(s);             s.clear();             console.log(s);\t\t\t\t=&gt;&#123;1,2&#125;\t\t\t=&gt;&#123;&#125;\n9.5 利用set获取交集并集set常用的做法除了数组去重，应该就是用于获取俩个数组的交集并集还有差集了\n交集：俩数组中相同的元素集合\n并集：俩数组中全部的元素集合\n差集：俩数组中不相同的元素集合\n123456var arr1 = [1, 2];var arr2 = [1, 3];交集:[1]并集:[1, 2, 3]arr1对于arr2的差集(arr1中有,arr2中没有): [2]arr2对于arr1的差集同理: [3]\n使用\n12345678910111213141516arr1 = [1, 2];   arr2 = [&apos;1&apos;, &apos;3&apos;]   var set1 = new Set(arr1);   var set2 = new Set(arr2.map(ele =&gt; &#123; return Number(ele) &#125;));   console.log(set1);   console.log(set2);    交集   let intersectionSet = new Set([...set1].filter(x =&gt; set2.has(x)));   console.log(intersectionSet)    ab差集   let differenceABSet1 = new Set([...set1].filter(x =&gt; !set2.has(x)));   console.log([...differenceABSet1])    ab差集   let differenceABSet2 = new Set([...set2].filter(x =&gt; !set1.has(x)));   console.log([...differenceABSet2])\n1234567891011121314151617181920212223242526272829**   * 获取2个数组的交集并集差集   * @param arr1 数组1   * @param arr2 数组2   * @returns nuionArr: 2个数组的并集    * intersectionArr: 2个数组的交集   * differArr1: 数组1中有,数组2中没有的数   * differArr2: 数组2中有,数组1中没有的数   *  checkDifferentArr(arr1, arr2) &#123;    arr1 = arr1 || [];    arr2 = arr2 || [];    let set1 = new Set(arr1.map(ele =&gt; &#123; return Number(ele) &#125;))    let set2 = new Set(arr2.map(ele =&gt; &#123; return Number(ele) &#125;))     并集    let unionSet = new Set([...set1, ...set2]);     交集    let intersectionSet = new Set([...set1].filter(x =&gt; set2.has(x)));     set1中有,set2中没有    let differenceSet1 = new Set([...set1].filter(x =&gt; !set2.has(x)));     set2中有,set1中没有    let differenceSet2 = new Set([...set2].filter(x =&gt; !set1.has(x)));    return &#123;      &apos;nuionArr&apos;: [...unionSet],      &apos;intersectionArr&apos;: [...intersectionSet],      &apos;differArr1&apos;: [...differenceSet1],      &apos;differArr2&apos;: [...differenceSet2]    &#125;  &#125;\n第十章: map数据结构10.1 创建map并添加map主要是对对象类型的补充\n1.利用new Map( )来创建;\n2.利用.set(key, value) 方法来添加;map 类型包含一组有序的键值对，其中键和值可以是任何类型, key 不允许重复,但是value允许重复.\n3.添加相同的属性的时候,后面的属性会把前面的给覆盖;\n4.get(key),来获取指定key对应的value\n1234567例1:\t\t\t\t\t\tvar map = new Map();            map.set(a,aa);            map.set(b,bb);            map.set(b,bbb);            console.log(map);            console.log(map.get(a))\n10.2 Map的初始化由于Map中的内容是以键子对的形式存储的,所以我们向里面添加内容的时候应该添加的是一个个的数组:    即(通过二维数组,给Map初始化值).\n123var map = new Map([[a,aa],[b,bb]]);         console.log(map);         =&gt;&#123;a =&gt; aa, b =&gt; bb&#125;\n10.3 Map与Set类似的3个方法\nhas(key) - 判断给定的 key 是否在 map 中存在\n\ndelete(key) - 移除 map 中的 key 及对应的值\n\nclear() - 移除 map 中所有的键值对\n12345678910var map = new Map();         map.set(a,aa);         map.set(b,bb);         map.set(b,bbb);         console.log(map.has(a));\ttrue         map.delete(b);         console.log(map);\t\t\t&#123;a =&gt; aa&#125;         map.clear();         console.log(map);\t\t\t&#123;&#125;\n\n\n10.4 Map的forEach方法\n利用forEach来遍历\nmap.forEach(function(value,key,ownMap){ });\n1234&gt; \t\t参数1：键值对的value&gt;         参数2：键值对的key&gt;         参数3：map对象本身&gt;\n\n12345678var map = new Map([[a,aa],[b,bb]]);         map.forEach(function (key,value,ownMap) &#123;             console.log(key,value,ownMap);           \tconsole.log(this);         &#125;);         =&gt;aa a Map(2) &#123;a =&gt; aa, b =&gt; bb&#125;         =&gt;bb b Map(2) &#123;a =&gt; aa, b =&gt; bb&#125;=&gt;window\n第十一章: 迭代器11.1 迭代器简介什么是迭代器?\n\n迭代器是一个对象\n迭代器提供一个方法next() 这个方式总是能够返回迭代到的对象。\nnext返回的对象中，至少有两个属性：done 是一个boolean值(表示数据是否迭代完)。 value：具体的数据(迭代到的具体数据)\n\nOK,下面我们利用以前的知识手动创建一个迭代器,遵循上面的三个条件:\n12345678910111213141516171819202122例1:\t\t\t\t\t\tfunction createIterator(arr)&#123;                var index = 0;                return &#123;\t\t\t1.迭代器是一个对象,所以return的是一个对象                    next()&#123;\t\t\t2.迭代器提供一个方法next()                        var done = index &gt;= arr.length;\t属性1                        var value = arr[index];\t\t\t属性2                        index++;                        return &#123;done,value&#125;\t\t\t\t返回迭代到的对象                    &#125;                &#125;            &#125;            var it = createIterator([10,20,30,40]);            var ele = it.next();            while(!ele.done)&#123;                console.log(ele.value);                ele = it.next();            &#125;\t\t\t=&gt;\t10            \t20                30                40\n11.2 生成迭代器\n当我们在创建函数的时候,在函数名之前添加一个 ,如:`function  createIterator(){}` 这样的函数就叫做生成器函数,\n生成器函数的作用就是返回一个迭代器对象\n\n新的 yield 关键字,yield 关键字只能 直接用在生成器内部 \n12345678910例2:function * createIterator()&#123;  console.log(aaa);  yield 3;  yield 4;&#125;var it = createIterator();console.log(it.next());\t\t\taaa\t\t&#123;value:3,done:false&#125;console.log(it.next());\t\t\t&#123;value: 4, done: false&#125;console.log(it.next());\t\t\t&#123;value: undefined, done: true&#125;\n每调用一次迭代器的next方法，如果碰到 yield 都会返回一个迭代到的一个对象，然后停止执行，直到下次调用next方法，会从上次停止的地方继续执行。\n所以我们就可以在生成器函数传入一个要迭代的数组,然后在函数内做一个for循环来将所有的value值都返回出来;\n123456789101112131415161718例3\t\t\t\t\t\tfunction * createIterator(arr)&#123;                for(var i = 0;i&lt;arr.length;i++)&#123;                    yield arr[i];                &#125;            &#125;            var it = createIterator([10,20,30,40]);\t\t创建了一个迭代器对象            var ele = it.next();\t\t\t\t\t\t调用迭代器对象内置的next方法            while(!ele.done)&#123;                console.log(ele.value);                ele = it.next();            &#125;\t\t\t=&gt;\t10            \t20                30                40          会发现效果和我们的例1是一样的          上面的迭代器函数就相对完整一点了\n11.3迭代器与for…of…第十二章: 类12.1 基本类的声明\n在ES6直接借鉴其他语言，引入了类的概念。\n\n123456789101112131415class关键字要小写,后面跟着类名         class Person&#123;             等效于 Person 构造函数             constructor(name,age)&#123;  这个表示类的构造函数                 this.name = name;   创建属性                 this.age = age             &#125;             等效于 Person.prototype.say = function()&#123;&#125;             say()&#123;                 console.log(My name is +this.name);             &#125;         &#125;         let person1 = new Person(Mrs.wang,18);         person1.say();=&gt;My name is Mrs.wang\n\n类的成员,也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算)\n\n123456789101112\tlet methodName = sayName;\tclass PersonClass &#123;    constructor(name) &#123;        this.name = name;    &#125;    [methodName]() &#123;\t\t属性名是一个变量,必须用[]括起来        console.log(this.name);    &#125;&#125;let me = new PersonClass(王先生);me.sayName();            王先生\n注:\n在类的内部,不能直接书写语句,只能声明方法.\n1.construction这个构造函数内,负责诶对象添加书写\n​    在上面的例子中,name和age属性是自有属性,它们创建在构造函数中.\n2.直接在类中给原型添加方法\n3.任何的类都有一个默认的无参的constructor,如果手动添加constructor,则默认的constructor不在存在\n4.如果用typeof对类名进行测试,结果是function , es6中的类,仅仅是一种语法糖,本质仍然是构造函数+原型\n5.类不会声明提前,必须先声明再使用.\n6.类声明中的代码自动运行在严格模式下,同时没有任何办法可以手动切换到非严格模式.\n7.所有的方法都是不可枚举的(也就是不能使用for…in..)\n8.所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]].\n9.不适用new 来调用类构造函数会抛出错误,也就是必须使用new 类名()方式来创建\n10.在类的方法内部重写类名会抛出错误.（因为在类的内部，类名是作为一个常量存在的）\n12.2 启动严格模式第一种方式:\n在js标签的最头上加上一句&quot;use strict&quot;(在它之前不能有代码).\n123&lt;script&gt;\tuse strict&lt;script&gt;\n第二种方式:\n直接在要启动严格模式的函数内部写上&quot;use strict&quot;\n1234function foo()&#123;  use strict  console.log(this);&#125;\n12.3  类作为一等公民\n类可以作为参数传递\n123456789function foo(cls) &#123;             let obj = new cls();             obj.say();         &#125;         foo(class&#123;             say()&#123;                 console.log(我是类中的方法);             &#125;         &#125;)\n\n\n2.立即调用类构造函数，创建单例\n12.4 静态成员\nECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。\n静态方法直接通过类名来调用,不能通过对象来调用.\n\n首先来看一下在ES5,我们给构造函数中添加方法的俩种方式:\n1234567891011121314function Person(name)&#123;\t this.name = name;&#125;静态方法 : 直接添加到构造方法上(就是将构造函数当成一个普通对象来用)Person.eat=function () &#123;             console.log(&quot;我是静态方法&quot;);         &#125;;         实例方法 : 添加到构造方法的原型对象中         Person.prototype.say=function()&#123;             console.log(&quot;我是实例方法&quot;);         &#125;;         let p1 = new Person(&quot;王先生&quot;);         Person.eat();\t调用静态方法只能通过构造函数本身调用,不能通过对象调用(p1.eat()会报错)         p1.say();\t\t调用实例方法可以通过对象调用.\n\nECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：\n\n1234567891011121314class Person&#123;             constructor(name)&#123;                 this.name = name             &#125;             say()&#123;                 console.log(我是实例方法);             &#125;             static eat()&#123;\t\t\t直接在                 console.log(我是静态方法);             &#125;         &#125;         let p1 = new Person(王先生);         Person.eat();         p1.say();\n12.5 ES6的继承在es5之前,我们想实现继承,需要这样:\n123456789101112131415161718192021例1:function Father(name) &#123;        this.name = name;    &#125;    Father.prototype.sayName = function () &#123;        console.log(this.name);    &#125;    function Son(name,age) &#123;        Father.call(this, name);        this.age = age;    &#125;    Son.prototype = new Father();    Son.prototype.constructor = Son;    Son.prototype.sayAge = function () &#123;        console.log(this.age);    &#125;    var son1 = new Son(儿子, 20);    son1.sayAge();  20    son1.sayName(); 儿子\n但是在es6中,只需要用到一个关键字 extends 就可以了,如下:\n1234567891011121314151617181920212223242526272829303132例2:\t\t\t\t\t\tclass Father&#123;                constructor(name,age)&#123;                    this.name = name;                &#125;                sayName()&#123;                    console.log(我是父类中的sayName方法:+this.name);                &#125;            &#125;            class Son extends Father&#123;                constructor(name,age)&#123;                super(name);        相当于以前的：Father.call(this.name);                this.age = age;     添加son自身的属性                &#125;                sayAge()&#123;           添加son独有的方法                    console.log(this.age);                &#125;                sayName()&#123;                    console.log(我是子类中的sayName方法:+this.name);                 super.sayName();    也可以调用父类中的sayName方法,而且这里面的this指代的是子类                &#125;            &#125;            let son1 = new Son(王先生,15);            son1.sayName();            son1.sayAge();            console.log(son1 instanceof Son);            console.log(son1 instanceof Father);\t\t\t=&gt;我是子类中的sayName方法:王先生            =&gt;我是父类中的sayName方法:王先生            =&gt;true            =&gt;true\n\n这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。\n\n这里的super有几点要注意的:\n1.super方法只有在派生类中使用(使用extents的类或者函数),否则就会报错\n2.必须在构造函数的起始位置调用super方法.\n3.在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。\n1234561. 在构造函数语法中,使用super就相当于在给对象初始化属性,就是以前的构造函数借调  super( )调用父类的构造函数的时候不要加点,而且要放在构造函数的第一行,因为它会初始化 this.2. 在子类中可以覆写(override)父类的方法, 而且也可以在子类的方法中, 使用 super.父类方法()来调用父类的方法, 而且这个时候父类方法中的 this 其实指的是子类的对象3. 使用类的的时候, 静态方法也可以继承\n","tags":["前端进阶","ES6"],"path":"2017/03/09/webNotes/advanced/JavaScript/es6/","external_link":""},{"title":"vue-cli","date":"2017-03-09T12:14:15.000Z","content":"第一章: 项目运行1.webpack.build.js进行所有的js文件打包\n​    文件夹名build\n​    其中webpack.base.conf中的module.exports={}:\n12345678910111213141516module.exports = &#123;  entry: &#123;      入口文件    app: &apos;.srcmain.js&apos;    &#125;,  output: &#123;    path: config.build.assetsRoot,    filename: &apos;[name].js&apos;,      打包以后输出的文件名称,(输出配置)  &#125;,  module: &#123;\t\t\t\t\t用以解析模块的一些规则    rules: &#123;          &#125;  &#125;,  resolve: &#123;\t\t\t\t读取文件的一些配置      &#125;\n2.利用webpack.config.js来进行命令的简化处理\n​    这个文件就是webpack的默认配置文件,也就是文件夹名为config\n3.利用webpack打包css\n​    webpack本身不支持css打包. 依赖于style-loader和css-loader(使用webpack下载下来的文件中自带)\n4.安装less-loader(需手动安装)\n1npm i less less-loader --save-dev\n5.安装vuex\n1npm install vuex --save\n6.安装axios\n​    用到http时需要安装axios\n1npm install --save axios\n项目的入口文件是main.js,然后在main.js中依赖app.vue.app.vue中又依赖了hello.vue这个组件。\n一个标准组件的构成就是由template,script,style这三个标签构成，\n如果要在app.vue中使用hello.vue这个组件的话，需要把hello定义为app的子组件\n12345678import Hello from &apos;.componentsHello&apos;export default &#123;  name: &apos;app&apos;,  components: &#123;    Hello  &#125;&#125;\n第二章: router根据不同的地址跳转到不同的页面，提到前端路由就不得不提SPA单页应用，单页面应用就是视觉感觉是页面的切换，但页面其实一直没有刷新，我们是通过js来让页面看起来好像是跳转到了另外一个页面。\n2.1 基本使用\n在终端中进入到你的项目目录: cd 项目路径\n在项目目录下执行：npm install vue-router --save。后面加上--save的原因是要将vue-router添加到package.json的依赖中\n然后在可以项目中引入vue-router，比如在main.js中\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243 The Vue build version to load with the `import` command (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from vueimport App from .App 1.引入vue-router及组件import Router from vue-routerimport Hello from .componentsHelloimport Orange from .componentsOrangeimport Banana from .componentsBanana 2.使用vue-routerVue.use(Router) 3.实例化router这个类let router = new Router(&#123;     5.做映射,什么样的地址,跳转到什么样的页面    routes:[        &#123;               path:路径            path:,               跳转的组件            component:Hello        &#125;,        &#123;            path:orange,            component:Orange        &#125;,        &#123;            path:banana,            component:Banana        &#125;    ]&#125;)Vue.config.productionTip = false* eslint-disable no-new *new Vue(&#123;  el: #app,   4.在vue实例中使用router  router:router,  template: &lt;App&gt;,  components: &#123; App &#125;&#125;)\n然后在app.vue中指定路由的位置，使用router-view这个组件\n2.2 案例1:1.在vue文件夹的目录下,执行\n1$ vue init webpack route_demo\n先不安装router\n2.进入到route_demo文件夹下,执行\n1$ npm i\n安装依赖\n3.进入到route_demo文件夹下,执行\n–save保存到生产环境\n–dev保存到开发环境\n1npm i vue-router@^2 --save\n文件夹下会多出\n4.项目中引入vue-router\n在main.js中:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 The Vue build version to load with the `import` command (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from vueimport App from .App 引入helloword组件import Hello from @componentsHelloWorld 引入orange组件import Orange from @componentsOrange 引入banana组件import Banana from @componentsBanana 1.引入vue-routerimport Router from vue-router 2.在vue调用(使用)vue-routerVue.use(Router) 3.初始化(实例化)vue-routervar router = new Router(&#123;   配置表   将路由模式切换为html5的history模式,可以将地址栏中的#去掉  mode: history,   5.配置路由,做映射，什么样的地址，跳转到什么的页面(组件)  routes: [    &#123;      path: ,       component-&gt;ng中的templateUrl      component: Hello    &#125;,    &#123;      path: orange,      name: orange,      component: Orange    &#125;,    &#123;      path: banana,      name: banana,      component: Banana    &#125;  ]&#125;)Vue.config.productionTip = false* eslint-disable no-new *new Vue(&#123;  el: #app,   4.在vue实例中使用router,键名必须为router  router,  template: &lt;App&gt;,  components: &#123; App &#125;&#125;)\n5.在components文件夹中创建orange和banana俩个组件\n如在orange中:\n12345678910111213141516171819&lt;template&gt;  &lt;div class=orange&gt;    &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;h1&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      title: 橙子    &#125;  &#125;&#125;&lt;script&gt;&lt;style scoped&gt;.orange&#123;  color: orange;&#125;&lt;style&gt;\n6.路由中的跳转(3种方式)\n1.在要实现路由的地方使用&lt;router-link to=&quot;path&quot;&gt; &lt;router-link&gt;\n2.在要实现路由的地方使用&lt;router-link :to=&quot;{path:path}&quot;&gt;&lt;router-link&gt;\n3.在要实现路由的地方使用&lt;router-link :to=&quot;{name: name}&quot;&gt;&lt;router-link&gt;(需要在设置路由的地方加上name属性)\n1234567891011121314151617181920212223242526272829&lt;template&gt;  &lt;div id=app&gt;    &lt;img src=.assetslogo.png&gt;    &lt;router-link to=&gt;首页&lt;router-link&gt;    &lt;router-link to=orange&gt;orange&lt;router-link&gt;\t to中填入的是你在main.js的path设置的路径    &lt;--&lt;router-link :to=&#123;path:orange&#125;&gt;orange&lt;router-link&gt;--&gt;    &lt;--&lt;router-link :to=&#123;name: orange&#125;&gt;orange&lt;router-link&gt;--&gt;    &lt;router-link to=banana&gt;banana&lt;router-link&gt;    &lt;router-view&gt;&lt;router-view&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;export default &#123;  name: app,  components: &#123;  &#125;&#125;&lt;script&gt;&lt;style&gt;#app &#123;  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;style&gt;\n2.3 通过js控制跳转在上面的案例中,我们是通过router-link标签自动转换为a标签来实现页面的跳转的,也可以通过js给任何元素添加事件来实现跳转:\n1.给要跳转的元素添加事件:\n1&lt;button @click=&quot;toBanana&quot;&gt;点击跳转&lt;button&gt;\n2.编写js代码\n1234567891011121314&lt;script&gt;export default &#123;  name: &apos;app&apos;,  components: &#123;  &#125;,  methods: &#123;    toBanana () &#123;       this.$router.push(&apos;banana&apos;)\t       this.$router.push(&#123;path: &apos;banana&apos;&#125;)      this.$router.push(&#123;name: &apos;banana&apos;&#125;)    &#125;  &#125;&#125;&lt;script&gt;\n2.4 路由器嵌套有时候在路由器的内部需要嵌套路由器,\n1. 案例比如在上面例子中的Orange.vue需要添加一个RedOrange.vue子路由器\n1.编写RedOrange.vue\n12345678910111213141516171819&lt;template&gt;  &lt;div class=redOrange&gt;    &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;h1&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      title: 红色橙子    &#125;  &#125;&#125;&lt;script&gt;&lt;style scoped&gt;.redOrange&#123;  color: red;&#125;&lt;style&gt;\n2.在配置orange路由的地方添加children属性,然后red作为它的子路由\n123456789101112131415161718192021222324252627 引入orange组件import Orange from &apos;@componentsOrange&apos;1. 引入redOrange import RedOrange from &apos;@componentsRedOrange&apos;var router = new Router(&#123;\t...  routes: [    &#123;      path: &apos;&apos;,       component-&gt;ng中的templateUrl      component: Hello    &#125;,    &#123;      path: &apos;orange&apos;,      name: &apos;orange&apos;,      component: Orange,      children: [\t\t 2. 配置red        &#123;          path:&apos;red&apos;,\t这里的path不用加&apos;&apos;,因为以  开头的嵌套路径会被当作根路径          component: RedOrange        &#125;      ]    &#125;  ]&#125;)\n3.在需要显示子路由的地方添加router-view(这里再Orange.vue中显示,所以在上面的Orange.vue中添加)\n1234567891011121314151617181920&lt;template&gt;  &lt;div class=orange&gt;    &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;h1&gt;\t    &lt;router-view&gt;&lt;router-view&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      title: 橙子    &#125;  &#125;&#125;&lt;script&gt;&lt;style scoped&gt;.orange&#123;  color: orange;&#125;&lt;style&gt;\n4.在要触发跳转至RedOrange的地方,添加&lt;router-link to=&quot;&quot;&gt;,(这里直接在主页中添加)\n12345678910111213141516171819202122232425262728293031323334&lt;template&gt;  &lt;div id=app&gt;    &lt;img src=.assetslogo.png&gt;    &lt;router-link to=&gt;首页&lt;router-link&gt;    &lt;router-link :to=&#123;name:orange&#125;&gt;orange&lt;router-link&gt;    &lt;router-link to=banana&gt;banana&lt;router-link&gt;    &lt;button @click=getBanana&gt;点击按钮到banana&lt;button&gt;    &lt;router-link :to=&#123;path:orangered&#125;&gt;redOrange&lt;router-link&gt;\t\t    &lt;router-view&gt;&lt;router-view&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;export default &#123;  name: app,  components: &#123;  &#125;,  methods: &#123;    getBanana () &#123;        this.$router.push(banana)    &#125;  &#125;&#125;&lt;script&gt;&lt;style&gt;#app &#123;  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;style&gt;\n注:点击redOrange跳转,可以看到地址栏变为了:http:localhost:8080orangered\n2.5 重定向1234&#123;  path:&apos;&apos;,  redirect:&apos;orange&apos;&#125;\nredirect：重定向地址\n2.6 路由配合动画我们在进行路由切换的时候,可以直接就在&lt;router-view&gt;&lt;router-view&gt;外面包上transition标签\n123&lt;transition name=fade&gt;     &lt;router-view class=view&gt;&lt;router-view&gt;   &lt;transition&gt;\n123456789.fade-enter-active, .fade-leave-active&#123;  transition: all 1s;&#125;.fade-enter, .fade-leave&#123;  opacity: 0;&#125;.view&#123;  position: absolute;&#125;\n使用animation.css\n1.使用CDN加速,\n在index.html页面引入\n1&lt;link href=https:cdn.jsdelivr.netnpmanimate.css@3.5.1 rel=stylesheet type=textcss&gt;\n2.将animation.css文件放在srcassets目录下\n​    1.并在index.html页面引入\n1&lt;link href=.srcassetsanimation.css rel=stylesheet type=textcss&gt;\n​    2.或者在你要用到它的地方使用import调用\n123&lt;style&gt;\t@import url(); &lt;style&gt;\n第三章: vuex\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n什么情况下使用vuex?\n虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\n3.1 安装vuex在你项目文件目录下使用命令行:\n1npm install vuex --save\n\n下载完后可以在package.json中查看到:\n123456&gt; &quot;dependencies&quot;: &#123;&gt;     &quot;vue&quot;: &quot;^2.4.2&quot;,&gt;     &quot;vue-router&quot;: &quot;^2.7.0&quot;,&gt;     &quot;vuex&quot;: &quot;^3.0.0&quot;&gt;   &#125;,&gt;\n\n每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：\n\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n\n1.在src目录下创建文件夹store\n\n文件夹store中应该有\n123451. index.js2. actions.js3. getters.js4. mutations.js5. state.js\n\n2.在index.js中要确保引用了vuex:\nVuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：\n\n1234567891011121314151617引入vue及vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)import state from &apos;.state&apos;import actions from &apos;.actions&apos;import mutations from &apos;.mutations&apos;import getters from &apos;.getters&apos;export default new Vuex.Store(&#123;  state,  actions,  mutations,  getters&#125;)\n\n3.在main.js中要引用\n\n通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store访问到\n12345new Vue(&#123;  el: &apos;#app&apos;,  router,  store,&#125;)\n如想要获取store下的state中的count\n1let count = this.$store.state.count\n3.2 vuex基础vuex核心理念:\n\nState\nGetter\nMutation\nAction\nModule\n\n1. state单一状态树\n一般用于储存初始化的一些数据\n123456789101112131415161718192021222324export default &#123;   bannar  bannar: &#123;&#125;,   存储所有分类数据  classifys: [],   控制tabBar显示隐藏的  tabBarShow: true,   用户信息  userInfo: &#123;&#125;,   地址列表  sites: [],   所选城市  selectCity: ,   所选的地区  selectSite: ,   所选地区的坐标  location: &#123;&#125;,   购物车数据  carts: [],   控制购物车数量图标的动画  cartActive: false,   保存tabBar中cart标签的位置  cartPos: &#123;&#125;&#125;\n2. getters\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n\n也就是用于存储一些方法,这些方法用来返回需要计算的数据\n\n例如,存储了购物车中计算商品总数的方法\n123456789101112export default &#123;   获取购物车中的商品总数  cartsLen (state) &#123;    let result = 0    for (let i = 0; i &lt; state.carts.length; i++) &#123;      if (state.carts[i].selected) &#123;        result += state.carts[i].num      &#125;    &#125;    return result  &#125;&#125;\n3. mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation\nmutation必须同步执行!    \nVuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n1234567891011const store = new Vuex.Store(&#123;  state: &#123;    count: 1  &#125;,  mutations: &#123;    increment (state) &#123;       变更状态      state.count++    &#125;  &#125;&#125;)\n在上面的例子中,我们不能直接使用store.increment来调用函数,需要以相应的type调用store.commit方法:\n1store.commit(&apos;increment&apos;)\n你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：\n1234567 ...mutations: &#123;  increment (state, n) &#123;    state.count += n  &#125;&#125;store.commit(increment, 10)\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n123456789 ...mutations: &#123;  increment (state, payload) &#123;    state.count += payload.amount  &#125;&#125;store.commit(increment, &#123;  amount: 10&#125;)\n在实际中,会将mutations整合到一个js文件,并且每个要提交的函数都应该用大写命名,\n如 : 向购物车添加商品\n1234ADD_PRODUCT_NUM (state, product) &#123;  state.carts.push(product)&#125;,\n此函数会在action中定义\n4. actionAction 类似于 mutation，不同在于：\n\nAction 提交的是 mutation，而不是直接变更状态。\n\nAction 可以包含任意异步操作。\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters\n让我们来注册一个简单的 action：\n\n\n123456789101112131415const store = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    INCREMENT (state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    increment (context) &#123;      context.commit(INCREMENT)    &#125;  &#125;&#125;)\n\n实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）：\n\n12345actions: &#123;  increment (&#123; commit &#125;) &#123;\t将上面的context换为&#123;commit&#125;    commit(&apos;INCREMENT&apos;)  &#125;&#125;\n那么我们怎么调用increment这个方法呢(也就是mutations中的INCREMENT方法)\n\n1.Action 通过 store.dispatch 方法触发：\n12&gt; store.dispatch(increment)\t\t触发的就是Action中的increment方法&gt;\n\n\n2.在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发 action\n12&gt; this.$store.dispatch(&apos;increment&apos;)&gt;\n\n\n3.或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\n\n12345678910111213141516import &#123; mapActions &#125; from &apos;vuex&apos;export default &#123;   ...  methods: &#123;    ...mapActions([      &apos;increment&apos;,  将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`       `mapActions` 也支持载荷：      &apos;incrementBy&apos;  将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`    ]),    ...mapActions(&#123;      add: &apos;increment&apos;  将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`    &#125;)  &#125;&#125;\n乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：\n1234567actions: &#123;  incrementAsync (&#123; commit &#125;) &#123;    setTimeout(() =&gt; &#123;\t\t\t\t比如定时器这种异步操作      commit(INCREMENT)    &#125;, 1000)  &#125;&#125;\n\nActions 支持同样的载荷方式和对象方式进行分发：\n\n12345678910 以载荷形式分发store.dispatch(&apos;incrementAsync&apos;, &#123;  amount: 10&#125;) 以对象形式分发store.dispatch(&#123;  type: &apos;incrementAsync&apos;,  amount: 10&#125;)\n来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：\n12345678910111213141516actions: &#123;  checkout (&#123; commit, state &#125;, products) &#123;     把当前购物车的物品备份起来    const savedCartItems = [...state.cart.added]     发出结账请求，然后乐观地清空购物车    commit(types.CHECKOUT_REQUEST)     购物 API 接受一个成功回调和一个失败回调    shop.buyProducts(      products,       成功操作      () =&gt; commit(types.CHECKOUT_SUCCESS),       失败操作      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)    )  &#125;&#125;\n组合 Action\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：\n123store.dispatch(actionA).then(() =&gt; &#123;   ...&#125;)\n在另外一个 action 中也可以：\n12345678actions: &#123;   ...  actionB (&#123; dispatch, commit &#125;) &#123;    return dispatch(actionA).then(() =&gt; &#123;      commit(someOtherMutation)    &#125;)  &#125;&#125;\n5. module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n12345678910111213141516171819202122const moduleA = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const moduleB = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)store.state.a  -&gt; moduleA 的状态store.state.b  -&gt; moduleB 的状态\n模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。\n3.3 vuex项目结构Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\n应用层级的状态应该集中到单个 store 对象中。\n提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。\n异步逻辑都应该封装到 action 里面。\n\n只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n1234567891011121314├── index.html├── main.js├── api│   └── ... # 抽取出API请求├── components│   ├── App.vue│   └── ...└── store    ├── index.js          # 我们组装模块并导出 store 的地方    ├── actions.js        # 根级别的 action    ├── mutations.js      # 根级别的 mutation    └── modules        ├── cart.js       # 购物车模块        └── products.js   # 产品模块\n第四章: http相关4.1 promisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n####1. 基本语法:\n123456789101112131415161718192021function async(a, b) &#123;    resolve异步操作成功时调用    reject失败时调用  return new Promise (function (resolve, reject) &#123;        if(...) &#123;      reject(new Error(出错了));    &#125;    setTimout(function () &#123;      resolve(a+b)    &#125;, 1000)      &#125;)&#125;async(1, 2)\t.then(function (result) &#123;      console.log(第一次返回的值 + result)\t&#125;, function (error) &#123;      console.log(第一次的错误是 + error)\t&#125;)\n2. 传统的异步操作转promise传统写法：\n123456789101112131415function async(a,b,cb)&#123;    setTimeout(function ()&#123;        cb(a+b)    &#125;,200)&#125;    async(1,2,function (result)&#123;     延迟200ms后执行    if (result&gt;2)&#123;        async(result,2,function(result)&#123;            if (result&gt;4)&#123;                console.log(result)            &#125;        &#125;)    &#125;&#125;)\n\nes6-promise写法：\n\n1234567891011121314151617181920212223242526272829303132333435363738394041function async(a,b)&#123;    resolve异步操作成功时调用    reject失败时调用    return new Promise(function(resolve,reject)&#123;        if (typeof a !== number ||typeof b !== number)&#123;            reject(new Error(不是一个number));        &#125;        setTimeout(function ()&#123;            resolve(a+b);        &#125;,1000)    &#125;)&#125;不管是成功或者失败都会调用then这个方法然后接受两个函数作为参数，第一个是成功的*promise:更加优雅，逻辑更加清晰*async(1,a)    .then(function (result)&#123;        console.log(第一次返回的值+result)        if (result &gt; 2)&#123;            return async(result,2)        &#125;    &#125;,function (error)&#123;        console.log(第一次错误:+error)        return 5;    &#125;)    .then(function (result)&#123;        console.log(第二次返回的值+result)        if (result &gt; 4)&#123;            return async(result,2)        &#125;    &#125;)    .then(function (result)&#123;        console.log(第三次返回的值+result)    &#125;)    catch捕获错误    .catch(function(error)&#123;        console.log(第二次错误:+error)    &#125;)\n4.2  ES7的AsyncAwaitAsyncAwait应该是目前最简单的异步方案了\n案例1:\n要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。\n1234567891011121314151617181920function sleep (time) &#123;  return new Promise(function (resolve, reject)) &#123;    setTimeout(function () &#123;      resolve();    &#125;, time)  &#125;&#125; var start = async function () &#123; 在这里使用起来就像同步代码那样直观  console.log(start)  await sleep(3000)  console.log(end)&#125;start();async function start () &#123;  &#125;\n1=&gt; 控制台先输出start，稍等3秒后，输出了end。\n在申明start函数时,也可以这样写:\n123async function start () &#123;\t 表面这是一个async函数  &#125;\n1. 基本规则\n\nasync 表示这是一个async函数，await只能用在这个函数里面。\n​\n\nawait 表示在这里等待promise返回结果了，再继续执行。\n​\n\nawait 后面跟着的应该是一个promise对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…）\n\n\n\n2. 获得返回值await等待的虽然是promise对象，但不必写.then(..)，直接可以得到返回值。\n123456789101112131415var sleep = function (time) &#123;    return new Promise(function (resolve, reject) &#123;        setTimeout(function () &#123;             返回 ‘ok’            resolve(ok);        &#125;, time);    &#125;)&#125;;var start = async function () &#123;  \tconsole.log(start)    let result = await sleep(1000);\t直接用一个变量来盛放返回值    console.log(result);  收到 ‘ok’&#125;;start();\n12start=&gt;1秒后输出ok\n3. 捕捉错误既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。\n1234567891011121314151617181920var sleep = function (time) &#123;    return new Promise(function (resolve, reject) &#123;        setTimeout(function () &#123;             模拟出错了，返回 ‘error’            reject(error);        &#125;, time);    &#125;)&#125;;var start = async function () &#123;    try &#123;        console.log(start);        await sleep(3000);  这里得到了一个返回错误                 所以以下代码不会被执行了        console.log(end);    &#125; catch (err) &#123;        console.log(err);  这里捕捉到错误 `error`    &#125;&#125;;\n4. 循环多个awaitawait看起来就像是同步代码，所以可以理所当然的写在for循环里，不必担心以往需要闭包才能解决的问题。\n123456789101112131415var sleep = function (time) &#123;    return new Promise(function (resolve, reject) &#123;        setTimeout(function () &#123;             返回 ‘ok’            resolve(ok);        &#125;, time);    &#125;)&#125;;var start = async function () &#123;    for (var i = 1; i &lt;= 10; i++) &#123;        console.log(`当前是第$&#123;i&#125;次等待..`);        await sleep(1000);    &#125;&#125;;\n123456当前是第1次等待..当前是第2次等待..当前是第3次等待..当前是第4次等待.....当前是第10次等待..\n值得注意的是，await必须在async函数的上下文中的。\n4.3 vue-resource1. 安装使用vue-resource1.进入项目目录后安装vue-resource\n1npm install vue-resource --save\n2.在要用的地方引入vue-resource,比如在main.js中    \n1234import Resource from vue-resource使用vue-resoureceVue.use(Resource)\n3.就可以开始使用this.$http来调用对应的方法\n####2. 基本语法:\n1234567 global Vue object\t(全局 Vue 对象)Vue.http.get(&apos;someUrl&apos;, [options]).then(successCallback, errorCallback);Vue.http.post(&apos;someUrl&apos;, [body], [options]).then(successCallback, errorCallback);in a Vue instance\t\t(Vue 实例)this.$http.get(&apos;someUrl&apos;, [options]).then(successCallback, errorCallback);this.$http.post(&apos;someUrl&apos;, [body], [options]).then(successCallback, errorCallback);\n比如调用get和post请求：\n12345678910111213141.get:created () &#123;\tcreated是vue中的生命周期中的在某个组件一创建时执行的代码  this.$http.get(db.json)\t\t获取数据  \t.then(function (result) &#123;      console.log(result)  &#125;)&#125;  2.post:created () &#123;  this.$http.post(db.json,&#123;user:wang&#125;)\t\t直接给db.json添加一条新数据    .then(function (data)&#123;    console.log(data)  &#125;)&#125;\n3. http的方法\nget(url, [options])    获取数据\nhead(url, [options])\ndelete(url, [options]) 删除数据\njsonp(url, [options])\npost(url, [body], [options]) 添加数据\nput(url, [body], [options]) 更改数据\npatch(url, [body], [options])\n\n1234567891011121314151617181920&#123;   POST someUrl  this.$http.post(someUrl, &#123;foo: bar&#125;).then(response =&gt; &#123;     get status    response.status;     get status text    response.statusText;     get Expires header    response.headers.get(Expires);     get body data    this.someData = response.body;  &#125;, response =&gt; &#123;     error callback  &#125;);&#125;\n4. get1. 属性值(Filter)    \n使用 . 操作对象属性值\n123456789getData () &#123;      this.$http.get(&apos;http:localhost:8081products2&apos;) 获取products数组下id为2的对象      this.$http.get(&apos;http:localhost:8081products?name.length=3&apos;)获取products数组下name长度为3的对象,并整合为一个数组      this.$http.get(&apos;http:localhost:8081products?name.length=3&amp;description=3&apos;)获取products数组下name长度为3的对象,并整合为一个数组              .then(res =&gt; &#123;          console.log(res.body)        &#125;)    &#125;,\n2. 分割(Slice)\n使用 _start 和 _end 或者 _limit (response中会包含 X-Total-Count)来获取对应的数据\n123456id从3开始到6结束(不包过3)this.$http.get(&apos;http:localhost:8081products?_start=3&amp;_end=6&apos;)id : 4 5 6id从3开始获取5个(不包过3)this.$http.get(&apos;http:localhost:8081products?_start=3&amp;_limit=5&apos;)id : 4 5 6 7 8\n3. 排序(Sort)\n使用 _sort 和 _order (默认使用升序(ASC))\n12id按降序排列this.$http.get(&apos;http:localhost:8081products?_sort=id&amp;_order=DESC&apos;)\n4. 运算符(Operators)    \n使用 _gte 或 _lte 选取一个范围\n123 选取浏览量在2000-2500之间的新闻GET news?views_gte=2000&amp;views_lte=2500\n使用 _ne 排除一个值\n123 选择tag属性不是 &quot;国际新闻&quot; 的分类GET news?tag_ne=国际新闻\n使用 _like 进行模糊查找 (支持正则表达式)\n123 查找title中含有 &quot;前端&quot; 字样的新闻 GET news?title_like=前端\n5. 全文检索(Full-text search)\n上面的_like是在title中查找的,使用 q，在对象全部value中遍历查找包含指定值的数据\n123 查找新闻全部字段包含 &quot;强拆&quot; 字样的数据GET news?q=强拆\n###4.4 axios\n上面介绍的vue-resource是Vue.js的一款插件,它可以通过XMLHttpRequest或JSONP发起请求并处理响应\n但在实际应用中,vue-resource已经被摈弃了,而是使用axios\n简介，在vue升级到2.0后，官方就不再更新vue-resourece，vue官网也不再推荐vue-resource作为推荐的HTTP库.转而推荐使用：axios。\n1. 使用axios1.首先肯定是安装并添加到生产环节的依赖\n1cnpm install axios --save\n2.在main.js中引入axios\n然后因为axios并不是vue的插件所以不能用Vue.use,但可以将它添加到Vue的原型中\n123import axios from &apos;axios&apos;将axios添加到vue的原型中Vue.prototype.$http = axios\n这样我们也可以像调用vue-resourece一样在组件中调用axios的方法.\n2. 利用axios跨域axios也提供了办法进行跨域\n设置代理:    \n首先按上面的步骤下载配置axios,然后在configindex.js中的设置proxyTable的值为：\n123456789proxyTable: &#123;      api: &#123;        target: http:127.0.0.1:8081,        changeOrigin: true,        pathRewrite: &#123;          ^api:         &#125;      &#125;    &#125;\n其中 ‘api’ 为匹配项，target 为被请求的地址\n因为在 ajax 的 url 中加了前缀 ‘api’，而原本的接口是没有这个前缀的\n所以需要通过 pathRewrite 来重写地址，将前缀 ‘api’ 转为 ‘‘\n如果本身的接口地址就有 ‘api’ 这种通用前缀，就可以把 pathRewrite 删掉\n案例:\n获取豆瓣网的书本信息\n如果我们直接用:\n123456getDouban () &#123;      this.$http.get(https:api.douban.comv2book1220562)\t直接请求这个地址        .then(function (data)&#123;          console.log(data)        &#125;)    &#125;\n会报出请求失败:\n1localhost:1 Failed to load https:api.douban.comv2book1220562: No Access-Control-Allow-Origin header is present on the requested resource. Origin http:localhost:8080 is therefore not allowed access.\n所以这时候我们可以使用代理来进行获取数据\n1.按上面的步骤安装配置好axios\n2.在configindex.js中的设置proxyTable的值为:\n123456789proxyTable: &#123;      api: &#123;        target: https:api.douban.com,\t豆瓣网的接口        changeOrigin: true,        pathRewrite: &#123;          ^api:         &#125;      &#125;    &#125;,\n3.在App.vue中设计一个按钮并添加方法:\n1234567891011121314151617181920&lt;template&gt;  &lt;div id=app&gt;\t&lt;button @click=getDouban&gt;获取豆瓣服务器的数据&lt;button&gt;  &lt;div&gt;&lt;template&gt;&lt;script&gt;export default &#123;  name: app,  methods: &#123;    getDouban () &#123;      this.$http.get(https:api.douban.comv2book1220562)        .then(function (data)&#123;          console.log(data)        &#125;)    &#125;  &#125;&#125;&lt;script&gt;&lt;style&gt;&lt;style&gt;\n点击按钮,可以获取到图书的信息打印在控制台中.\n第五章: json-server插件在前后端分离的这种工作模式下，分工明确，各司其职。前端负责展示数据，后端提供数据。然而，在这种过程中对于接口的规范 需要提前制定好。例如根据规范提前模拟数据，这个时候就比较麻烦的。JsonServer这个比较NB了,它可以快速搭建服务端环境，创建json文件，便于调用。下面是使用过程：\n5.1 使用json-server1.安装json-server \n1npm install  json-server --save\n2.修改dev-server.js\n添加到server = app.listen(port)之前\n1234567891011const jsonServer = require(&apos;json-server&apos;)const aipServer = jsonServer.create()const apiRouter = jsonServer.router(&apos;db.json&apos;) 此处的db.json是与package.json在同一目录下const middlewares = jsonServer.defaults()aipServer.use(middlewares)aipServer.use(apiRouter)aipServer.listen(port + 1, () =&gt; &#123;  console.log(&apos;JSON Server is running&apos;)&#125;)\n3.在根目录下创建并修改一个db.json文件 (如果你已经有了db.json,则省略这一步)\n12345678910111213141516171819&#123;    &quot;getList&quot;:[        &#123;            &quot;id&quot;:1,            &quot;title&quot;:&quot;title1&quot;,            &quot;content&quot;:&quot;content1&quot;        &#125;,        &#123;            &quot;id&quot;:2,            &quot;title&quot;:&quot;title2&quot;,            &quot;content&quot;:&quot;content2&quot;        &#125;,        &#123;            &quot;id&quot;:3,            &quot;title&quot;:&quot;title3&quot;,            &quot;content&quot;:&quot;content3&quot;        &#125;    ]&#125;\n4.然后CD到项目文件夹下 cd..\n1json-server --watch data.json\n5.在浏览器打开网址验证json-server是否启动成功在浏览器打开以下网址：http:localhost:3000 (默认端口号:3000),你也可以使用如下命令修改它\n成功打开地址后证明json-server安装成功，打开地址后可以看到db.json中的接口方法“getList”，点击“getList”，返回getList数据，证明可以成功调用mock数据。\n\n使用代理访问mock数据我们在项目里访问什么路径会到json-server，这需要我们做一个代理。4.1 修改 config文件夹中的index.js修改index.js文件，在 dev 对象中的 proxyTable 设置以下代理对象\n\n123456789&#123;     &apos;api&apos;: &#123;         target: &apos;http:localhost:8081&apos;,         changeOrigin: true,         pathRewrite: &#123;             &apos;^api&apos;: &apos;&apos;         &#125;     &#125; &#125;\n注:数据的访问端口不能和你项目的启动端口号相同!!!\n否则就会报出一个:\n端口号已经被使用的错误\n注: 项目文件的名字也不能为json-server,否则也会报错\n###5.2 修改端口号\n默认端口号:3000,你也可以使用如下命令修改它\n1$ json-server --watch db.json --port 3004\n5.3 设置常用路由地址当我们在进行http请求json-server数据的时候,有一些常用的路由地址,我们可以用一个json文件来盛放它\n1.在根目录下,创建一个routes.json的文件,并写上你常用的路由地址:\n123456&#123;  api*: $1,  :resource:idshow: :resource:id,  posts:category: posts?category=:category,  articles?id=:id: posts:id&#125;\n2.将json-server和你的routes.json关联起来:\n使用以下命令:\n1json-server db.json --routes routes.json\n3.现在你可以使用以下命令来直接访问资源了\n12345apiposts # → postsapiposts1  # → posts1posts1show # → posts1postsjavascript # → posts?category=javascriptarticles?id=1 # → posts1\n5.4 json-server的关系图谱json-server是非常好用的一款模拟REST API的工具,文档也很详细和全面. 详情：json-server 而其中的关系图谱是它非常强大的一个功能，可以非常方便实现多个路由之间关联数据的获取。\n案例:    \n官网上对于关系图谱的案例非常好，我这里在它示例的基础上稍以改进，进行说明，首先我这里编写了一个原始数据,db.json:\n1234567891011&#123;  &quot;posts&quot;: [    &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;post的第一个title&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;,    &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;post的第二个title&quot;, &quot;author&quot;: &quot;tangcaiye&quot; &#125;  ],  &quot;comments&quot;: [    &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment1111&quot;, &quot;postId&quot;: 2 &#125;,    &#123; &quot;id&quot;: 2, &quot;body&quot;: &quot;some comment2222&quot;, &quot;postId&quot;: 1 &#125;  ],  &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125;\n这里对这个db.json数据内容解释一下： 这个json文件中posts跟comments是有关联的，他们的关系通过的就是comments下postId属性，postId对应的就是posts的id。 比如comments下postId:2的对象关联的就是posts下的{ &quot;id&quot;: 2, &quot;title&quot;: &quot;post的第二个title&quot;, &quot;author&quot;: &quot;tangcaiye&quot; }\n####1. _embed    \njson-server中的_embed就是用来获取包含下级资源的数据. 比如我json-server服务器的端口号是8081,然后我的请求路径是http:localhost:8081posts2?_embed=comments 这个路径获取的就是posts下的id为2的数据和它关联的comments的数据：{ &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment1111&quot;, &quot;postId&quot;: 2 }输出结果为：\n123456789101112&#123;  &quot;id&quot;: 2,  &quot;title&quot;: &quot;post的第二个title&quot;,  &quot;author&quot;: &quot;tangcaiye&quot;,  &quot;comments&quot;: [    &#123;      &quot;id&quot;: 1,      &quot;body&quot;: &quot;some comment1111&quot;,      &quot;postId&quot;: 2    &#125;  ]&#125;\n####2. _expand\n如果理解了_embed那么_expand它也就很轻松了,_expand获取的是包含上级资源的数据： 路径：http:localhost:8081comments2?_expand=post 上面这个路径获取的就是comments下id为2的数据和它关联的上级资源post，也就是posts下的： { &quot;id&quot;: 1, &quot;title&quot;: &quot;post的第一个title&quot;, &quot;author&quot;: &quot;typicode&quot; } 输出结果：\n12345678910&#123;  &quot;id&quot;: 2,  &quot;body&quot;: &quot;some comment2222&quot;,  &quot;postId&quot;: 1,  &quot;post&quot;: &#123;    &quot;id&quot;: 1,    &quot;title&quot;: &quot;post的第一个title&quot;,    &quot;author&quot;: &quot;typicode&quot;  &#125;&#125;\n3. 只获取下级资源有时候我们可能想只获取下级资源，可以通过： 路径：http:localhost:8081posts2comments 上面这个路径就是获取posts的id:2所关联的comments数据： 返回结果：\n1234567[  &#123;    &quot;id&quot;: 1,    &quot;body&quot;: &quot;some comment1111&quot;,    &quot;postId&quot;: 2  &#125;]\n但因为jsonserver服务器的端口号跟我们的服务器端口不一样，也就是跨域了，所以可以在vue-cli中设置代理:\n####4.总结\n1234561.获取下级资源(从post =&gt; postId)http:localhost:8081posts2?_embed=comments2.获取上级资源(从postId =&gt; post)http:localhost:8081comments2?_expand=post3.只获取下级资源http:localhost:8081posts2comments\n第六章: mockjs6.1 基本使用1.安装mockjs\n1npm i mockjs --save\n2.使用mockjs\n在根目录下创建mock.js并编写\n12345678910var Mock = require(mockjs)var data = Mock.mock(&#123;     属性 list 的值是一个数组，其中含有 1 到 10 个元素    list|1-10: [&#123;         属性 id 是一个自增数，起始值为 1，每次增 1        id|+1: 1    &#125;]&#125;) 输出结果console.log(JSON.stringify(data, null, 4))\n3.由于Mock.js是插件,为了让人能看懂,最好在package.js中的scripts写入:\n1&quot;mock&quot;: &quot;node mock.js&quot;\n6.2 mockjs配合fs写入数据在根目录下创建mock.js并编写:\n123456789101112131415161718192021222324252627282930 使用 Mockvar Mock = require(mockjs)var fs = require(fs)var data = Mock.mock(&#123;  list|1-10 数组元素个数随机范围， id|+2 属性值递增, age|20-30数值随机范围   test|3.2-5 3.xx-3.xxxxx 整数位3，小数位位数范围为2-5  yourname|2-4: alice- 重复字符串的次数范围2-4  常规真实数据格式，@name @color @url @first @last @image  list|1-10: [&#123;id|+2: 1 , age|20-30: 100&#125;],  name: @name,  color: @color,  url: @url,  email: @email,  friends|3: [&#123;name: @name&#125;],  price|10-20.1-4: 11,  cost|10-20.3: 11,  test|3.2-5: 52,  yourname|2-4: alice-,  img: @image(200x100,@color,tangcaiye),  txt: @cword(3),  cname: @cname  &#125;); console.log(JSON.stringify(data, null, 2)); 写入到db.jsonfs.writeFile(db.json, JSON.stringify(data, null, 2),  function(err) &#123;  if (err) &#123;      return console.error(err);  &#125;  console.log(数据写入成功！);&#125;);\ndb.json不需要我们创建,后台会自动生成一个db.json文件\n执行:\n1node mockjs\n可以看到控制台输出”数据写入成功!”,此时我们的文件夹下多了一个db.json文件,并且其中的数据已经写好\n第七章: json+mockjs+http案例1.创建一个webpack,名为demo\n12$ vue init webpack demovue-router   Y\n2.依次使用指令\n123npm install vue-resource --savenpm install  json-server --savenpm i mockjs --save\n3.在main.js引入vue-resource    \n`\n","tags":["vue","前端入门"],"path":"2017/03/09/webNotes/primary/Vue/vue-cli/","external_link":""},{"title":"9012年了你还在用单色图标？(iconfont多色图标详解)","date":"2019-07-03T13:19:15.000Z","content":"前言记录iconfont的三种使用方式多色图标出来已经很久了，现在才拿出来说貌似有点过时…但为了方便自己以后知道怎么使用，也为了让更多刚入门的新手熟悉iconfont，还是决定写一篇比较详细的文章来记录它的使用方式。本文主要是参考花叔的文章：手摸手，带你优雅的使用 icon\n前期准备在iconfont)官网上创建一个自己的账号，并创建一个项目。在官网上挑选响应的图标添加进项目中。比如我这里有一个名为vuepress-bolg的项目，添加了一个github的图标。\nunicode最基础的一种使用方式，就是使用unicode。它的主要优点是：\n\n兼容性最好，支持ie6+\n支持按字体的方式去动态调整图标大小，颜色等等但是缺点也很明显：\n不支持多色图标\n在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对文字的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难第一步在你项目的css中引入字体如果你的项目是使用像vue这样的前端框架开发的话，你可以在公共的css中引入它：比如我的vue项目下有一个common.css:12345678910* common.css *@font-face &#123;  font-family: iconfont;  * project id 872514 *  src: url(at.alicdn.comtfont_872514_urq1z9ughp.eot);  src: url(at.alicdn.comtfont_872514_urq1z9ughp.eot?#iefix) format(embedded-opentype),  url(at.alicdn.comtfont_872514_urq1z9ughp.woff) format(woff),  url(at.alicdn.comtfont_872514_urq1z9ughp.ttf) format(truetype),  url(at.alicdn.comtfont_872514_urq1z9ughp.svg#iconfont) format(svg);&#125;\n\n\n注：上面的内容不是复制我的，而是复制你在iconfont项目上Unicode下的内容。这段代码的作用是远程的引入iconfont  字体。你可以不需要下载到本地。第二步定义字体将字体引入到了项目中的话，你需要定一个类，让它的字体类型为iconfont：123456789101112131415161718* common.css *@font-face &#123;  font-family: iconfont;  * project id 872514 *  src: url(at.alicdn.comtfont_872514_urq1z9ughp.eot);  src: url(at.alicdn.comtfont_872514_urq1z9ughp.eot?#iefix) format(embedded-opentype),  url(at.alicdn.comtfont_872514_urq1z9ughp.woff) format(woff),  url(at.alicdn.comtfont_872514_urq1z9ughp.ttf) format(truetype),  url(at.alicdn.comtfont_872514_urq1z9ughp.svg#iconfont) format(svg);&#125;.icon-online &#123; * 定义一个类 *  font-family:iconfont !important;  font-size:16px;  font-style:normal;  -webkit-font-smoothing: antialiased;  -webkit-text-stroke-width: 0.2px;  -moz-osx-font-smoothing: grayscale;&#125;\n由于我的字体是远程引入的，所以这里我就取名为icon-online，当然你也可以使用其它的命名。第三步页面上使用unicode1&lt;i class=&quot;icon-online&quot;&gt;&amp;#xe68c;&lt;i&gt;\n创建一个i标签，然后给它设置class，之后在标签中写上你要使用的字体的代码。这样在页面上显示的就是你在对应的图标啦。可以看到上面的这种unicode有一个很大的弊端，就是你看到代码里的这串&amp;#xe68c;，根本不知道它是个什么图标，需要打开iconfont在你的项目上找对应的代码才知道。所以有了另一种font-class的方式。\nfont-class第二种方式就是使用font-class它的优点是：\n\n兼容性良好，支持ie8+\n相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。第一步找到iconfont项目下的Font class,并复制它：然后在css中引用：12345678910111213141516171819* common.css *@import at.alicdn.comtfont_872514_urq1z9ughp.css;@font-face &#123;  font-family: iconfont;  * project id 872514 *  src: url(at.alicdn.comtfont_872514_urq1z9ughp.eot);  src: url(at.alicdn.comtfont_872514_urq1z9ughp.eot?#iefix) format(embedded-opentype),  url(at.alicdn.comtfont_872514_urq1z9ughp.woff) format(woff),  url(at.alicdn.comtfont_872514_urq1z9ughp.ttf) format(truetype),  url(at.alicdn.comtfont_872514_urq1z9ughp.svg#iconfont) format(svg);&#125;.icon-online &#123; * 定义一个类 *  font-family:iconfont !important;  font-size:16px;  font-style:normal;  -webkit-font-smoothing: antialiased;  -webkit-text-stroke-width: 0.2px;  -moz-osx-font-smoothing: grayscale;&#125;\n\n\n第二步然后你在使用的时候就可以将unicode的方式改为font-class啦：1&lt;i class=&quot;icon-online icon-github&quot;&gt;&lt;i&gt;\n注意⚠️：不过你的前端项目要是用到了多组iconfont，一定要主要命名空间的问题。\n不管是unicode还是font-class都只支持单色的图标，设置了iconfont的i标签其实就相当于一个字了，也就是可以根据color来控制它的字体颜色。但是你并不能使用多色。\nsymbol随着IE慢慢的退出历史舞台，svg-icon使用形式慢慢成为主流和推荐的方法。它主要有一下几个优点：\n\n支持多色图标了，不再受单色限制。\n支持像字体那样通过font-size,color来调整样式。\n支持 ie9+\n可利用CSS实现动画。\n减少HTTP请求。\n矢量，缩放不失真\n可以很精细的控制SVG图标的每一部分使用方式：第一步引入js引入的方式有两种：\n\n\n在iconfont的项目里，点击下载至本地，它会把这个项目相关的字体文件都下载下来。找到下载下来里面的iconfont.js文件，把它拷贝到你的前端项目里(只需要拷贝这一个文件就可以了)，然后在前端代码里引用这个js:\n1&lt;script src=&quot;.iconfont.js&quot;&gt;&lt;script&gt;\n\n远程引入，不需要下载这个iconfont.js，而是直接用iconfont项目里生成的那个地址：\n1&lt;script src=&quot;at.alicdn.comtfont_872514_urq1z9ughp.js&quot;&gt;&lt;script&gt;\n\n\n第二步设置通用的类名1234567* common.css *.icon &#123;       width: 1em; height: 1em;       vertical-align: -0.15em;       fill: currentColor;       overflow: hidden;    &#125;\n第三步挑选相应图标并获取类名，应用于页面：12345&lt;div&gt;  &lt;svg class=icon aria-hidden=true&gt;      &lt;use xlink:href=#icon-github&gt;&lt;use&gt;  &lt;svg&gt;&lt;div&gt;\n注意⚠️在xlink:href=&quot;#&quot;后面接的就是你图标的font-class，比如我这里github的图标就是icon-github。前缀icon-并不是所有图标都会有，要根据自己图标的font-class来填写它。另外，使用symbol这种方式是不需要引用woff|eot|ttf|这些字体库的，也就是上面的unicon和font-class两步都可以省去。\n现在你可以去iconfont彩色图标库挑选你想要的彩色图标应用在页面中啦。\n创建公共的多色图标组件完成上面的第三步，你已经可以在项目中使用多色的图标了。但是作为一个有”追求”的前端，怎么能允许在每次要用到图标的时候就写那么一长串的html标签呢。我相信，你首先想到的就是把它封装成一个组件。(如果你真的想到了，恭喜你，和我心有灵犀🧡)下面以在vue中创建多色图标组件为例：第一步\n\n创建IconSvg组件\n\n首先在你的组件文件夹中创建一个IconSvg.vue文件：123456789101112131415161718192021222324252627282930313233&lt;template&gt;  &lt;svg class=&quot;svg-icon&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;use&gt;  &lt;svg&gt;&lt;template&gt;&lt;script&gt;export default &#123;  name: &apos;icon-svg&apos;,  props: &#123;    iconClass: &#123;      type: String,      required: true    &#125;  &#125;,  computed: &#123;    iconName() &#123;      return `#$&#123;this.iconClass&#125;`    &#125;  &#125;&#125;&lt;script&gt;&lt;style&gt;.svg-icon &#123;  width: 1em;  height: 1em;  font-size: 18px;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;&#125;&lt;style&gt;\n第二步\n\n注册为全局组件\n\n由于多色图标可能会在多处使用，所以我建议你将这个组件注册为全局的组件。比如我会在components文件夹下创建一个GlobalComponent文件夹，文件夹目录为：12345|-src  |-components    |-GlobalComponent      |-index.js      |-IconSvg.vue\n然后在index.js中，将其注册为全局组件：12345 存放一些全局的组件import Vue from vueimport IconSvg from .componentsIconSvg全局注册icon-svgVue.component(icon-svg, IconSvg)\n最后记得在main.js中引入：1234 main.js...import @componentsGlobalComponent  全局组件...\n第三步\n\n使用多色图标组件\n\n使用的时候只需要指定对应的font-class就可以了：1&lt;icon-svg icon-class=icon-github &gt;\n是不是感觉方便多了呢？由于icon-svg也是一个组件，所以你还可以给它加上额外的属性，比如：123456&lt;icon-svg   class=cur_pointer   style=font-size: 20px;   icon-class=icon-github   title=我是github图标&gt;\n但是在使用过程中，我碰到了一个问题。就是在你想给图标添加一个事件的时候，却是无效的。比如我先给图标添加一个点击事件：1&lt;icon-svg icon-class=icon-github  @click=onClick&gt;\nclick事件并没有触发。暂时的解决方案：使用事件修饰符native：1&lt;icon-svg icon-class=icon-github  @click.native=onClick&gt;\n有更好解决方案的大佬请评论区留言，谢谢…\n注⚠️我喜欢使用iconfont的还一个好处是它可以在一个项目中添加多个项目成员，这样在团队进行项目开发的时候是十分方便的。\n后语参考文章：手摸手，带你优雅的使用 icon知识无价，支持原创\n","tags":["前端进阶","css"],"path":"2019/07/03/webNotes/advanced/CSS/iconSvg/","external_link":""},{"title":"霖呆呆的函数式编程之路(四)","date":"2019-07-04T14:56:40.000Z","content":"组合函数到了第四章了，函数式编程的魅力似乎越来越大。\n对于函数式编程者，他们会将每个函数都当成是一个“部件”，在需要时通过组装不同的“部件”，来拼凑出一个自己想要的“模型”。\n专业点的角度来说，就是我们能够定义某种组合方式，来让它们成为一种新的组合函数，程序中不同的部分都可以使用这个函数。这种将函数一起使用的过程叫做组合。\n再介绍组合函数的概念之前，我们就已经使用过组合了。\n例如在之前我们的一个案例：\n1unary(adder(3))\n上面的表达式，我们将两个函数整合起来，然后将第一个函数调用产生的值(输出)当成第二个函数调用的实参(输入)。画个简图，也就是这样：\n1functionValue &lt;-- unary &lt;-- adder &lt;-- 3\n3 是 adder(..) 的输入。而 adder(..) 的输出是 unary(..) 的输入。unary(..) 的输出是 functionValue。 这就是 unary(..) 和 adder(..) 的组合。\nCompose2函数为了满足上面组合函数的要求，我们可以来构造这么一个简单的函数：\n1234567891011function compose2(fn2,fn1) &#123;\treturn function composed(origValue)&#123;\t\treturn fn2( fn1( origValue ) );\t&#125;;&#125; ES6 箭头函数形式写法var compose2 =\t(fn2,fn1) =&gt;\t\torigValue =&gt;\t\t\tfn2( fn1( origValue ) );\n它能够自动创建两个函数的组合，这和我们手动做的是一模一样的。\nWords案例现在有这么一个需求，需要将给定的一个英文字符串，提取其中全部的英文单词，先全部转化小写，然后去除其中重复的单词。\n我们可以先来创建这么2个函数：\n123456789101112131415161718192021function words(str) &#123;\treturn String( str )\t\t.toLowerCase()\t\t.split( s|b )\t\t.filter( function alpha(v)&#123;\t\t\treturn ^[w]+$.test( v );\t\t&#125; );&#125;function unique(list) &#123;\tvar uniqList = [];\tfor (let i = 0; i &lt; list.length; i++) &#123;\t\t value not yet in the new list?\t\tif (uniqList.indexOf( list[i] ) === -1 ) &#123;\t\t\tuniqList.push( list[i] );\t\t&#125;\t&#125;\treturn uniqList;&#125;\n接下来我们解析文本字符串：\n1234567891011var text = To compose two functions together, pass the output of the first function call as the input of the second function call.;var wordsFound = words( text );var wordsUsed = unique( wordsFound );wordsUsed; [to,compose,two,functions,together,pass, the,output,of,first,function,call,as, input,second]\n在上面的例子中，我们将该过程分为了2步来做。\n并且先创建了wordsFound函数，然后将该函数的输出再传递给unique,实际上，上面的效果等同于：\n1var wordsUsed = unique( words(text) )\n所以我们可以将其封装一层：\n12345function uniqueWords(str) &#123;\treturn unique( words( str ) );&#125;var wordsUsed = uniqueWords(text)\n你会发现，其实我们还可以这样写：\n123var uniqueWords = compose2( unique, words )var wordsUsed = uniqueWords(text)\n这样我们就成功将uniqueWords转化为了无形参的函数。\nuniqueWords(..) 接收一个字符串并返回一个数组。它是 unique(..) 和 words(..) 的组合，并且满足我们的数据流向要求：\n1wordsUsed &lt;-- unique &lt;-- words &lt;-- text\ncompose函数在上面我们构造了compose2函数，它能接收2个函数，并将2个函数从右向左的执行。\n如果我们能够定义两个函数的组合，我们也同样能够支持组合任意数量的函数。任意数目函数的组合的通用可视化数据流如下：\n1finalValue &lt;-- func1 &lt;-- func2 &lt;-- ... &lt;-- funcN &lt;-- origValue\n我们能够像这样实现一个通用 compose(..) 实用函数：\n1234567891011121314151617181920212223242526272829function compose(...fns) &#123;\treturn function composed(result)&#123;\t\t 拷贝一份保存函数的数组\t\tvar list = fns.slice();\t\twhile (list.length &gt; 0) &#123;\t\t\t 将最后一个函数从列表尾部拿出\t\t\t 并执行它\t\t\tresult = list.pop()( result );\t\t&#125;\t\treturn result;\t&#125;;&#125; ES6 箭头函数形式写法var compose =\t(...fns) =&gt;\t\tresult =&gt; &#123;\t\t\tvar list = fns.slice();\t\t\twhile (list.length &gt; 0) &#123;\t\t\t\t 将最后一个函数从列表尾部拿出\t\t\t\t 并执行它\t\t\t\tresult = list.pop()( result );\t\t\t&#125;\t\t\treturn result;\t\t&#125;;\n现在看一下组合超过两个函数的例子。回想下我们的 uniqueWords(..) 组合例子，让我们增加一个 skipShortWords(..)，它将所有单词字母数大于4的提取出来：\n123function skipShortWords(list) &#123;\treturn list.filter(str =&gt; str.length &gt; 4)&#125;\n让我们再定义一个 biggerWords(..) 来包含 skipShortWords(..)。我们期望等价的手工组合方式是 skipShortWords(unique(words(text)))，所以让我们采用 compose(..) 来实现它：\n1234567891011var text = To compose two functions together, pass the output of the first function call as the input of the second function call.;var biggerWords = compose( skipShortWords, unique, words );var wordsUsed = biggerWords( text );wordsUsed; [compose,functions,together,output,first, function,input,second]\n现在，让我们回忆一下第 3 章中出现的 partialRight(..) 来让组合变的更有趣。我们能够构造一个由 compose(..) 自身组成的右偏函数应用，通过提前定义好第二和第三参数（unique(..) 和 words(..)）；我们把它称作 filterWords(..)（如下）。\n然后，我们能够通过多次调用 filterWords(..) 来完成组合，但是每次的第一参数却各不相同。\n123456789101112131415161718function skipShortWords(list) &#123;\treturn list.filter(str =&gt; str.length &gt; 4)&#125;function skipLongWords(list) &#123; \treturn list.filter(str =&gt; str.length &lt;= 4)&#125;var filterWords = partialRight( compose, unique, words );var biggerWords = filterWords( skipShortWords );var shorterWords = filterWords( skipLongWords );biggerWords( text ); [compose,functions,together,output,first, function,input,second]shorterWords( text ); [to,two,pass,the,of,call,as]\n花些时间考虑一下基于 compose(..) 的右偏函数应用给了我们什么。\n 甚至我们可以结合前面一章的not和when、identity函数来重构一下：\n123456789101112131415161718192021222324252627282930313233343536373839404142 取反辅助函数function not(predicate) &#123;    return function negated(...args) &#123;        return !predicate(...args)    &#125;&#125; 判断某个条件成立之后执行fnfunction when(predicate, fn) &#123;    return function conditional(...args) &#123;        if (predicate(...args)) &#123;            return fn(...args)        &#125;    &#125;&#125; 传一个返回一个function identity(v) &#123;    return v;&#125;var isLong = (str) =&gt; str.length &gt; 4;var isShort = not(isLong)var returnLong = when(isLong, identity)var returnShort = when(isShort, identity)function skipShortWords(list) &#123;    return list.filter(str =&gt; returnLong(str))&#125;function skipLongWords(list) &#123;    return list.filter(str =&gt; returnShort(str))&#125;var filterWords = partialRight(compose, unique, words)var biggerWords = filterWords(skipShortWords)var shorterWords = filterWords(skipLongWords)biggerWords( text ); [compose,functions,together,output,first, function,input,second]shorterWords( text ); [to,two,pass,the,of,call,as]\ncompose的不同实现方式reduce实现123456789101112131415function compose(...fns) &#123;\treturn fns.reverse().reduce( function reducer(fn1,fn2)&#123;\t\treturn function composed(...args)&#123;\t\t\treturn fn2( fn1( ...args ) );\t\t&#125;;\t&#125; );&#125; ES6 箭头函数形式写法var compose =\t(...fns) =&gt;\t\tfns.reverse().reduce( (fn1,fn2) =&gt;\t\t\t(...args) =&gt;\t\t\t\tfn2( fn1( ...args ) )\t\t);\n递归实现12345678910111213141516171819202122232425262728function compose(...fns) &#123;\t 拿出最后两个参数\tvar [ fn1, fn2, ...rest ] = fns.reverse();\tvar composedFn = function composed(...args)&#123;\t\treturn fn2( fn1( ...args ) );\t&#125;;\tif (rest.length == 0) return composedFn;\treturn compose( ...rest.reverse(), composedFn );&#125; ES6 箭头函数形式写法var compose =\t(...fns) =&gt; &#123;\t\t 拿出最后两个参数\t\tvar [ fn1, fn2, ...rest ] = fns.reverse();\t\tvar composedFn =\t\t\t(...args) =&gt;\t\t\t\tfn2( fn1( ...args ) );\t\tif (rest.length == 0) return composedFn;\t\treturn compose( ...rest.reverse(), composedFn );\t&#125;;\npipe函数我们早期谈及的是从右往左顺序的标准 compose(..) 实现。这么做的好处是能够和手工组合列出参数（函数）的顺序保持一致。\n不足之处就是它们排列的顺序和它们执行的顺序是相反的，这将会造成困扰。同时，不得不使用 partialRight(compose, ..) 提早定义要在组合过程中 第一个 执行的函数。\n相反的顺序，从右往左的组合，有个常见的名字：pipe(..)。\npipe(..) 与 compose(..) 一模一样，除了它将列表中的函数从左往右处理。\n123456789101112function pipe(...fns) &#123;\treturn function piped(result)&#123;\t\tvar list = fns.slice();\t\twhile (list.length &gt; 0) &#123;\t\t\t 从列表中取第一个函数并执行\t\t\tresult = list.shift()( result );\t\t&#125;\t\treturn result;\t&#125;;&#125;\n实际上，我们只需将 compose(..) 的参数反转就能定义出来一个 pipe(..)。\n1var pipe = reverseArgs( compose );\n回忆下之前的通用组合的例子：\n1var biggerWords = compose( skipShortWords, unique, words );\n以 pipe(..) 的方式来实现，我们只需要反转参数的顺序：\n1var biggerWords = pipe( words, unique, skipShortWords );\npipe(..) 的优势在于它以函数执行的顺序排列参数，某些情况下能够减轻阅读者的疑惑\n抽象先来介绍2个简单且实用的函数\nprop函数将任意对象的任意属性通过属性名提取出来。让我们把这个实用函数称为 prop(..)：\n12345678function prop(name,obj) &#123;\treturn obj[name];&#125; ES6 箭头函数形式var prop =\t(name,obj) =&gt;\t\tobj[name];\n使用：\n1234var obj = &#123; x: 1, y: 2 &#125;prop(&apos;x&apos;, obj) 1\nsetProp函数我们处理对象属性的时候，也需要定义下反操作的工具函数：setProp(..)，为了将属性值设到某个对象上。\n12345function setProp(name,obj,val) &#123;\tvar o = Object.assign( &#123;&#125;, obj );\to[name] = val;\treturn o;&#125;\n使用：\n1234var obj = &#123; x: 1, y: 2 &#125;var obj2 = setProp(z, obj, 3) &#123; x: 1, y: 2, z: 3 &#125;\nmakeObjProp函数12345678function makeObjProp(name,value) &#123;\treturn setProp( name, &#123;&#125;, value );&#125; ES6 箭头函数形式var makeObjProp =\t(name,value) =&gt;\t\tsetProp( name, &#123;&#125;, value );\n提示： 这个实用函数在 Ramda 库中被称为 objOf(..)。\n回顾ajax案例让我们回顾一下第二章介绍的ajax案例\n12345678910111213function ajax (url, data, callback) &#123;\t ...&#125;var getUser = partial( ajax, apiuser );var getLastOrder = partial( ajax, apiorder, &#123; orderId: -1 &#125; );var output = (str) =&gt; console.log(sgr);getLastOrder(function orderFound(order) &#123;  getUser(&#123; userId: order.userId &#125;, function userFound (user) &#123;    output(user.name)  &#125;)&#125;)\n如上，我们在给getLastOrder函数传递最后一个参数(一个回调函数orderFound)\n该函数用查询到的订单信息order中的userId查询当前订单的用户，并输出用户的姓名name.\n可以看到上面的函数需要order和user两个形参。\n我们可以用现有的函数式编程的知识将其转化为一个无形参的函数getLastOrder.\n移除user形参从里向外，我们先想想如何移除user这个形参。\n首先output函数是需要接收user.name这个参数的。我们可以用什么样的方式来移除这个参数呢。\n在这里我们的目的是想要获取user中的name属性：\n定义一个extractName函数：\n1var extractName = partial(prop, name)\n之后我们就可以直接用：\n1extractName(user)\n这样的方式获取到user.name\n接着你是不是也想到可以用compose了呢？\n1var outputUserName = compose( output, extractName )\n想一下我们需要的数据流是什么样：\n1output &lt;-- extractName &lt;-- user\n下一步，让我们缩小关注点，看下例子中嵌套的这块查找操作的调用：\n123getLastOrder( function orderFound(order)&#123;\tgetUser( &#123; userId: order.userId&#125;, outputUserName );&#125; );\n我们刚刚创建的 outputUserName(..) 函数是提供给 getUser(..) 的回调。所以我们还能定义一个函数叫做 processUser(..) 来处理回调参数，使用 partialRight(..)：\n1var processUser = partialRight( getUser, outputUserName )\n让我们用新函数来重构下之前的代码：\n123getLastOrder(function orderFound(order) &#123;\tprocessUser(&#123; userId: order.userId &#125;)&#125;)\nOk，至此，user这个形参已经被我们干掉了。\n移除order形参接下来你可以用类似的方式移除掉order形参。\n首先是获取userId\n1var extractUserId = partial(prop, userId)\n接着你需要定义一个函数来解决{ userId: order.userId }这个问题。我们可以使用上面的makeObjProp函数：\n1var userData = partial(makeObjProp, userId)\n为了使用 processUser(..) 来完成通过 order 值查找一个人的功能，我们需要的数据流如下：\n1processUser &lt;-- userData &lt;-- extractUserId &lt;-- user\n所以我们只需要再使用一次 compose(..) 来定义一个 lookupUser(..) ：\n1var lookupUser = compose( processUser, userData, extractUserId )\n完整流程然后，就是这样了！把这整个例子重新组合起来，不带任何的“形参”：\n12345678910111213141516function ajax (url, data, callback) &#123;\t ...&#125;;var getUser = partial( ajax, apiuser );var getLastOrder = partial( ajax, apiorder, &#123; orderId: -1 &#125; );var output = (str) =&gt; console.log(sgr);var extractName = partial(prop, name);var outputUserName = compose( output, extractName );var processUser = partialRight( getUser, outputUserName )var extractUserId = partial(prop, userId)var userData = partial(makeObjProp, userId)var lookupUser = compose( processUser, userData, extractUserId )getLastOrder( lookupUser )\nLook!不带任何的形参。\n总结\n函数组合是一种定义函数的模式，它能将一个函数调用的输出路由到另一个函数的调用上，然后一直进行下去。\n因为 JS 函数只能返回单个值，这个模式本质上要求所有组合中的函数（可能第一个调用的函数除外）是一元的，当前函数从上一个函数输出中只接收一个输入。\n相较于在我们的代码里详细列出每个调用，函数组合使用 compose(..) 实用函数来提取出实现细节，让代码变得更可读，让我们更关注组合完成的是什么，而不是它具体做什么。\n组合 ———— 声明式数据流 ———— 是支撑函数式编程其他特性的最重要的工具之一。\n\n","tags":["前端进阶","Functional"],"path":"2019/07/04/webNotes/advanced/Functional/ch_4/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class="tagcloud-container">
<div class="tag-cloud">
	<a href="/tags/Angular/" style="font-size: 1.49em; color: #995f51">Angular</a> <a href="/tags/ES6/" style="font-size: 0.8em; color: #488baf">ES6</a> <a href="/tags/ES7/" style="font-size: 0.8em; color: #488baf">ES7</a> <a href="/tags/ES9/" style="font-size: 0.8em; color: #488baf">ES9</a> <a href="/tags/Functional/" style="font-size: 1.31em; color: #856a68">Functional</a> <a href="/tags/Git/" style="font-size: 0.8em; color: #488baf">Git</a> <a href="/tags/Html/" style="font-size: 1.49em; color: #995f51">Html</a> <a href="/tags/JQuery/" style="font-size: 1.49em; color: #995f51">JQuery</a> <a href="/tags/JavaScript/" style="font-size: 1.66em; color: #ad5439">JavaScript</a> <a href="/tags/canvas/" style="font-size: 1.31em; color: #856a68">canvas</a> <a href="/tags/css/" style="font-size: 1.31em; color: #856a68">css</a> <a href="/tags/hexo/" style="font-size: 0.97em; color: #5c8097">hexo</a> <a href="/tags/http/" style="font-size: 0.8em; color: #488baf">http</a> <a href="/tags/mySql/" style="font-size: 0.8em; color: #488baf">mySql</a> <a href="/tags/navicat/" style="font-size: 0.8em; color: #488baf">navicat</a> <a href="/tags/npm/" style="font-size: 0.8em; color: #488baf">npm</a> <a href="/tags/php/" style="font-size: 0.8em; color: #488baf">php</a> <a href="/tags/vscode/" style="font-size: 0.8em; color: #488baf">vscode</a> <a href="/tags/vue/" style="font-size: 1.14em; color: #717580">vue</a> <a href="/tags/webpack/" style="font-size: 0.8em; color: #488baf">webpack</a> <a href="/tags/其它技能/" style="font-size: 1.14em; color: #717580">其它技能</a> <a href="/tags/前端入门/" style="font-size: 1.83em; color: #c24922">前端入门</a> <a href="/tags/前端进阶/" style="font-size: 2em; color: #d63e0a">前端进阶</a> <a href="/tags/微信小程序/" style="font-size: 0.97em; color: #5c8097">微信小程序</a> <a href="/tags/面试/" style="font-size: 0.8em; color: #488baf">面试</a>
</div>
</div>

  </div>

  

<footer id="footer">
    <div class="footer-copyright">
        <div>
            <p> 版权所有 <a href="">LinDaiDai </a> @ 2019</p>
            <!--<p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>-->
        </div>
    </div>
    
    <div class="footer-social">
        
            
                
                    <div class="footer-social-item"><a href="https://github.com/LinDaiDai" target="_blank"><i class="fab fa-github fa-2x" aria-hidden="true"></i></a></div>
                
            
                
                    <div class="footer-social-item"><a href="https://github.com/LinDaiDai" target="_blank"><i class="fab fa-weixin fa-2x" aria-hidden="true"></i></a></div>
                
            
                
                    <div class="footer-social-item"><a href="https://github.com/LinDaiDai" target="_blank"><i class="fab fa-qq fa-2x" aria-hidden="true"></i></a></div>
                
            
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
		
			
				
			
		
		
	
		
			
		
		
	
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="归档">
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon active_dot">
		
			<a href="/search/" title="搜索">
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/home/">
							<span>首页</span>
						</a>
					</div>
			</div>
		
		
			
			
				
			
				
			
				
			
				
			
				
			
				
			
		
			<div class="nav-more-item">
					<div class="nav-name">
						<a class="nav-link" href="/about/">
							<span>关于</span>
						</a>
					</div>
			</div>
		
		
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/php/">
						<span>Php</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/mySql/">
						<span>Mysql</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/其它技能/">
						<span>其它技能</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/vscode/">
						<span>Vscode</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端进阶/">
						<span>前端进阶</span>
					</a>
				</div>
		</div>
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/前端入门/">
						<span>前端入门</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    

    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        appId: '0Nyr31J74bB24hrKnRrheEdf-gzGzoHsz',
        appKey: 'RYPhOnr007gXeWPQr3V1VFHH',
        placeholder: '说点什么吧...',
        path:window.location.pathname, 
        avatar:'monsterid',
        lang: 'zh-cn',
        visitor: true // 阅读量统计
    });
</script>









    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type="text/javascript">

  
</script>


    
<script type="text/javascript">
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant="" type="text/javascript">

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
